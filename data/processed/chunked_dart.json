[
  ". Welcome \u2022 React Native. Created by Facebook, it is based on javascript; \u2022 Xamarin. Created by Microsoft, it uses the C#; \u2022 Firemonkey. Created by Embarcadero, it uses Delphi. During the reading of the book you will see how Google tries to make the cross-platform devel- opment production-ready using the Dart programming language and the Flutter UI framework. You will learn that Flutter renders everything by itself 1 in a very good way and it doesn\u2019t use any intermediate bridge to communicate with the OS. It compiles directly to ARM (for mobile) or optimized JavaScript (for web). ..1 Who is this book for To get the most out of this book, you should already know the basics of object-oriented pro- gramming and preferably at least an \"OOP language\" such as Java or C#. Our goal is trying to make the contents of this book understandable for the widest possible range of developers. Nevertheless, you should already have a minimum of experience in order to better understand the concepts. If you already know what is a class, what is inheritance and what is nullability, part 1 of this book is going to be a walk in the park. Foreknowledge aside, we will talk about both Dart and Flutter \"from scratch\" so that the reader can understand any concept regardless the expertise level. ..2 Author Alberto Miola is an Italian software developer that started working with Delphi (Object Pascal) for desktop development and Java for back-end and Android apps. He currently works in Italy where he daily uses Flutter for mobile and Java for desktop and back-end. Alberto graduated 1For example, it doesn\u2019t use the system\u2019s OEM widgets Flutter Complete Reference 16",
  ". Welcome in computer science at University of Padua with a thesis about cross-platform frameworks and OOP programming languages. ..3 Acknowledgments This book owes a lot to some people the author has to mention here because he thinks it\u2019s the minimum he can do to express his gratitude. They have technically supported the realization of this book with their fundamental comments and critiques that improved the quality of the contents. \u2022 R\u00e9mi Rousselet. He is the author of the famous \"provider\" 2 package and a visible member in the Flutter/Dart community. He actively answers on stackover\ufb02ow.com helping tons of people and constantly works in the creation of open source projects. \u2022 Felix Angelov. Felix is a Senior Software Engineer at Very Good Ventures. He previously worked at BMW for 3 years and is the main maintainer of the bloc state management library. He has been building enterprise software with Flutter for almost 2 years and loves the technology as well as the amazing community. \u2022 Matej Re\u0161et\u00e1r. He is helping people get prepared for real app development on re- socoder.com and also on the Reso Coder YouTube channel. Flutter is an amazing framework but it is easy to write spaghetti code in it. That\u2019s why he\u2019s spreading the message of proper Flutter app architecture. Special thanks to my friends Matthew Palomba and Alfred Schilken which carefully read the book improving the style and the quality of the contents. ..4 Online resources and the quiz The o\ufb03cial website of this book 3 contains the source code of the examples described in Part III. While reading the chapters you might encounter this box: B Resources >",
  "> Files download 2https://pub.dev/packages/provider 3https://\ufb02uttercompletereference.com Flutter Complete Reference 17",
  ". Welcome It indicates that if you navigate to the Resources page of our website, you\u2019ll \ufb01nd the complete source code of the example being discussed at",
  "> Files download. In addition, you can play the \"Quiz game\" which will test the Dart and Flutter skills you\u2019ve acquired reading this book. At the end, the result page will tell you the exact page of the book at which you can \ufb01nd an explanation of the answer. .2 Introduction to Dart Dart is a client-optimized, garbage-collected, OOP language for creating fast apps that run on any platform. If you are familiar with an object oriented programming language such as Java or C# you might \ufb01nd many similarities with Dart. The \ufb01rst part of this book aims to show how the language can help you solving problems and the vastness of its API. ..1 Supported platforms Dart is a very \ufb02exible language thanks to the environment in which it lives. Once the source code has been written (and tested) it can be deployed in many di\ufb00erent ways: Flutter Complete Reference 18",
  ". Welcome \u2022 Stand-alone. In the same way as a Java program can\u2019t be run without the Java Virtual Machine (JVM), a stand-alone Dart program can\u2019t be executed without the Dart Virtual Machine (DVM). There\u2019s the need to download and install the DVM which to execute Dart in a command-line environment. The SDK, other than the compiler and the libraries, also o\ufb00ers a series of other tools: \u2013 the pub package manager, which will be explored in detail in chapter ; \u2013 dart2js, which compiles Dart code to deployable JavaScript; \u2013 dartdoc, the Dart documentation generator; \u2013 dartfmt, a code formatter that follows the o\ufb03cial style guidelines. In other words, with the stand-alone way you\u2019re creating a Dart program that can only run if the DVM is installed. To develop Flutter apps for any platform (mobile, web and desktop), instead of installing the \"pure\" Dart SDK, you need to install Flutter  (which is basically the Dart SDK combined with Flutter tools). \u2022 AOT compiled. The Ahead Of Time compilation is the act of translating a high-level programming language, like Dart, into native machine code. Basically, starting from the Dart source code you can obtain a single binary \ufb01le that can execute natively on a certain operating system. AOT is really what makes Flutter fast and portable. With AOT there is NO need to have the DVM installed because at the end you get a single binary \ufb01le (an .apk or .aab for Android, an .ipa for iOS, an .exe for Windows...) that can be executed. \u2013 Thanks to the Flutter SDK you can AOT compile your Dart code into a native binary 4https://\ufb02utter.dev/docs/get-started/install Flutter Complete Reference 19",
  ". Welcome for mobile, web and desktop. \u2013 As of Flutter ., the Dart SDK is included in the Flutter SDK so you don\u2019t have to install them separately. They\u2019re all bundled in a single install package. \u2013 Starting from version ., the dart2native command (supported on Windows, macOS and Linux) makes AOT compiles a Dart program into x64 native machine code. The output is a standalone executable \ufb01le. AOT compilation is very powerful because it natively brings Dart to mobile desktop. You\u2019ll end up having a single native binary which doesn\u2019t require a DVM to be installed on the client in order to run the application. \u2022 Web. Thanks to the dart2js tool, your Dart project can be \"transpiled\" into fast and compact JavaScript code. By consequence Flutter can be run, for example, on Firefox or Chrome and the UI will be identical to the other platforms. AngularDart 5 is a performant web app framework used by Google to build some famous websites, such as \"AdSense\" and \"AdWords\". Of course it\u2019s powered by Dart! So far we\u2019ve covered what you can do with Dart when it comes to deployment and production- ready software. When you have to debug and develop, both for desktop/mobile and web, there are useful some tools coming to the rescue. 5https://angulardart.dev/ Flutter Complete Reference 20",
  ". Welcome This picture sums up very well how the Dart code can be used in development and deploy- ment. We\u2019ve just covered the \"Deploy\" side in the above part, so let\u2019s analyze the \"Develop\" column: \u2022 Desktop/mobile. The Just In Time (JIT) technique can be seen as a \"real time trans- lation\" because the compilation happens while the program is executing. It\u2019s a sort of \"dynamic compilation\" which happens while the program is being used. JIT compilation, combined with the DVM (JIT + VM in the picture), allows the dispatch of the code dynamically without considering the user\u2019s machine architecture. In this way it\u2019s possible to smoothly run and debug the code everywhere without having to mess up with the underlying architecture. \u2022 Web. The Dart development compiler, abbreviated with dartdevc, allows you to run and debug Dart web apps on Google Chrome. Note that dartdevc is for development only: for deployment, you should use dart2js. Using special tools like webdev 6 there\u2019s the possibility to edit Dart \ufb01les, refreshing Chrome and visualizing changes almost immediately. As you\u2019ve just seen, Dart can run literally everywhere: desktop, mobile and web. This book will give you a wide overview of the language (Dart version ., with null safety support) and all the required skills to create easily maintainable projects. 6https://dart.dev/tools/webdev#serve Flutter Complete Reference 21",
  ". Welcome ..2 Package system Dart\u2019s core API o\ufb00ers di\ufb00erent packages, such as dart:io or dart:collection, that expose classes and methods for many purposes. In addition, there is an o\ufb03cial online repository called pub containing packages created by the Dart team, the Flutter team or community users like you. If you head to https://pub.dev you will \ufb01nd an endless number of packages for any purpose: I/O handling, XML serialization/de-serialization, localization, SQL/NoSQL database utilities and much more. . Go to https://pub.dev, the o\ufb03cial repository; . Let\u2019s say you\u2019re looking for an equation solving library. Type \"equations\" in the search bar and \ufb01lter the results by platform. Some packages are available only for Dart, others only for Flutter and a good part works for both; . The page of the package contains an installation guide, an overview and a guide so that you won\u2019t get lost. You should check the amount of likes received by the community and the overall reputation of the package because those values indicate how mature and healthy the product is. You will learn how to properly write a library and how to upload it to the pub.dev repository in order to give your contribution to the growth of the community. ..3 Hello World The simplest way you have to run your Dart code is by opening DartPad , an open-source compiler that works in any modern browser. Clicking on \"New Pad\" you can decide whether creating a new Dart or Flutter project (with latest stable version of the SDK). 7https://dartpad.dartlang.org/ Flutter Complete Reference 22",
  ". Welcome It\u2019s the perfect tool for the beginners that want to play with Dart and try the code. If you\u2019re new to the language, start using DartPad (which is absolutely not and IDE). It always has the latest version of the SDK installed and it\u2019s straightforward to use. void main() { // Best food worldwide! print(\"pasta pizza maccheroni\"); } Like with Java and C++, any Dart program has to de\ufb01ne a function called main() which is the entry point of the application. Very intuitively the print() method outputs to the console, on the right of the DartPad, a string. Starting from chapter , you\u2019ll begin to learn the syntax and the good practices that a programmer should know about Dart. When you develop for real world applications, you\u2019re going to download the whole SDK and use an IDE like IntelliJ IDEA, Android Studio or VS Code. DartPad doesn\u2019t give you the possibility to setup tests, import external packages, add dependencies and test your code. Flutter Complete Reference 23",
  ". Welcome .3 Intorduction to Flutter Flutter is an UI toolkit for building natively compiled applications for mobile, desktop and web with a single codebase. At the time of writing this book, only Flutter for mobile is stable and ready for production. Web support is currently in beta while desktop (macOS, Linux and Windows) is in early alpha: they will be covered in a future release of this reference once they will be o\ufb03cially released as stable builds. Being familiar with Jetpack compose or React Native is surely an advantage because the concepts of reactive views and \"components tree\" are the fundamentals of the Flutter framework. ..1 How does it work This picture shows how a native app interacts with the OS, whether it\u2019s been written in Kotlin (or Java) for Android or Swift (or Objective-C) for iOS. We\u2019re going to use these 2 platforms as examples in this section. Flutter Complete Reference 24",
  ". Welcome . The platform, which can be Android or iOS, exposes a series of OEM widgets used by the app to build the UI. Those widgets are fundamental because they give our app the capabilities to paint the UI, use the canvas and respond to events such as \ufb01nger taps. . If you wanted to take a picture from your app or use the bluetooth to send a \ufb01le, there would be the need to communicate with the native API exposed by the platform. For example, using OS-speci\ufb01c APIs, you could ask for the camera service, wait for a response and then start using it. The cross-platform approach is di\ufb00erent and it has to be like so. If you want your app to run on both Android and iOS with the same codebase, you can\u2019t directly use OEM widgets and their API because they come from di\ufb00erent architectures. They are NOT compatible. On the hardware side however, both are based on the ARM architecture (precisely, v7 and v8) and the most re- cent versions have -bit support. Flutter AOT compiles the Dart code into native ARM libraries. \u009f ARM is a family of RISC microprocessors (32 and 64 bit) widely used in embed- ded systems. It dominates the mobile world thanks to its qualities: low costs, good heat dissipation and a longer battery life thanks to a low power consumption. The picture has rectangles on Android and triangles on iOS to indicate that OEM widgets and Flutter Complete Reference 25",
  ". Welcome APIs have di\ufb00erences in how they are structured, in how they interact with the app and in how you have to use them. For this reason, cross-platform apps cannot directly \"talk\" to the under- lying environment: they must speak a language that everyone can understand. \u009f Try to only think about the runtime environment for a moment. If you wrote a Java Android app, it would be compiled to work with the ART ecosystem (Android RunTime): how could the same binary \ufb01le work with iOS architecture which is com- pletely di\ufb00erent and has no ART? In the above image, squares represents calls made by Java to interact with the ART which is available only in Android and not on iOS. This compatibility problem is solved by cross-platform frameworks. ReactJS is a Reactive web framework which tries to solve the above problem by adding a bridge in the middle that takes care of the communication with the platform. With this approach, the bridge becomes the real starring of the scene it acts like a translator: . The bridge always exposes the same interface to the app so that it doesn\u2019t care anymore about the OS it\u2019s running on; . The bridge has an implementation of OEMs and APIs for each platform to allow the app to correctly work in many environments. In this way, you have a native app in the sense that it uses the native tools given by the OS, but there\u2019s still an \"adapter\" in the middle. Flutter Complete Reference 26",
  ". Welcome As you can see from the picture, the bridge is an abstraction layer between the app the OS in which it\u2019s hosted. Of course, there has to be a bridge for each supported platform but that\u2019s not something you have to deal with because the developers of the framework will take care of creating all of them. \u009f If you used a cross-platform framework, you\u2019d just need to care about creating the app with the code and the API exposed by the framework. The implementation of the bridge is already in the internals of the SDK and it\u2019s automatically \"attached\" to the app in the build phase. You don\u2019t have to create the bridge. The bridge approach is quite popular, but it could be a potential bottleneck that slows down the execution and thus the performances might drop. If you think about animations, swipes or transitions, widgets are accessed very often and many of them running at the same time could slow down the app. Flutter adopts a completely di\ufb00erent strategy: It uses its own very e\ufb03cient rendering engine, called Skia, to paint the UI so that OEM widgets are not needed anymore. In this way, the app doesn\u2019t rely on the instruments the OS exposes to draw the interface and you can freely control each single pixel of the screen. \u2022 Flutter produces native ARM code for the machine; Flutter Complete Reference 27",
  ". Welcome \u2022 when launched, the app loads the Flutter library. Any rendering, input or event handling, and so on, is delegated to the compiled Flutter and app code. This is much faster than having a bridge. \u2022 A minimal Flutter app is about .4 MB on Android and .9 MB on iOS (depending on the architecture, whether it be ARM 32 or 64 bit) 8 The true power of Flutter lies on the fact that apps are built with their own rendering stu\ufb00and they are not constrained to paint the UI following the rules \"imposed\" by OEM widgets. You\u2019re free to control the screen and manipulate every single pixel. ..2 Why Flutter uses Dart There are many reasons behind the decision made by Google to choose Dart as language for the Flutter framework. At the time of writing this book, the latest stable version of Dart is .. (Dart .10 is on beta, but downloadable anyway). Here\u2019s a summary 9 of what brought them to make this choice. . OOP style. The vast majority of developers have object-oriented programming skills and thus Dart would be easy to learn as it adopts most of the common OOP patterns. The developer doesn\u2019t have to deal with a completely new way of coding; he can reuse what he already knows and integrate it with the speci\ufb01c details of Dart. . Performances. In order to guarantee high performances and avoid frame dropping during the execution of the app, there\u2019s the need of a high performance and predictable language. Dart can guarantee to be very e\ufb03cient and it provides a powerful memory allocator that handles small, short-lived allocations. This is perfect for Flutter\u2019s functional-style \ufb02ow. . Productivity. Flutter allows developers to write Android, iOS, web and desktop apps with a single codebase keeping the same performances, aspect and feeling in each plat- form. A highly productive language like Dart accelerates the coding process and makes the framework more attractive. . Both Flutter and Dart are developed by Google which can freely decide what to do with them listening to the community as well. If Dart was developed by another company, Google probably wouldn\u2019t have the same freedom of choice in implementing new features and and the language couldn\u2019t evolve at the desired pace. Another important aspect is that Dart is strongly typed, meaning that the compiler is going 8https://\ufb02utter.dev/docs/resources/faq#how-big-is-the-\ufb02utter-engine 9https://\ufb02utter.dev/docs/resources/faq#why-did-\ufb02utter-choose-to-use-dart Flutter Complete Reference 28",
  ". Welcome to be very strict about types; you\u2019ll have both less runtime surprises and an easier debugging process. In addition, keep in mind that Dart is a complete swiss-knife because it has built-in support for: \u2022 tree-shaking optimization; \u2022 hot reload feature; \u2022 a package manager with mandatory documentation and the possibility to play with the code using DartPad; \u2022 DevTools, a collection of debugging and performance tools; \u2022 code documentation generator tool; \u2022 support for JIT and AOT compilation. By owning two home-made products, Google can keep the entire projects under control and decide how to integrate them in the best way possible with quick development cycles. Dart evolves together with Flutter and as time goes by: they help each other maximizing productivity and performances. ..3 Hello world When creating Flutter apps for the production world, you should really consider using Android Studio or VSCode and install the respective plugins. They o\ufb00er a debugger, hints, a friendly UI and powerful optimization tools we will explore in detail. void main() { runApp(MyApp()); } class MyApp extends StatelessWidget { const MyApp(); Widget build(BuildContext context) { return MaterialApp( home: Scaffold( body: Center( child: Text(\"Flutter app!\"), ), ), Flutter Complete Reference 29",
  ". Welcome ); } } This is a very simple example of a minimal Flutter application. You can notice immediately that there is a void main() { ... } function, required by Dart to de\ufb01ne the entry point of the program. An UI is a composition of widgets that decorate the screen with many objects; you will learn how to properly use them to create e\ufb03cient and beautiful designs. This is an example of how a simple Flutter app looks identical in two di\ufb00erent platforms. In this book we will focus on Android and iOS mobile apps but everything you\u2019re going to learn is also valid for web and desktop because it\u2019s always Flutter. Once you have the code ready, open the console... Flutter Complete Reference 30",
  ". Welcome $ flutter build appbundle $ flutter build ios $ flutter build web $ flutter build macos $ flutter build windows $ flutter build linux ...and it\u2019s just a matter of running di\ufb00erent build commands to get di\ufb00erent native binaries of the same app. For more info on Flutter for web and desktop, see the appendix B at the bottom of the book. Flutter Complete Reference  \"I\u2019m not a great programmer; I\u2019m just a good programmer with great habits.\" Martin Fowler Part I The Dart programming language   | Variables and data types .1 Variables As in any programming language, variables are one of the basics and Dart comes with support for type inference. A typical example of creation and initialization of a variable is the following: var value = ; var myName = \"Alberto\" In the example, value is an integer while myName is a string. Like Java and C#, Dart is able to infer the type of the variable by looking at the value you\u2019ve assigned. In other words, the Dart compiler is smart enough to \ufb01gure out by itself which is the correct type of the variable. int value = ; String myName = \"Alberto\" This code is identical to the preceding example with the only di\ufb00erence that here the types have been typed explicitly. There would also be a third valid way to initialize variables, but you should almost never use it. dynamic value = ; dynamic myName = \"Alberto\" dynamic can be used with any type, it\u2019s like a \"jolly\": any value can be assigned to it and the compiler won\u2019t complain. The type of a dynamic variable is evaluated at runtime and thus, for a proper usage, you\u2019d need to work with checks and type casts. According with the Dart guidelines and our personal experience you should: . Prefer initializing variables with var as much as you can; . When the type is not so easy to guess, initialize it explicitly to increase the readability of the code; Flutter Complete Reference 35",
  ". Variables and data types . Use Object or dynamic only if it\u2019s really needed but it\u2019s almost never the case. Actually, we could say that dynamic is not really a type: it\u2019s more of a way to turn o\ufb00static analysis and tell the compiler you know what you\u2019re doing. The only case in which you\u2019ll deal with it will come in the Flutter part in regard to JSON encoding and decoding. ..1 Initialization The o\ufb03cial Dart guidelines 1 state that you should prefer, in most of the cases, the initialization with var rather than writing the type explicitly. Other than making the code shorter (program- mers are lazy!) it can increase the readability in various scenarios, such as: // BAD: hard to read due to nested generic types List<List<Toppings>> pizza = List<List<Toppings>>(); for(List<Toppings> topping in pizza) { doSomething(topping); } // GOOD: the reader doesn't have to \"parse\" the code // It's clearer what's going on var pizza = List<List<Toppings>>(); for(var topping in pizza) { doSomething(topping); } Those code snippets use generics, classes and other Dart features we will discuss in depth in the next chapters. It\u2019s worth pointing out two examples in which you want to explicitly write the type instead of inferring it: \u2022 When you don\u2019t want to initialize a variable immediately, use the late keyword. It will be explained in detail later in this chapter. // Case 1 late List<String> names; if (iWantFriends()) names = friends.getNames(); else names = haters.getNames(); 1https://dart.dev/guides/language/e\ufb00ective-dart/design#types Flutter Complete Reference 36",
  ". Variables and data types If you used var instead of List<String> the inferred type would have been null and that\u2019s not what we want. You\u2019d also lose the type safety and readability. \u2022 The type of the variable is not so obvious at \ufb01rst glance: // Is this a list? I guess so, \"People\" is plural... // but actually the function returns a String! var people = getPeople(true, ); // Ok, this is better String people = getPeople(true, ); However, there isn\u2019t a golden rule to follow because it\u2019s up to your discretion. In general var is \ufb01ne, but if you feel that the type can make the code more readable you can de\ufb01nitely write it. .. \ufb01nal A variable declared as final can be set only once and if you try to change its content later, you\u2019ll get an error. For example, you won\u2019t be able to successfully compile this code: final name = \"Alberto\"; name = \"Albert\"; // 'name' is final and cannot be changed You can also notice that final can automatically infer the type exactly like var does. This keyword can be seen as a \"restrictive var\" as it deduces the type automatically but does not allow changes. // Very popular - Automatic type deduction final name = \"Alberto\"; // Generally unnecessary - With type annotation final String nickName = \"Robert\"; If you want you can also specify the type but it\u2019s not required. So far we\u2019ve only shown examples with strings, but of course both final and var can be used with complex data types (classes, enums) or methods. final rand = getRandomInteger(); // rand = ; // ^ doesn't work because the variable is final Flutter Complete Reference 37",
  ". Variables and data types The type of rand is deduced by the return statement of the method and it cannot be re-assigned in a second moment. The same advice we\u2019ve given in \"..1 Initialization\" for var can be applied here as well. \u009f Later on in the book we will analyze in detail the const keyword, which is the \"brother\" of final, and it has very important performance impacts on Flutter. While coding you can keep this rule in mind: use final when you know that, once assigned, the value will never change in the future. If you know that the value might change during the time use var and think whether it\u2019s the case to annotate the type or not. Here\u2019s an example in which a final variable \ufb01ts perfectly: void main() { // Assume that the content of the file can't be edited final jsonFile = File('myfile.json').readAsString(); checkSyntax(jsonFile); saveToDisk(jsonFile, 'file.json'); } In this example the variable jsonFile has a content that doesn\u2019t have to be modi\ufb01ed, it will always remain the same and so a final declaration is good: \u2022 it won\u2019t be accidentally edited later; \u2022 the compiler will give an error if you try to modify the value. If you used var the code would have compiled anyway but it wouldn\u2019t have been the best choice. If the code was longer and way more complicated, you could accidentally change the content of jsonFile because there wouldn\u2019t be the \"protection\" of final. .2 Data types Types in Dart can be initialized with \"literals\"; for example true is a boolean literal and \"test\" is a string literal. In chapter 6 we will analyze generic data types that are very commonly used for collections such as lists, sets and maps. Flutter Complete Reference 38",
  ". Variables and data types ..1 Numbers Dart has two type of numbers: \u2022 int. -bit at maximum, depending on the platform, integer values. This type ranges from -263 to -. \u2022 double. -bit double-precision \ufb02oating point numbers that follow the classic IEEE 754 standard de\ufb01nition. Both double and int are subclasses of num which provides many useful methods such as: \u2022 parse(string), \u2022 abs(), \u2022 ceil(), \u2022 toString()... You should always use double or int. We will see, with generic types, a special case in which num is needed but in general you can avoid it. Some examples are always a good thing: var a = ; // int var b = .; // double int x = ; double y = b + ; num z =  - y + x; // 7 is a compile-time constant const valueA = ; // Operations among constant values are constant const valueB =  * valueA; From Dart .1 onwards the assignment double a = 5 is legal. In .0 and earlier versions you were forced to write ., which is a double literal, because 5 is instead an integer literal and the compiler didn\u2019t automatically convert the values. Some special notations you might \ufb01nd useful are: . The exponential representation of a number, such as var a = .35e2 which is the equiva- lent of . * ; Flutter Complete Reference 39",
  ". Variables and data types . The hexadecimal representation of a number, such as var a = 0xF1A where 0xF1A equals to F1A in base  (3866 in base ). ...1 Good practices Very likely, during your coding journey, you\u2019ll have at some point the need to parse numbers from strings or similar kinds of manipulations. The language comes to the rescue with some really useful methods: String value = \"\"; var a = int.parse(value); // String-to-int conversion var b = double.parse(\".\"); // String-to-double conversion var c = int.parse(\"\", radix: ); // Converts from 13 base 6 You should rely on these methods instead of writing functions on your own. In the opposite direction, which is the conversion into a string, there is toString() with all its variants: String v1 = .toString(); // v1 = \"\"; String v2 = ..toString(); // v2 = \".\"; String v3 = ..toStringAsFixed(); // v3 = \".\"; Since we haven\u2019t covered functions yet you can come back to this point later or, if you\u2019re brave enough, you can continue the reading. When converting numbers from a string, the method parse() can fail if the input is malformed such as \"12_@.\". You\u2019d better use one of the following solutions (we will cover nullable types later): // . If the string is not a number, val is null double? val = double.tryParse(\"@.3x_\"); // null double? val = double.tryParse(\".\"); // . // . The onError callback is called when parsing fails var a = int.parse(\"1_6\", onError: (value) => ); // 0 var a = int.parse(\"\", onError: (value) => ); // 16 Keep in mind that parse() is deprecated: you should prefer tryParse(). What\u2019s important to keep in mind is that a plain parse(\"value\") call is risky because it assumes the string is already well-formed. Handling the potential errors as shown is safer. Flutter Complete Reference 40",
  ". Variables and data types ..2 Strings In Dart a string is an ordered sequence of UTF-16 values surrounded by either single or double quotes. A very nice feature of the language is the possibility of combining expressions into strings by using ${expr} (a shorthand to call the toString() method). // No differences between s and t var s = \"Double quoted\"; var t = 'Single quoted'; // Interpolate an integer into a string var age = ; var myAge = \"I am $age years old\"; // Expressions need '{' and '}' preceeded by $ var test = \"${.abs()}\" // This is redundant, don't do it because ${} already calls toString() var redundant = \"${.toString()}\"; A string can be either single or multiline. Single line strings are shown above using single or double quotes, and multiline strings are written using triple quotes. They might be useful when you want to nicely format the code to make it more readable. // Very useful for SQL queries, for example var query = \"\"\" SELECT name, surname, age FROM people WHERE age >= 18 ORDER BY name DESC \"\"\"; In Dart there isn\u2019t a char type representing a single character because there are only strings. If you want to access a particular character of a string you have to use the [] operator: final name = \"Alberto\"; print(name[]); // prints \"A\" print(name[]); // prints \"b\"; Flutter Complete Reference 41",
  ". Variables and data types The returned value of name[] is a String whose length is . We encourage you to visit 2 the online Dart documentation about strings which is super useful and full of examples. var s = 'I am ' + name + ' and I am ' + ().toString() + ' y.o.'; You can concatenate strings very easily with the + operator, in the classic way that most pro- gramming languages support. The o\ufb03cial Dart guidelines 3 suggest to prefer using interpolation to compose strings, which is shorter and cleaner: var s = 'I am $name. I am ${} years old'; In case of a string longer than a single line, avoid the + operator and prefer a simple line break. It\u2019s just something recommended by the Dart for styling reasons, there are no performance implications at all. Try to be as consistent as possible with the language guidelines! // Ok var s = 'I am going to the' 'second line'; // Still ok but '+' can be omitted var s = 'I am going to the' + 'second line'; Since strings are immutable, making too many concatenations with the + operator might be ine\ufb03cient. In such cases it\u2019d be better if you used a StringBuffer which e\ufb03ciently concatenates strings. For example: var value = \"\"; for(var i = ; i < ; ++i) { value += \"$i \"; } Each time the + operator is called, value is assigned with a new instance which merges the old value and the new one. In other words, this code creates for 900000 times a new String object, one for each iteration, and it\u2019s not optimal at all. Here\u2019s the way to go: var buffer = StringBuffer(); 2https://dart.dev/guides/libraries/library-tour#strings-and-regular-expressions 3https://dart.dev/guides/language/e\ufb00ective-dart/usage#prefer-using-interpolation-to-compose-strings-and- values Flutter Complete Reference 42",
  ". Variables and data types for(var i = ; i < ; ++i) buffer.write(\"$i \"); var value = buffer.toString(); This is much better because StringBuffer doesn\u2019t internally create a new string on each iteration; the string is created only once at the moment in which toString() is called. When you have to do long loops that manipulate strings, avoid using the + operator and prefer a bu\ufb00er. The same class can also be found in Java and C# for example. ..3 Enumerated types Also known as \"enums\", enumerated types are containers for constant values that can be declared with the enum keyword. A very straightforward example is the following: enum Fruits { Apple, Pear, Grapes, Banana, Orange } void main() { Fruits liked = Fruits.Apple; var disliked = Fruits.Banana; print(liked.toString()); // prints 'Fruits.Apple' print(disliked.toString()); // prints 'Fruits.Banana' } Each item of the enum has an associated number, called index, which corresponds to the zero- based position of the value in the declaration. You can access this number by using the index property. enum Fruits { Apple, Pear, Grapes, Banana, Orange } void main() { var a = Fruits.Apple.index; // 0 var b = Fruits.Pear.index; // 1 var c = Fruits.Grapes.index; //  } Note that when you need to use an enum you always have to fully qualify it. Using the name only doesn\u2019t work. Flutter Complete Reference 43",
  ". Variables and data types ...1 Good Practices When you need a prede\ufb01ned list of values which represents some kind of textual or numeric data, you should prefer an enum over a primitive data type. In this way you can increase the readability of the code, the consistency and the compile-time checking. Look at these 2 ways of creating a function (/// is used to document the code): enum Chess { King, Queen, Rook, Bishop, Knight, Pawn } /// METHOD . Checks if the piece can move in diagonal bool diagonalMoveC(Chess item) { ... } /// METHOD . Checks if a piece can move in diagonal: [item] can only be: /// . King /// . Queen /// . Rook /// . Bishop /// . Knight /// . Pawn /// Any other number is not allowed. bool diagonalMoveS(int item) { ... } This example should convince you that going for the \ufb01rst method is for sure the right choice. \u2022 diagonalMoveC(Chess item). There\u2019s a big advantage here: we\u2019re guaranteed by the compiler that item can only be one of the values in Chess. There\u2019s no need for any particular check and we can understand immediately what the method wants us to pass. \u2022 diagonalMoveS(int item). There\u2019s a big disadvantage here: we can pass any number, not only the ones from 1 to . We\u2019re going to do extra work in the body because we don\u2019t have the help of the compiler, so we need to manually check if item contains a valid value. In the second case, we\u2019d have to make a series of if conditions to check whether the value ranges from 1 to . Using an enum, the compiler does the checks for us (by comparing the types) and we\u2019re guaranteed to work with valid values. ..4 Booleans You can assign to the bool type only the literals true or false, which are both compile-time constants. Here there are a few usage examples: Flutter Complete Reference 44",
  ". Variables and data types bool test =  == ; // false bool test2 = !test; // has the opposite value of test var oops = . / .; // evaluates to 'Not a Number' (NaN) bool didIFail = oops.isNaN; ..5 Arrays Probably you\u2019re used to create arrays like this: int[] array = new int[]; which is the way that Java and C# o\ufb00er. In Dart it doesn\u2019t really work like that because you can only deal with collections: an \"array\" in Dart is represented by a List<T>. \u009f List<T> is a generic container where T can be any type (such as String or a class). We will cover generics and collections in detail in chapter . Basically, Dart doesn\u2019t have \"arrays\" but only generic containers. If this is not clear, you can look at this comparison. In both languages there is a generic container for the given type but only Java has \"primitive\" arrays. \u2022 Java // . Array double[] test = new test[]; // . Generic list List<double> test = new ArrayList<>(); \u2022 Dart // . Array // (no equivalent) // . Generic list List<double> test = new List<double>(); In Dart you can work with arrays but they are intended to be instances of List<T>. Lists are -indexed collections and items can be randomly accessed using the [] operator, which will throw an exception if you exceed the bounds. //use var or final final myList = [-., , ., .]; final value = myList[]; Flutter Complete Reference 45",
  ". Variables and data types A consequence of the usage of a List<T> as container is that the instance exposes many useful methods, typical of collections: \u2022 length, \u2022 add(T value), \u2022 isEmpty, \u2022 contains(T value) ... and much more. .3 Nullable and Non-nullable types Starting from Dart ., variables will be non-nullable by default (nnbd) which means they\u2019re not allowed to hold the null value. This feature has been o\ufb03cially introduced in June 2020 as tech preview in the dev channel of the Dart SDK. // Trying to access a variable before it's been assigned will cause a // compilation error. int value; print(\"$value\"); // Illegal, doesn't compile If you don\u2019t initialize a variable, it\u2019s automatically set to null but that\u2019s an error because Dart has non-nullability enabled by default. In order to successfully compile you have to initialize the variable as soon as it\u2019s declared: // . int value = ; print(\"$value\"); // . int value; value = ; print(\"$value\"); In the \ufb01rst case the variable is assigned immediately and that\u2019s what we recommend to do as much as possible. The second case is still valid because value is assigned before it\u2019s ever accessed. It wouldn\u2019t have worked if you had written this: // OK - assignment made before the usage Flutter Complete Reference 46",
  ". Variables and data types int value; value = ; print(\"$value\"); // ERROR - usage made before assignment int value; print(\"$value\"); value = ; Non-nullability is very powerful because it adds another level of type safety to the language and, by consequence, lower possibilities for the developer to encounter runtime exceptions related to null. For example, you won\u2019t have the need to do this: String name = \"Alberto\"; void main() { if (name != null) { print(name) } } The compiler guarantees that it can\u2019t be null and thus no null-checks are required. To sum up, what\u2019s important to keep in mind while writing Dart .10 code (and above) is: \u2022 By default, variables cannot be null and they must always be initialized before being used. It would be better if you immediately initialized them, but you could also do it in a second moment before they ever get utilized. \u2022 Don\u2019t do null-checks on \"standard\" non-nullable variables because it\u2019s useless. In Dart you can also declare nullable types which doesn\u2019t require to be initialized before being accessed and thus they\u2019re allowed to be null. Nullables are the counterpart of non-nullable types because the usage of null is allowed (but the additional type safety degree is lost). int? value; print(\"$value\"); // Legal, it prints 'null' If you append a question mark at the end of the type, you get a nullable type. For safety, they would require a manual null checks in order to avoid undesired exceptions but, in most of the cases, sticking with the default non-nullability is \ufb01ne. // Non-nullable version - default behavior Flutter Complete Reference 47",
  ". Variables and data types int value = ; print(\"$value\"); // prints '' // Nullable version - requires the ? at the end of the type int? value; print(\"$value\"); // prints 'null' Nullable types that support the index operator [] need to be called with the ?[] syntax. null is returned if the variable is also null. String? name = \"Alberto\"; String? first = name?[]; // first = 'A'; String? name; String? first = name?[]; // first = 'null'; We recommend to stick with the defaults, which is the usage of non-nullable types, as they\u2019re safer to use. Nullables should be avoided or used only when working with legacy code that depends on null. Last but not least, here are the only possible conversions between nullables and non nullables: \u2022 When you\u2019re sure that a nullable expression isn\u2019t null, you can add a ! at the end to convert it to the non-nullable version. int? nullable = ; int notNullable = nullable!; The ! (called \"bang operator\") converts a nullable value (int?) into a non-nullable value (int) of the same type. An exception is thrown if the nullable value is actually null. int? nullable; // An exception is thrown int notNullable = nullable!; \u2022 If you need to convert a nullable variable into a non-nullable subtype, use the typecast operator as (more on it later): num? value = ; int otherValue = value as int; You wouldn\u2019t be able to do int otherValue = value! because the bang operator works only when the type is the same. In this example, we have a num and an int so there\u2019s the need for a cast. Flutter Complete Reference 48",
  ". Variables and data types \u2022 Even if it isn\u2019t a real conversion, the operator ?? can be used to produce a non-nullable value from a nullable one. int? nullable = ; int nonNullable = nullable ?? ; If the member on the left (nullable) is non-null, return its value; otherwise, evaluate and return the member of the right (). Remember that when you\u2019re working with nullable values, the member access operator (.) is not available. Instead, you have to use the null-aware member access operator (?.): double? pi = .; final round1 = pi.round(); // No final round2 = pi?.round(); // Ok .4 Data type operators In Dart expressions are built using operators, such as + and - on primitive data types. The language also supports operator overloading for classes as we will cover in chapter . ..1 Arithmetic operators Arithmetic operators are commonly used on int and double to build expressions. As you already know, the + operator can also be used to concatenate strings. Symbol Meaning Example + Add two values  +  // - Subtract two values  -  //- * Multiply two values  *  // / Divide two values  /  //. \u223c/ Integer division of two values  ~/  //4 Flutter Complete Reference 49",
  ". Variables and data types % Remainder (modulo) of an int division  %  //1 Pre\ufb01x and post\ufb01x increment or decrement work as you\u2019re used to see in many languages. int a = ; ++a; // a = 11 a++; // a = 12 int b = ; --b; // b = ; b--; // b = ; int c = ; c +=  // c = 12 As a reminder, both post\ufb01x and pre\ufb01x increment/decrement have the same result but they work in a di\ufb00erent way. In particular: \u2022 in the pre\ufb01x version (++x) the value is \ufb01rst incremented and then \"returned\"; \u2022 in the post\ufb01x version (x++) the valie is \ufb01rst \"returned\" and then incremented ..2 Relational operators Equality and relational operators are used in boolean expression, generally inside if statements or as a stop condition of a while loop. Symbol Meaning Example == Equality test  ==  != Inquality test  !=  > Greather than  > 6 Flutter Complete Reference 50",
  ". Variables and data types < Smaller than  <  >= Greater or equal to  >=  <= Smaller or equal to  <=  . Testing the equality of two objects a and b always happens with the == operator because, unlike Java or C#, there is no equals() method. In chapter 6 we will analyze in detail how classes can be properly compared by overriding the equality operator. In general here\u2019s how the == works: . If a or b is null, return true if both are null or false if only one is null. Otherwise... . ... return the result of == according with the logic you\u2019ve de\ufb01ned in the method override. Of course, == works only with objects of the same type. ..3 Type test operators They are used to check the type of an object at runtime. Symbol Meaning Example as Cast a type to another obj as String is True if the object has a certain type obj is double is! False if the object has a certain type obj is! int . Let\u2019s say you\u2019ve de\ufb01ned a new type like class Fruit {}. You can cast an object to Fruit using the as operator like this: (grapes as Fruit).color = \"Green\"; Flutter Complete Reference 51",
  ". Variables and data types The code compiles but it\u2019s unsafe: if grapes was null or if it wasn\u2019t a Fruit, you would get an exception. It\u2019s always a good practice checking whether the cast is doable before doing it: if (grapes is Fruit) { (grapes as Fruit).color = \"Green\"; } Now you\u2019re guaranteed the cast will happen only if it\u2019s possible and no runtime exceptions can happen. Actually, the compiler is smart enough to understand that you\u2019re doing a type check with is and it can do a smart cast. if (grapes is Fruit) { grapes.color = \"Green\"; } You can avoid writing the explicit cast (grapes as Fruit) because, inside the scope of the condition, the variable grapes is automatically casted to the Fruit type. ..4 Logical operators When you have to create complex conditional expressions you can use the logical operators: Symbol Meaning !expr Toggles true to false and vice versa expr1 && expr2 Logical AND (true if both sides are true) expr1 || expr2 Logical OR (true if at least one is true) . ..5 Bitwise and shift operators You\u2019ll never use these operators unless you\u2019re doing some low level data manipulation but in Flutter this never happens. Flutter Complete Reference 52",
  ". Variables and data types Symbol Meaning a & b Bitwise AND a | b Bitwise OR a ^ b Bitwise XOR \u223ca Bitwise complement a >> b Right shift a << b Left shift Flutter Complete Reference   | Control \ufb02ow and functions .1 If statement This is probably the most famous statement of any programming language and in Dart it works exactly as you would expect. The else is optional and it can be omitted when not needed. You can avoid using brackets in case of one-liner statements. void main() { final random = ; if (random %  == ) print(\"Got an even number\"); else print(\"Got an odd number\"); } Conditions must be boolean values. In C++ for example you can write if () {...} where zero is evaluated to false but in Dart it doesn\u2019t compile; you have to write if (false) {...}. ..1 Conditional expressions In Dart there are two shorthands for conditional expressions that can replace the if-else state- ment: \u2022 valueA ?? valueB. If valueA is non-null, valueA is returned; otherwise valueB is evalu- ated and then returned. If the de\ufb01nition is too verbose, you can understand this syntax by looking at the following example. String? status; // This is null Flutter Complete Reference 54",
  ". Control \ufb02ow and functions // isAlive is a String declared somewhere before if (status != null) isAlive = status; else isAlive = \"RIP\"; Basically we want to know whether status is null or not and then decide the proper value to assign. The same logic can be expressed in another, more concise way: String? status; // This is null String isAlive = status ?? \"RIP\"; In the example isAlive doesn\u2019t need to be nullable as it\u2019s guaranteed to be initialized with a string. The ?? operator automatically checks if status is null and decides what to do: \u2013 status is not null: return status; \u2013 status is null: return the provided \"default value\" at the right of ?? It\u2019s a very helpful syntax because it guarantees that a variable is properly initialized avoiding unwanted operations with null. \u2022 condition ? A : B;. If condition is true A is returned, otherwise you get B. It\u2019s a pretty common pattern among modern languages so you might already be familiar with it. String status; if (correctAns >= ) status = \"Test passed!\"; else status = \"You didn't study enough...\" If it looks a bit too verbose, you can rewrite the logic in a more concise way: String status = (correctAns >= ) ? \"Test passed!\" : \"You didn't study enough...\"; We could call this the \"shorter if \" syntax in which you replace the if with the question mark (?) and the else with the colon (:). You can omit parenthesis. ..2 Good practices Simple boolean expressions are easy to read but complicated ones might require documentation and might also not \ufb01t well inside a single if statement like the following: Flutter Complete Reference 55",
  ". Control \ufb02ow and functions if ( (A && B || C && !A) || (!(A && C) || B) ) { ... } You might get a headache while trying to \ufb01gure out what\u2019s going on and there are also no comments at all. In such cases, you probably want to make the code more readable by splitting the conditions: final usefulTestName1 = A && B || C && !A; final usefulTestName2 = !(A && C) if (usefulTestName1 || usefulTestName2 || B) { ... } For sure it\u2019s more understandable and another programmer, or yourself in the future, will be very grateful. We also recommend to not underestimate the usefulness of variable names. \u009f The point is that you have to keep expressions short and easy to read. Break down long conditions into smaller pieces and give the variables good names to better understand what you want to check. We also recommend the usage of the short if syntax only when there\u2019s one condition or at maximum two short ones. The longer the line is the harder it is to understand. .2 switch statement When you have a series of cases to take into account, instead of using a long chain of if-elses you should go for the switch statement. It can compare many types: . compile-time constants . enums . integers . strings . classes Classes must not override == if they want to be compared with this statement. At the bottom there\u2019s a default label used as fallback if none of the previous cases matches the item being compared. Flutter Complete Reference 56",
  ". Control \ufb02ow and functions enum Status { Ready, Paused, Terminated } void main() { final status = Status.Paused; switch (status) { case Status.Ready: run(); break; case Status.Paused pause(); break; case Status.Terminated stop(); break; default unknown(); } } If the body of the case is NOT empty you must put a break otherwise your code won\u2019t compile. When you just want a fall-through to avoid code-replication, leave the body empty. Here\u2019s a few examples: \u2022 This code is not going to compile because the \ufb01rst case has a body, containing start(), but there isn\u2019t a break. switch (status) { case Status.Ready: start(); //missing \"break;\" here case Status.Paused pause(); break; } } \u2022 This code instead is \ufb01ne because the case doesn\u2019t have a body; the method pause() is going to be called when status is ready or paused. Flutter Complete Reference 57",
  ". Control \ufb02ow and functions switch (status) { case Status.Ready: case Status.Paused pause(); break; } } The above code is equivalent to... switch (status) { case Status.Ready: pause(); break; case Status.Paused pause(); break; } } ... but you should avoid code duplication which is always bad in terms of code maintenance. When you have two or more cases that must execute the same action, use the fall-through approach. .3 for and while loops The iteration with a for loop is the most traditional one and doesn\u2019t need many explanations. You can omit brackets in case of one-liner statements. The index cannot be nullable (using int? i = 0 doesn\u2019t work). for(var i = ; i <= ; ++i) print(\"Number $i\"); As you\u2019d expect, the output prints a series of \"Number (i)\" in the console. An equivalent version can be written with a classic while loop: var i = ; while (i <= ) { print(\"Number $i\"); Flutter Complete Reference 58",
  ". Control \ufb02ow and functions ++i; } The language also has the do while loop that always executes at least one iteration because the condition is evaluated only at the end of the cycle. var i = ; do { print(\"Number $i\"); ++i; } while (i <= ) The di\ufb00erence is that the while evaluates the condition at the beginning so the loop could never start. The do while instead runs at least once because the condition check is placed at the end. If you wanted to alter the \ufb02ow of the loop you could use: \u2022 break. It immediately stops the loop in which it is called. In case of nested loops, only the one whose scope contains break is stopped. For example: for (var i = ; i <= ; ++i) { // . for(var j = ; j <= ; ++j) { // . if (j == ) break; } } In this case only loop 2 is terminated when j is 5 but loop 1 executes normally until i reaches . In practical terms, we can say break stops only 1 loop. \u2022 continue. It skips to the next iteration and, like we\u2019ve seen before, in case of nested loops it does the jump only for the loop containing it, not the others. ..1 for-in loop There are some cases in which you want to completely traverse a string or a container and you don\u2019t care about the index. Look at this very easy example: final List<String> friendsList = [\"A\", \"B\", \"C\", \"D\", \"E\"]; for(var i = ; i < friendsList.length; ++i) print(friendsList[i]); Flutter Complete Reference 59",
  ". Control \ufb02ow and functions That\u2019s perfectly \ufb01ne but you\u2019re using i just to retrieve the element at the i-th position and nothing more. There are no calculations based on the index as it\u2019s just used to traverse the list. In such cases you should do the following: List<String> friendsList = [\"A\", \"B\", \"C\", \"D\", \"E\"]; for(final friend in friendsList) print(friend); This version is less verbose and clearer. You\u2019re still traversing the entire list but now, instead of the index i, you have declared final friend that represents an item at each iteration. .4 Assertions While writing the code you can use assertions to throw an exception 1 if the given condition evaluates to false. For example: // the method returns a json-encoded string final json = getJSON(); // if length > 0 is false --> runtime exception assert(json.length > , \"String cannot be empty\"); // other actions doParse(json); The \ufb01rst parameter of assert must be an expression returning a boolean value. The second parameter is an optional string you can use to tell what\u2019s gone wrong; it will appear in the IDE error message window if the condition evaluates to false. \u009f In release mode, every assert is ignored by the compiler and you\u2019re guaranteed that they won\u2019t interfere with the execution \ufb02ow. Assertions work only in debug mode. When you hit Run on Android Studio or VS Code your Flutter app is compiled in debug mode so assertions are enabled. 1Exceptions will be discussed in detail in chapter 5 Flutter Complete Reference 60",
  ". Control \ufb02ow and functions .5 Good practices Sometimes you have to implement a complicated algorithm and you don\u2019t want to make it even more complex by writing code hard to understand. Here\u2019s what we recommend. \u2022 Try to always use brackets, even if they can be omitted, so that you can avoid unexpected behaviors. Imagine you had written this code... // Version 1 if (\"A\" == \"A\") if (\"B\" == \"B\") print(\"Oh well!\"); else print(\"Oops...\"); ... but in reality you wanted to write this, with a better indentation: // Version 2 if (\"A\" == \"A\") if (\"B\" == \"B\") print(\"Oh well!\"); else print(\"Oops...\"); There\u2019s a high possibility that, at \ufb01rst glance, in version 1 you associated the else to the \ufb01rst if but it\u2019d be wrong! While it may seem obvious, in a complex architecture with thousands of lines you might misread and get tricked. \u2022 When you have to traverse an entire list and you don\u2019t care about the position in which you are during the iteration, use a for-in loop. As we\u2019ve already said, it\u2019s less verbose and so more understandable. Use assertions, in particular when you create Flutter apps, to control the behavior of your soft- ware. Don\u2019t remove them when you\u2019re ready to deploy the code to the production world because they will be automatically discarded. .6 The basics of functions Functions in Dart have the same structure you\u2019re used to see in the most popular programming languages and so you\u2019ll \ufb01nd this example self-explanatory. You can mark a parameter with final but in practice it does nothing. Flutter Complete Reference 61",
  ". Control \ufb02ow and functions bool checkEven(int value) { return value %  ==  } When the body of the function contains only one line, you can omit the braces and the return statement in favor of the \"arrow syntax\". It works with expressions and not with state- ments. // Arrow syntax bool checkEven(int value) => value %  == ; // Arrow syntax with method calls bool checkEven(int value) => someOtherFunction(value); // Does NOT work bool checkEven(int value) => if (value %  == ) ... ; The second example is a conditional statement so it doesn\u2019t work with the arrow syntax. The \ufb01rst example instead is still a condition but it\u2019s written as expression and so it works \ufb01ne. // . This function does not return a value void test() {} // . No return type so this function returns dynamic. Don't do this. test() {} When you don\u2019t need a function to return a value, simply make it void like you\u2019d do in Java for example. If you omitted the return type like in (.), the compiler would automatically append return dynamic at the end of the body. void test() => print(\"Alberto\"); Interestingly, if you have a void function with an one-liner body, you can use the arrow syntax. The function doesn\u2019t return anything because of the void but you\u2019re allowed to do it anyway. \u009f Try to always specify the return type or use void. Avoid ambiguity; you could avoid the return type for laziness (you just don\u2019t want to write void) but someone else could think you\u2019re returning dynamic on purpose. Flutter Complete Reference 62",
  ". Control \ufb02ow and functions ..1 The Function type Dart is truly an OOP language because even functions are objects and the type is called... Function! A return type is required while the parameters list is optional: // Declare a function bool checkEven(int value) => value %  == ; void main() { // Assign a function to a variable bool Function(int) checker = checkEven; // Use the variable that represents the function print(checker()); // true } It\u2019s nothing new: you\u2019re just writing a type (bool Function(int)), its name (checker) and then you\u2019re assigning it a value (checkEven). You may \ufb01nd this declaration a bit weird because it\u2019s made up of many keywords but it\u2019s a simple assignment. This is a comparison to clarify the idea: \u2022 : It\u2019s an integer and its type is int. \u2022 \"Pizza\": It\u2019s a string and its type is String. \u2022 bool checkEven(int value) => ...: It\u2019s a function and its type is bool Function(int). This particular syntax is very expressive; you have to declare the return type and the exact order of the type(s) it takes. In other words, signatures must match. If you think it\u2019s too verbose, you can use the typical automatic type deduction you\u2019re getting used to see: bool checkEven(int value) => value %  == ; void main() { final checker1 = checkEven; var checker2 = checkEven; print(checker1()); // true print(checker2()); // true } Both var and final will be evaluated to bool Function(int). There\u2019s still something to say Flutter Complete Reference 63",
  ". Control \ufb02ow and functions about this type but you\u2019ll have to wait until the next chapter where we\u2019ll talk about classes and the special call() method. \u009f When you declare a variable you can only write Function(int) name without the return type. However, automatic type deduction is generally the best choice because it reduces a lot the verbosity. It might not seem very useful and we\u2019d agree with you because there is no usage context, at the moment. When you\u2019ll arrive at part 2 of the book you\u2019ll see that the Function type is super handy in Flutter because it\u2019s used to create \"function callbacks\". .7 Anonymous functions So far you\u2019ve only seen named functions such as bool checkEven(int value) where checkEven is the name. Dart gives you the possibility to create nameless functions called anonymous func- tions. void main() { bool Function(int) isEven = (int value) => value %  == ; print(isEven()); //false } This syntax allows you to create functions \"on the \ufb02y\" that are immediately assigned to a variable. If you want an anonymous function with no parameters, just leave the parenthesis blank (). Of course you can use final and var to automatically deduce the type. \u2022 Single line. You can use the arrow syntax when you have one-liner statements. This example declares a function with no parameters that returns a double. final anon = () => . + ; \u2022 Multiple lines. Use brackets and return when you have to implement a logic that\u2019s longer than one line. final anon = (String nickname) { var myName = \"Alberto\"; myName += nickname; Flutter Complete Reference 64",
  ". Control \ufb02ow and functions return myName; }; We recommend to always write down the type of the parameter even if it\u2019s not required by the compiler. You can decide whether the type has to appear or not. Using final and var is allowed but it doesn\u2019t make much sense. String Function(String) printName = (String n) => n.toUpperCase(); String Function(String) printName = (final n) => n.toUpperCase(); String Function(String) printName = (var n) => n.toUpperCase(); String Function(String) printName = (n) => n.toUpperCase(); Any variant compiles with success but none of them is the best option, the decision is up to your discretion. Before moving on, we\u2019re going to show a simple scenario you\u2019ll encounter many times in Flutter. // . void test(void Function(int) action) { // . final list = [, , , , ]; // . for(final item in list) action(item); } void main() { // . test( // . (int value) { print(\"Number $value\"); } ); } The action parameter commonly known as callback because it executes an action given from the outside. . This function doesn\u2019t return a value because of the void. The parameter, called action, accepts a void function with a single integer value. . It\u2019s a simple list of integer values Flutter Complete Reference 65",
  ". Control \ufb02ow and functions . We iterate through the entire list and, for each item, we call the function. . test(...); is how you normally call a function . This is an anonymous function returning nothing (void) and asking for a single integer parameter. The \ufb02exibility of callbacks lies on the fact that you can reuse the same function test() with di\ufb00erent implementations. The caller doesn\u2019t care about the body of the anonymous function, it just invokes it as long as the signature matches. // The same method (test) outputs different values // because anonymous functions have different bodies test( (int value) => print(\"$value\") ); test( (int value) => print(\"${value + }\") ); You will often encounter the forEach() method on collections, which accepts a callback to be executed while elements are traversed. Again, the same function (forEach()) is reused multiple times regardless the implementation (thanks to callbacks). void main() { // Declare the list final list = [, , , , ]; // Iterate list.forEach((int x) => print(\"Number $x\")); } This is an even shorter way that doesn\u2019t use a for-in loop. You pass an anonymous function to the method and it executes the given action for every item. Pay attention because the documen- tation suggests to avoid using anonymous functions in forEach() calls. \u009f A very handy feature you\u2019ll see very often is the possibility to put an underscore when one or more parameters of a function aren\u2019t needed. For example, in Flutter the BuildContext object is often given as a callback param but it\u2019s not always essential. builder: (BuildContext context) { return Text(\"Hello\"); } Since the variable context isn\u2019t used, but it must be there anyway to match the method signature, you can use an underscore to \"hide\" it: Flutter Complete Reference 66",
  ". Control \ufb02ow and functions builder: (_) { return Text(\"Hello\"); } It\u2019s less code for you to write and the reader focuses more on what\u2019s really important. In case of multiple values that you don\u2019t use, just chain a series of underscores. builder: (_, value, __) { return Text(\"$value\"); } .8 Optional parameters In Dart function parameters can be optional in the sense that if you don\u2019t provide them, the compiler will assign null or a default value you\u2019ve speci\ufb01ed. ..1 Named parameters In the simplest case, a function can have optional parameters whose names must be explicitly written in order to be assigned. Pay attention to null-safety in case you don\u2019t plan to give the variables a default value. Declaration Calling void test({int? a, int? b}) { print(\"$a\"); print(\"$b\"); } void main() { // Prints '' and '-' test(a: , b: -); } When calling a function with optional named parameters, the order doesn\u2019t matter but the names of the variables names must be explicit. For example, you could have called test(b: -, a: ); and it would have worked anyway. When a parameter is missing, the default value is given: Flutter Complete Reference 67",
  ". Control \ufb02ow and functions Declaration Calling void test({int? a, int? b}) { print(\"$a\"); print(\"$b\"); } void main() { // Prins '' and 'null' test(a: ); } Calling test(a: ); initializes only a because b, which is omitted, is set to null by the compiler. null is the default value of nullable types. You can manually give a default value to an optional named parameter just with a simple assignment: Declaration Calling void test({int? a, int b = }) { print(\"$a\"); print(\"$b\"); } void main() { // Prints '' and '' test(a: ); } Note that b doesn\u2019t need to be nullable anymore thanks to the default value. In Dart . (an lower) nnbd was not enabled so you were able to successfully compile this code, which initializes both a and b to null: Declaration Calling // Dart .9 and lower void test({int a, int b}) { print(\"$a\"); print(\"$b\"); } // Dart .9 and lower void main() { // Prints 'null' and 'null' test(); } The required modi\ufb01er, introduced in Dart .10 with nnbd, forces an optional parameter to be set. You won\u2019t be able to compile if a required parameter is not used when calling the function. void test({int a = , required int b}) { print(\"$a\"); print(\"$b\"); Flutter Complete Reference 68",
  ". Control \ufb02ow and functions } void main() { test(a: , b: ); // Ok test(a: ); // Compilation error, 'b' is required } Even if you had written required int? b you\u2019d have to assign b anyway because it\u2019s required. Version .9 of Dart and lower didn\u2019t have this keyword: you had to use instead an annotation which just produced a warning (and not a compilation error) by default. // Dart .9 and lower void test({int a = , @required int b}) {...} In Flutter, for a better readability, some methods only use named optional params together with required to force the explicit name in the code.Y ou can mix optional named parameters with \"classic\" ones: Declaration Calling void test(int a, {int b = }) { print(\"$a\"); print(\"$b\"); } void main() { // Prints '' and '' test(, b: ); } Optional parameters must stay at the end of the list. // it compiles void test(int a, {int? b}) { } // it doesn't compile void test({int? a}, int b) { } ..2 Positional parameters You can also use optional parameters without being forced to write down the name. Optional positional parameters follow the same rules we\u2019ve just seen for named params but instead of using curly braces ({ }) they\u2019re declared with square brackets ([ ]). Flutter Complete Reference 69",
  ". Control \ufb02ow and functions Declaration Calling void test([int? a, int? b]) { print(\"$a\"); print(\"$b\"); } void main() { // Prints '' and '-' test(, -); } All the examples we\u2019ve made for named parameters also apply here. They really have the same usage but the practical di\ufb00erence is that, in this case, the name of the parameter(s) doesn\u2019t have to be written in the function call. .9 Nested functions The language allows you to declare functions inside other functions visible only within the scope in which they\u2019re declared. In other words, nested functions can be called only inside the function containing them; if you try from the outside, you\u2019ll get a compilation error. \u009f From a practical side, the scope is the \"area\" surrounded by two brackets { } This example shows how you can nest two functions, where testInner() is called \"outer func- tion\" and randomValue() is called \"inner function\". void testInner(int value) { // Nested function int randomValue() => Random().nextInt(); // Using the nested funcion final number = value + randomValue(); print(\"$number\"); } As we\u2019ve just seen, functions are types in Dart so a \"nested function\" is nothing more than a Function type assignment. Given this declaration, we\u2019re able to successfully compile the following: void main() { Flutter Complete Reference 70",
  ". Control \ufb02ow and functions // testInner internally calls randomValue testInner(); } An error is going to occur if we try to directly call randomValue from a place that\u2019s not inside the scope of its outer function. void main() { // Compilation error var value = randomValue(); } .10 Good practices Following the o\ufb03cial Dart guidelines 2 we strongly encourage you to follow these suggestions in order to guarantee consistency with what the community recognizes as a good practice. \u2022 Older versions of Dart allow the speci\ufb01cation of a default value using a colon (:); don\u2019t do it, prefer using =. In both cases, the code compiles successfully. // Good void test([int a = ]) {} // Bad void test([int a : ]) {} The colon-initialization might be removed in the future. \u2022 When no default values are given, the compiler already assigns null to the variable so you don\u2019t have to explicitly write it. // Good void test({int? a}) {} // Bad void test({int? a = null}) {} In general, you should never initialize nullables with null because the compiler already does that by default. 2https://dart.dev/guides/language/e\ufb00ective-dart/usage#functions Flutter Complete Reference 71",
  ". Control \ufb02ow and functions Dart gives the possibility to write only the name of a function, with no parenthesis, and automat- ically pass proper parameters to it. It\u2019s a sort of \"method reference\". We are going to convince you with this example: void showNumber(int value) { print(\"$value\"); } void main() { // List of values final numbers = [, , , , ]; // Good numbers.forEach(showNumber); // Bad numbers.forEach((int val) { showNumber(val); }); } The bad example compiles but you can avoid that syntax in favor of a shorter one. \u2022 The forEach() method asks for a function with a single integer parameter and no return type (void). \u2022 The showNumber() function accepts an integer as parameter and returns nothing (void). The signatures match! If you pass the function name directly inside the method, the compiler automatically initializes the parameters. This tear-o\ufb00is very useful and you might already have seen it somewhere else under the name of \"method reference\" (Java). .11 Using typedefs The typedef keyword simply gives another name to a function type so that it can be easily reused. Imagine you had to write a callback function for many methods: void printIntegers(void Function(String msg) logger) { logger(\"Done.\"); } void printDoubles(void Function(String msg) logger) { Flutter Complete Reference 72",
  ". Control \ufb02ow and functions logger(\"Done.\"); } Alternatively, rather than repeating the declaration every time, which leads to code duplication, you can give it an alias using the typedef keyword. typedef LoggerFunction = void Function(String msg); void printIntegers(LoggerFunction logger) { logger(\"Done int.\"); } void printDoubles(LoggerFunction logger) { logger(\"Done double.\"); } You are going to encounter this technique very often, especially in Flutter, in callbacks for classes or methods. For instance, VoidCallback 3 is just a function alias for a void function taking no parameters. typedef VoidCallback = void Function(); In a future version of Dart, probably later than ., typedef will also be used to de\ufb01ne new type names. At the moment it\u2019s not possible, but in the future there will be the possibility to compile the following code: typedef listMap = List<Map<int,double>>; The reason is that generic types can become very verbose and so an alias could improve the readability. Currently, typedef only works with functions. 3https://api.\ufb02utter.dev/\ufb02utter/dart-ui/VoidCallback.html Flutter Complete Reference   | Classes Up to now you\u2019ve seen us saying many times the claim that Dart is an OOP language and now we\u2019re \ufb01nally going to prove it. There are a lot of similarities with the most popular programming language so you probably are already familiar with the concepts. class Person { // Instance variables String name; String surname; // Constructor Person(String name, String surname) { this.name = name; this.surname = surname; } } This syntax is almost identical to Java, C# or C++ and that\u2019s very good: if you\u2019re going to learn the language, there\u2019s nothing you\u2019ve never seen before. Some keywords might be di\ufb00erent but the essence is always the same. \u009f Every object is an instance of a class. Dart classes, even if it\u2019s not explicitly written in the declaration, descend from Object and in the next chapter you will see the bene\ufb01ts. In Delphi and C# as well, any class implicitly derives from Object. In any class you have methods (it\u2019s the OOP way to call functions) which can be public or private. The keyword this refers to the current instance of the class. Dart has NO method overload so you cannot have more than a function with the same name. For this reason, you\u2019ll Flutter Complete Reference 74",
  ". Classes see how named constructors come to the help. class Example { // Doesn't compile; you have to use different names void test(int a) {} void test(double x, double y) {} } You might be able to write this in other programming languages because methods have the same name but di\ufb00erent signature. In Dart it\u2019s not possible, every function name (in the same class) must be unique. Before going into the details of classes, look at the cascade notation. class Test { String val1 = \"One\"; String val2 = \"Two\"; int randomNumber() { print(\"Random!\"); return Random().nextInt(); } } Given this class, you have two ways to give a value to the variables: // first way, the \"classic\" one test.val1 = \"one\"; test.val2 = \"two\"; // second way, using the cascade operator test..val1 = \"one\" ..val2 = \"two\"; It\u2019s just a shorthand version you can use when there are multiple values of the same objects that has to be initialized. You can do the same even with methods but the returned value, if any, will be ignored. For this reason, the cascade notation is useful when calling a series of void methods on the same object. Test()..randomNumber() ..randomNumber() ..randomNumber(); Here the integer returned by randomNumber() is discarded but the body is executed. If you Flutter Complete Reference 75",
  ". Classes run the snipped, you\u2019ll get Random! printed three times in the console. In case of nullable values... MyClass? test = MyClass(); test?..one() ..two() ..three(); ... the cascade notation has to start with ?.. in order to be null-checked before dereferencing. In Dart there cannot be nested classes. .1 Libraries and visibility In the Dart world, when you talk about a \"library\" you\u2019re referring to the code inside a \ufb01le with the .dart extension. If you want to use that particular library, you have to reference its content with the import keyword. \u009f If you aren\u2019t sure you\u2019ve understood the above statement, here\u2019s an example. Let\u2019s say there\u2019s the need to handle fractions in the form numerator / denominator: you are going to create a \ufb01le named fraction.dart. // === Contents of fraction.dart === class MyFraction { final int numerator; final int denominator; //... other code } Congratulations, you have just created the fraction library! It can be used by any other .dart \ufb01le that references it via import. import 'package:fraction.dart'; void main() { // You could have written 'new Fraction(, )' but // starting from Dart . 'new' is optional final frac = Fraction(, ); Flutter Complete Reference 76",
  ". Classes } You can also use the library keyword to \"name\" your library as you prefer. This keyword really just names the library as you like, nothing more, and it\u2019s not required. library super_duper_fraction; class MyFraction { final int numerator; final int denominator; const MyFraction(this.numerator, this.denominator); } . The import directive accepts a string which must contain a particular scheme. For built-in libraries you have to use the dart: pre\ufb01x followed by the library name: import 'dart:math'; import 'dart:io'; import 'dart:html'; Everything else that doesn\u2019t belong to the Dart SDK, such as a custom library created by you or another developer in the community, must be pre\ufb01xed by package. import 'package:fraction.dart'; import 'package:path/to/file/library.dart'; It could happen that two di\ufb00erent libraries have implemented a class with the same name; the only possible technique to avoid ambiguity is called \"library aliases\". It\u2019s a way to reference the contents of a library under a di\ufb00erent name. // Contains a class called 'MyClass' import 'package:libraryOne.dart'; // Also contains a class called 'MyClass' import 'package:libraryTwo.dart' as second; void main() { // Uses MyClass from libraryOne var one = MyClass(); //Uses MyClass from libraryTwo. Flutter Complete Reference 77",
  ". Classes var two = second.MyClass(); } You can selectively import or exclude types using the show and hide keywords: \u2022 import 'package:libraryOne.dart' show MyClass; Imports only MyClass and discards all the rest. \u2022 import 'package:libraryTwo.dart' hide MyClass; Imports everything except MyClass. At the moment, you have the basics of libraries (simple creation and usage). In chapter 23 you\u2019ll learn how to create a package (a collection of libraries and tools) and how to publish it at https://pub.dev. ..1 Encapsulation You may be used to hide implementation details in your classes using public, protected and private keywords but there\u2019s no equivalent in Dart. Every member is public by default unless you append an underscore (_) which makes it private to its library. If you had this \ufb01le... // === File: test.dart === class Test { String nickname = \"\"; String _realName = \"\"; } ... you could later import the library anywhere: // === File: main.dart === import 'package:test.dart'; void main() { final obj = Test(); // OK var name = obj.nickname; // ERROR, doesn't compile var real = obj._realName; } The variable nickname is public and everyone can see it but _realName can be seen ONLY inside test.dart. In other words, if you put the underscore in front of the name of a variable, it Flutter Complete Reference 78",
  ". Classes is visible only within that \ufb01le. // === File: main.dart === class Test { String nickname = \"\"; String _realName = \"\"; } void main() { final obj = Test(); // Ok var name = obj.name; // Ok, it works because 'Test' is in the same file var real = obj._realName; } We\u2019ve moved everything in the same \ufb01le: now both Test and main() belong to the same library and so _realName is not private anymore. \u009f The same rules on package private members also apply to classes and functions. For example, void something() is visible from the outside while void _something() is private to its library. // Inside a file called users.dart class Users { } class _UsersHelper { } In this case, Users is visible while _UsersHelper is package-private (exactly as it happens with variables and methods). In Dart everything is \"public\" by default; if you append an underscore at the front, it becomes \"private\". There is no way to de\ufb01ne \"protected\" members or variables (where protected is a typical OOP keyword that makes a member or variable accessible only by subclasses of a certain type.). Flutter Complete Reference 79",
  ". Classes ..2 Good practices We strongly recommend to NOT put everything in a single \ufb01le (or a few ones) for the following reasons: \u2022 Dealing with thousands of lines of code containing literally everything is not good at all. Maintenance is going to be hard and you\u2019re on the good way to become a professional \"spaghetti code\" writer! \u2022 If you placed everything in the same \ufb01le, you\u2019d expose private details of the class. We\u2019ve seen that private members exist only if classes are put in separated libraries (\ufb01les). Try to have one \ufb01le per class or at maximum a few classes that are closely related (they should have the same purpose). When you write a Dart program, in general you have this folder structure: root | -- lib | | -- main.dart | | -- routes | | -- other_folders | -- tests | -- tools You\u2019ll learn throughout the chapters how to create a robust folder hierarchy. The minimal Dart/Flutter project is made up of a lib/ folder and a main.dart entry point \ufb01le. .2 Constructors The constructor is a special function with the same name of the class and doesn\u2019t carry a return type. To invoke it, the syntax is the most common one you can imagine: final myObject = new MyClass(); Starting from Dart , the keyword new can be omitted. It\u2019s something you\u2019re always going to do, especially while writing Flutter apps. final myObject = MyClass(); As example, in this chapter we are creating a library to work with fractions and rational num- bers. To get started, there\u2019s the need to create a \ufb01le called fraction.dart with the following contents: Flutter Complete Reference 80",
  ". Classes class Fraction { int? _numerator; int? _denominator; Fraction(int numerator, int denominator) { _numerator = numerator; _denominator = denominator; } } In this case variables must be nullables because they are initialized, by default, to null. The body of the constructor is called after the variables initialization. If you want to get rid of nullables there are two options: . Declare variables as late final to tell the compiler to not emit an error. They are going to be initialized later but anyway before being accessed for the \ufb01rst time ever. class Fraction { late final int _numerator; late final int _denominator; Fraction(int numerator, int denominator) { _numerator = numerator; _denominator = denominator; } } Because of the final modi\ufb01er, variables cannot be changed anymore after their initializa- tion. You could have only used late but variables would be mutable then: class Fraction { late int _numerator; late int _denominator; Fraction(int numerator, int denominator) { _numerator = numerator; _denominator = denominator; } } In both cases, members are NOT initialized immediately because the body of the construc- Flutter Complete Reference 81",
  ". Classes tor is executed after the variable initialization phase. . The Dart team recommends going for the \"initializing formal\" 1 approach as it\u2019s more readable and it initializes the variables immediately. class Fraction { int _numerator; int _denominator; Fraction(this._numerator, this._denominator); } It\u2019s just syntactic sugar to immediately assign values to members. In this case, variables initialization is executed \ufb01rst so no need to use nullable types or late. This kind of initialization happens before the execution of the constructor\u2019s body. Keep in mind that constructor bodies are executed after the variable initialization phase. The second approach is very common and you should get used to it, even if your class only declares final \ufb01elds. class Fraction { final int _numerator; final int _denominator; Fraction(this._numerator, this._denominator); } If your class doesn\u2019t de\ufb01ne a constructor, the compiler automatically adds a default constructor with no parameters and an empty body. With the \"initializing formal\" you can still declare a body to perform additional setup for the class. class Fraction { final int _numerator; final int _denominator; late final double _rational; Fraction(this._numerator, this._denominator) { _rational = _numerator / _denominator; doSomethingElse(); 1https://dart.dev/guides/language/e\ufb00ective-dart/usage#do-use-initializing-formals-when-possible Flutter Complete Reference 82",
  ". Classes } }; You could only write Fraction(this._numerator) to initialize exclusively _numerator but then _denominator would be set to null by the compiler. Keep in mind that you cannot have named optional parameters starting with an underscore. // Doesn't compile Fraction({this._numerator, this._denominator}); However, you can have positional parameters starting with an underscore: // Ok but pay attention to non-nullability Fraction([this._numerator, this._denominator]); ..1 Initializer list When using the initializing formal approach, the names of the variables must match the ones declared in the constructor. This could lead to an undesired exposure of some internals of the class: class Test { int _secret; double _superSecret; Test(this._secret, this._superSecret); } What if you wanted to keep int _secret (private) but with a di\ufb00erent name in the constructor? Use an initializer list! It\u2019s executed before the body and thus variables are immediately initialized. No need for nullable types or late. class Test { int _secret; double _superSecret; Test(int age, double wallet) : _secret = age, _superSecret = wallet; } In this way the constructor is asking you for age and wallet but the user has no idea that Flutter Complete Reference 83",
  ". Classes internally they\u2019re treated as _secret and _superSecret. It\u2019s basically a way to \"rename\" internal private properties you don\u2019t want to expose. ..2 Named constructors Named constructors are generally used to implement a default behavior the user expects from your class. They are the only alternative to have multiple constructors since Dart has no method overload. class Fraction { int _numerator; int _denominator; Fraction(this._numerator, this._denominator); // denominator cannot be 0 because /0 is not defined! Fraction.zero() : _numerator = , _denominator = ; } At this point you can use the named constructor in your code like if it were a static method call. void main() { // \"Traditional\" initialization final fraction1 = Fraction(, ); // Same thing but with a named constructor final fraction2 = Fraction.zero(); } In general constructors aren\u2019t inherited by a subclass so, if they are needed across the hierarchy, every subclass must implement its own named constructor. If we had written a named constructor with a body... class Fraction { int? _numerator; int? _denominator; Flutter Complete Reference 84",
  ". Classes Fraction.zero() { _numerator = ; _denominator =  } } ... we would have had to use nullable instance variables as constructors\u2019 bodies are always executed after variables\u2019 initialization. ..3 Redirecting constructors Sometimes you might have a constructor that does almost the same thing already implemented by another one. It may be the case to use redirecting constructors in order to avoid code dupli- cation: Fraction(this._numerator, this._denominator); // Represents '/' Fraction.oneHalf() : this(, ); // Represents integers, like '' which is '/' Fraction.whole(int val) : this(val, ); Where Fraction.oneHalf() is just another way to call Fraction(, ) but you\u2019ve avoided code repetition. This feature is very powerful when mixed with named constructors. ..4 Factory constructors The factory keyword returns an instance of the given class that\u2019s not necessarily a new one. It can be useful when: \u2022 You want to return an instance of a subclass instead of the class itself, \u2022 You want to implement a singleton (the Singleton pattern), \u2022 You want to return an instance from a cache. Factory constructors are like static methods and so they don\u2019t have access to this. There cannot be together a factory and a \"normal\" constructor with the same name. class Test { static final _objects = List<BigObject>(); factory Test(BigObject obj) { Flutter Complete Reference 85",
  ". Classes if (!objects.contains(obj)) objects.add(obj); return Test._default(); } // This is a private named constructor and thus it can't be called // from the outside Test._default() { //do something... } } In the example, since BigObject requires a lot of memory and the list is very very long, we\u2019ve declared objects as static. This technique is often used to save memory and reuse the same object across multiple objects of the same type. \u009f If the list weren\u2019t static (just a normal instance variable), it would be created every time that a Test object is instantiated. It\u2019d be a waste of memory and a per- formance problem; in this way we\u2019re guaranteed that there\u2019s an unique list created only once. In this case the factory constructor is essential because it takes care of updating the _objects cache. Factories are called \"normally\" like if they were a regular constructor: // Calls the factory constructor final a = Test(); ..5 Instance variables initialization As we\u2019ve already seen, \"normal\" non-nullable variables have to be initialized either via initializing formal or initializer list. In any other case, they\u2019re set to null because constructor bodies run after the instance initialization phase. // Initializing formal class Example { int _a; // Ok - 'a' initialized by the constructor Example(this._a); Flutter Complete Reference 86",
  ". Classes } class Example { int _a; // Error - 'a' not initialized Example(int a) { _a = a; } } If variables aren\u2019t initialized immediately and you want them to be non-nullanle, you can use the late modi\ufb01er. It works like a \"lazy initialization\" because with this keyword you allow a non- nullable to be initialized later (but anyway before it gets accessed for the \ufb01rst time ever). // For Dart .10 and earlier versions, 'late' does not exist so just // remove it. Not initialized variables will be set to 'null' by default. class Example { late int a; void printExample() { a = ; print(\"$a\"); a = ; print(\"$a\"); } } If you tried to use the variable before it gets assigned for the \ufb01rst time, you would get a compilation error. Always be sure to have the initialization done before using it. class Example { late int a; void printExample() { // Compilation error print(\"$a\"); a = ; } } Using a like above causes an error because it\u2019s accessed before being initialized. There\u2019s also the Flutter Complete Reference 87",
  ". Classes possibility to declare a late final variable which behaves in the same way but with the only exception that it can be assigned only once. class Example { late final int a; void printExample() { a = ; print(\"$a\"); //a = ; <-- This would be an error } } Once a is set with a = ; you can\u2019t re-assign it anymore because of the final modi\ufb01er. Instead, if it were a simple late int a;, you could have re-assigned it multiple times. late final double a = takesLongTime(); Thanks to the usage of the late final combination you can lazily initialize a variable that is going to hold a value computed from a function. You can assign it immediately or, as we\u2019ve just seen, in a second moment. The function takesLongTime() will only be called once a is accessed. ..6 Good practices Following what the o\ufb03cial documentation 2 suggests, here\u2019s some tips you should consider while writing constructors for your classes: . Prefer using the \"initializing formal\" approach rather than initializing variables directly in the body of the constructor. Doing so, you\u2019ll avoid the usage of nullable types or late. . When you use the initializing formal, the types of the variables are deduced automatically to reduce the verbosity. Omit the types because they\u2019re useless. // Ok but useless Constructor(String this.a, double this.b) {} // OK Constructor(this.a, this.b); . When you have an empty constructor with no body, use the semicolon instead of the empty brackets. 2https://dart.dev/guides/language/e\ufb00ective-dart/usage#constructors Flutter Complete Reference 88",
  ". Classes // Bad Constructor(this.a, this.b) {} // Good Constructor(this.a, this.b); . Do not use the new keyword when creating new instances of objects. In modern Dart and Flutter code, new never appears. . We recommend using redirecting constructors to avoid code duplication. It makes mainte- nance easier. . Try to not use the late keyword because it could lead to hard maintenance (you\u2019d have to manually keep an eye on the initialization of variables). Whenever possible, initialize variables as soon as they are declared. . In the second part of the book we\u2019ll show a case where late or late final are required. They\u2019ll be used to initialize values inside the state of a Widget. class Example extends State { late int value; @override void initState() { super.initState(); value = ; } } In short, subclasses of State cannot de\ufb01ne a constructor and you have to perform the initialization of the variables in the initState() method. In order do to this, late is essential. The syntax for private constructors in Dart might seem a bit weird at \ufb01rst. Generally, a private constructor is used in conjunction with a factory that returns a subtype or an instance of the actual object with certain criteria. class Example { final a; // Private constructor Example._(this.a); factory Example(int value) { Flutter Complete Reference 89",
  ". Classes final c = value * ; return Example._(c); } } A private constructor is declared using the ._() notation. In the example, the class can still be instantiated but only because we\u2019ve de\ufb01ned a factory. In this case... final ex = Example(); ... we\u2019re not calling the \"normal\" constructor (because it\u2019s package private) but instead the factory one. .3 const keyword The const keyword can be used when you have to deal with compile-time constant values such as strings or numbers. It can automatically deduce the type. // type of 'number' is int const number =  // explicitly write the type const String name = 'Alberto'; const sum = . + .; It\u2019s true that final and const are very similar at \ufb01rst glance and they also share the same syntax style. A very intuitive way to determine which one you can choose is ask yourself: is this value already well de\ufb01ned? is it known at compile time? Let\u2019s \ufb01nd out why. \u2022 final. Use it when the value is not known at compile time because it will be evalu- ated/obtained at runtime. Common usages are I/O from the disk or HTTP requests. For example, this is how you read a text \ufb01le from the disk (more on this in A.): final contents = File('myFile.txt').readAsString(); // const contents = File('myFile.txt').readAsString(); // ^ does not compile! The compiler doesn\u2019t know in advance which is the content of myFile.txt because it will be read only when the program will be running (so after the compilation). For this reason, you can only use \ufb01nal. Flutter Complete Reference 90",
  ". Classes \u2022 const. Use it when the value is computed at compile time, for example with integers, doubles, Strings or classes with a constant constructor (more on it in the next section). const a = ; // final a =  -> it works as well If it works with const, it works also with final because anything that is const is also final. Instance variables can only be declared as final while const can be applied in combination with the static keyword. class Example { // OK final double a = .; // NO, instance variables can only be 'final' const double b = .; // OK static const double PI = .; // OK but without type annotation static const PI = .; } The real power of const comes when combined with constructors and, in Flutter, it can lead to an important performance boost. \u009f Variables and methods marked with the static modi\ufb01er are available on the class itself and not on instances. In practice it means that you can use them without having to create an object. class Example { static const name = \"Flutter\"; static String test() => \"Hello, I am $name!\"; } void main() { final name = Example.name; final text = Example.test(); } Flutter Complete Reference 91",
  ". Classes Both variables are strings and they\u2019ve been retrieved without creating an instance of Example; static members belong to the \"class scope\" and you cannot use this. class Example { int a = ; static void test() { // Doesn't compile final version = this.a; print(\"$version\"); }; } Since you don\u2019t have to create objects to call static methods, this cannot work be- cause it refers to the current instance that gets never created. ..1 const constructors In Dart you can append the const keyword in front of a constructor only if you\u2019re going to initialize a series of final (immutable) variables. // Compiles class Compiles { final int a; final int b; const Compiles(this.a, this.b); } // Does not compile because a is mutable (not final) class DoesNot { int a; final int b; const DoesNot(this.a, this.b); } If your class only has final variables it\u2019s said to be an \"immutable class\" and you should really instantiate it with a const constructor. The compiler can perform some optimizations. final example1 = const Compiles(); // () constant object final example2 = Compiles(); // () not a constant object! Flutter Complete Reference 92",
  ". Classes In example () we\u2019re calling the constant constructor but in () we\u2019re not. Even if your class only has constant constructors, objects can be instantiated as constants only with the const keyword. When put in front of a collection, such as a list, everything inside that container will automatically be const (if it is allowed to be constant). class Test { // constant constructor const Test(); } const List<Test> listConst = [Test(), Test()]; // () final List<Test> listConst2 = [Test(), Test()]; // () In () everything inside the list is automatically \"converted\" into a const value while in () it doesn\u2019t happen, meaning that the contents of listConst2 aren\u2019t constant. The final keyword in front of a list just makes it impossible to change the reference assigned to listConst2 but does NOT call the constant constructor (while example () does). // Bad const List<Test> list1 = [const Test(), const Test()]; // () // Good const List<Test> list2 = [Test(), Test()]; // () You should avoid version () because calling const Test() is not necessary. Any constant collection initializes its children calling their const constructor (if any, otherwise a compilation error occurs). ..2 Good practices and annotations If you know that variables in your class will never change, you really should make them final and use a const constructor. As we\u2019ve already said, constant constructors play a very important role in Flutter because they allow \"caching\" on instances. \u009f Don\u2019t get \"obsessed\" by immutable classes and const constructors because you simply can\u2019t use them in every situation. If your instance variables cannot be final that\u2019s perfectly \ufb01ne; the environment and the compiler are very powerful and your \ufb01nal product won\u2019t su\ufb00er of speed degradations due to the lack of immutability. Any class with a constant constructor can be used as annotation: they\u2019re are generally put Flutter Complete Reference 93",
  ". Classes before the name of a class or method. An annotation is preceded by the \"at\" sign (@). In the next section, we will see that overriding methods is usually done in the following way: class MySubclass extends SuperClass { @override void defineMethod() {} } The @override annotation does nothing in practice: it just tells the developer that defineMethod has been overridden. If you looked at how the override annotation is declared in the Dart SDK, you\u2019ll \ufb01nd simply the following: // This class has a constant constructor and so it can be used as annotation class _Override { const _Override(); } // the actual \"@override\" annotation const Object override = _Override(); The class has been made private (_Override) because its instantiation is useless as it does nothing. However, thanks to the const Object override variable being public, there\u2019s an \"alias\" of the _Override class which can be used as annotation. They\u2019re generally used for: \u2022 reminding the developer about something, such as in the case of @override; \u2022 before Dart ., the @required annotation was used by the IDE to bring the developer\u2019s attention to the fact that a named optional parameter is required; \u2022 some packages, such as json_serializable we\u2019re going to cover in chapter , rely on anno- tations to add additional information about a class, a method or a member. Annotations can be used to pass data to code generation tools. Annotations can also have parameters but in this case you aren\u2019t doing the above \"trick\" of declaring a global variable exposing a private class. Just create a normal class, with a const constructor and use it as follows: // Use this as annotation but it takes a param class Something { final int value; const Something(this.value); } Flutter Complete Reference 94",
  ". Classes @Something() class Test {} .4 Getters and setters When a public variable is declared, anyone can freely manipulate it but it may not a good idea because the class partially loses control of its members. If we had written this... class Fraction { int numerator; int denominator; Fraction(this.numerator, this.denominator); } ... at a certain point someone could have changed the numerator and the denominator without any control introducing unexpected behaviors due to a wrong internal state. void main() { final frac = Fraction(, ); frac.numerator = ; frac.denominator = ; } Having set both numerator and denominator to 0 there will be problems at runtime due to an invalid division operation. We can \ufb01x this problem using a getter, which makes the variables read-only. class Fraction { int _numerator; int _denominator; Fraction(this._numerator, this._denominator); // Getters are read-only int get numerator => _numerator; int get denominator { return _denominator; } } Flutter Complete Reference 95",
  ". Classes The getter numerator returns an int, _numerator; the getter denominator does the same thing with an equivalent syntax. Like it happens with methods, when there is an one-liner expression or value to return, the => (arrow) syntax can be used. void main() { final frac = Fraction(, ); // Compilation error, numerator is read-only frac.numerator = ; // No problems here, we can read its value final num = frac.numerator; } The code is now safe because we can expose both numerator and denominator but it\u2019s guaranteed that they cannot be freely modi\ufb01ed. Internally, _numerator and _denominator are \"safe\" because they aren\u2019t visible from the outside. Just as example, we\u2019re going to see how to write a setter for the denominator. So far it\u2019s read-only but with a setter it becomes editable: class Fraction { int _numerator; int _denominator; Fraction(this._numerator, this._denominator); // getters int get numerator => _numerator; int get denominator => _denominator; // setter set denominator(int value) { if (value == ) { // Or better, throw an exception... _denominator = ; } else { _denominator = value; } } } There can be the same name for a setter and a getter so that a property can be read/written using the same identi\ufb01er. Setters should be used to make \"safe edits\" on variables; they often contain a Flutter Complete Reference 96",
  ". Classes validation logic which makes sure that the internal state of the class doesn\u2019t get corrupted. void main() { final frac = Fraction(, ); var den1 = frac.denominator; // den1 = 7 frac.denominator = ; // the setter changes it to 1 den1 = frac.denominator // den1 =  } To sum it up, getters and setters are used to control the reading/writing on variables. They are methods under the hood but with a \"special\" syntax that uses the get and set keywords. ..1 Good practices Our recommendation is to keep the body of getters and setters as short as possible in bene\ufb01t of code readability. You shouldn\u2019t put any loop that might slow down the assignment/retrieval of a value. The o\ufb03cial documentation 3 also has something to say: \u2022 When a variable has to be both public and read-only, just mark it as final without asso- ciating a getter to it. // Bad class Example { final _address = \"https://fluttercompletereference.com\"; String get address => _address; } // Good class Example { final address = \"https://fluttercompletereference.com\"; } If it\u2019s final, it\u2019s already a read-only variable because nothing can change its content. In this case a getter is simply useless. \u2022 Avoid wrapping public variables with getters and setters if there\u2019s no validation logic. class Example { var _address = \"https://fluttercompletereference.com\"; 3https://dart.dev/guides/language/language-tour#getters-and-setters Flutter Complete Reference 97",
  ". Classes String get address => _address; set address(String value) => _address = value; } It compiles but there\u2019s no point in doing that: both getter and setter don\u2019t perform any particular logic as they just serve the variable as it is. Prefer doing this: class Example { var address = \"https://fluttercompletereference.com\"; } In general, use getters when you want to expose a variable but in \"read-only mode\" and setters when you want to \ufb01lter/check the value that is going to be assigned. .5 Operators overload When you deal with primitive types you use operators very often:  + 8 is a sum between two int types happening with the + operator. We are going to do the same with Fraction class. class Fraction { Fraction operator+(Fraction other) => Fraction( _numerator * other._denominator + _denominator * other._numerator, _denominator * other._denominator ); Fraction operator-(Fraction other) => ... Fraction operator*(Fraction other) => ... Fraction operator/(Fraction other) => ... } Operator overloading gives the possibility to customize the usage of operators in your classes. We have overloaded the + operator so that we can easily sum two fractions instead of having to create an add(Fraction value) method, like it happens with Java. void main() { Flutter Complete Reference 98",
  ". Classes // /5 final frac1 = Fraction(, ); // /3 final frac2 = Fraction(, ); // / + / = /15 final sum = frac1 + frac2 } They work like normal methods with the only exception that the name must be in the form operator{sign} where sign is a supported Dart operator: \u2022 Arithmetic operators like +, -, *, or /. \u2022 Relational operators such as >=, <=, > or <. \u2022 Equality operators like != and == And many more. There are no restrictions on the types you can handle with the operators, meaning that we could also sum fractions with integers: operator+(int other). You cannot overload the same operator more than once in the same class. ..1 callable classes There is a special call() method which is very closely related to an operator overload because it allows classes to be called like if they were functions with the () operator. \u009f You can give call() as many parameters as you want as there are no restrictions on their types. The function can return something or it can simply be void. Let\u2019s give a look at this example. class Example { double call(double a, double b) => a + b; } void main() { final ex = Example(); // . final value = ex(., -.); // . Flutter Complete Reference 99",
  ". Classes print(\"$value\"); } . Classic creation of an instance of the class . The object ex can act like if it were a function. The call() method allows an object to be treated like a function. Any class that implements call() is said to be a callable class. In Dart, everything is an object and you\u2019ve seen in ..1 that even functions are objects. You can now understand why with the following example: void test(String something) { print(something); } This is a typical void function asking for a single parameter. Actually, the above code can be con- verted into a callable class that overrides call() returning nothing and asking for a string. // Create this inside 'my_test.dart' for example class _Test { const _Test(); void call(String something) { print(something); } } const test = _Test(); // Somewhere else, for example in main.dart import 'package:myapp/my_test.dart'; void main() { test(\"Hello\"); } The function is nothing more than a package private class that overrides call() with a certain signature. Thanks to const test = _Test(); in the last line we\u2019re \"hiding\" the class and exposing a callable object to be used as function. Flutter Complete Reference 100",
  ". Classes .6 Cloning objects Even if it\u2019s not mentioned in the o\ufb03cial Dart documentation, there is a standard \"pattern\" to follow when it comes to cloning objects. Unlike Java, there is no clone() method to override but still you might need to create deep copies of objects: class Person { final String name; final int age; const Person({ required this.name, required this.age, }); } void main() { const me = const Person( name: \"Alberto\", age:  ); const anotherMe = me; } As you already know, the variable anotherMe just holds a reference to me and thus they point to the same object. Changes applied to me will also re\ufb02ect on anotherMe. If you want to make deep copies in Dart (cloning objects and making them independent), this is the way: class Person { final String name; final int age; const Person({ required this.name, required this.age, }); Person copyWith({ String? name, int? age, }) => Person( Flutter Complete Reference 101",
  ". Classes name: name ?? this.name, age: age ?? this.age ); @override String toString() => \"$name, $age\"; } This method is called copyWith() by convention and it takes the same number (and name) of parameters required by the constructor. It creates a new, independent copy of the object (a clone) with the possibility to change some parameters: const me = const Person( name: \"Alberto\", age:  ); // Create a deep copy of 'me'. final anotherMe = me.copyWith(); // Create a deep copy of 'me' with a different age. final futureMe = const.copyWith(age: ); print(\"$me\"); // Alberto, 25 print(\"$anotherMe\"); // Alberto, 25 print(\"$futureMe\"); // Alberto, 35 Both anotherMe and futureMe have no side e\ufb00ects on me because the reference is not the same. In fact, copyWith() returns a fresh new instance by copying internal data. Let\u2019s take a look at this line: name: name ?? this.name, Thanks to the ?? operator, if name is null then initialize the clone with value of this.name taken from the instance. In other words, if you don\u2019t pass a custom name to copyWith(), by default a copy of this.name is made. Pay attention to generic containers and objects in general: class Skills {...} class Person { final List<Skills> skills; Flutter Complete Reference 102",
  ". Classes const Person({ required this.skills }); Person copyWith({ List<Skills>? skills, }) => Person( skills: skills ?? this.skills ); } This code doesn\u2019t do what you\u2019d expect because List<T>, like any other generic container, is an object and not a primitive type. With the above code you\u2019re just copying references and not making copies. The correct solution is the following: Person( skills: skills ?? this.skills.map((p) => p.copyWith()).toList(); ); In this way you\u2019re making a copy of the entire list rather than passing a reference. The above code is just an one-liner way to iterate on each element of the source, making deep copies using copyWith and returning a new list. However, when the list is made up of primitive types, you could use a shortcut: class Person { final List<int> values; const Person({ required this.values }); Person copyWith({ List<int>? values, }) => Person( values: values ?? []..addAll(this.values) ); } Primitive types are automatically copied so instead of using map() (which would be perfectly \ufb01ne as well) we can use addAll() for a shorter syntax. There is no di\ufb00erence however because it still iterates on every element of the source list. The same example also applies to Map<K, V> and Flutter Complete Reference 103",
  ". Classes Set<K>. To sum it up, what you have to keep in mind is: \u2022 Deep copies in Dart are made using the copyWith() method. You can give it any other name but you\u2019d better follow the conventions. \u2022 When making copies, be sure that classes (like generic containers) are deep copied using the convenient map((x) => x.copyWith()) strategy. \u2022 If you have a list of primitive types (like doubles or int) you can use the []..addAll() shortcut. Do this only with primitive types. Flutter Complete Reference   | Inheritance and Exceptions .1 Inheritance In any OOP language you can create hierarchies of classes and Dart is no exception. Here\u2019s the most basic example we can imagine. class A {} class B extends A {} As you might expect, A is called superclass while B is the subclass (or \"child class\"). Methods can be overridden in subclasses because they all are \"virtual\" by default. \u009f The term virtual indicates the possibility to rede\ufb01ne the behavior of a method in the subclasses. It\u2019s a very common OOP concept. Actually Dart doesn\u2019t have the virtual keyword but it\u2019s \"implicit\" because any method can be overridden along the hierarchy. The annotation @override is optional but you\u2019d better always use it. Starting from Dart .9 onwards, implicit downcasts are not allowed: class A { double test(double a) => a * .; } class B extends A { @override double test(double a) => a * .; } Flutter Complete Reference 105",
  ". Inheritance and Exceptions void main() { A obj1 = A(); A obj2 = B(); // Upcast B obj3 = obj1; // Downcast - ERROR from Dart .9 print(\"${obj1.test()}\"); // Prints .5 print(\"${obj2.test()}\"); // Prints . } This behaves in the classic OOP way; obj1 calls the method in class A while obj2 calls the overridden version in class B. When overriding, you can reference the original method de\ufb01nition in the superclass: class B extends A { @override double test(double a) { final original = super.test(a); return original * .; }; } The special keyword super holds a reference to the super class. The usage of super.test(a) calls the test() method de\ufb01ned in the superclass. In Java for example, you get the same behavior. \u009f You cannot block inheritance since every class can have the extends modi\ufb01er. In Java for example you can write final class A {} to say \"hey, you can\u2019t inherit from me\" but in Dart there is no equivalent. You\u2019re allowed to also override setters (set) and getters (get) other than regular methods. Dart doesn\u2019t support multiple inheritance, like C++ does for example, meaning that extends works only with a single class: // Ok class A {} class B extends A {} // Doesn't work class A {} Flutter Complete Reference 106",
  ". Inheritance and Exceptions class B {} class C extends A, B {} When overriding a parameter\u2019s type with a subtype, the compiler emits an error. Thanks to the covariant keyword, you can turn o\ufb00static analysis for this kind of error to tell the compiler you know you\u2019re doing this intentionally. Here\u2019s an example: abstract class Fruit {} class Apple extends Fruit {} class Grape extends Fruit {} class Banana extends Fruit {} abstract class Mammal { void eat(Fruit f); } class Human extends Mammal { // Ok void eat(Fruit f) => print(\"Fruit\"); } class Monkey extends Mammal { // Error void eat(Banana f) => print(\"Banana\"); } Instead of eat(Banana f) we should have written eat(Fruit f) inside Monkey because the superclass method is asking for Fruit. However, we can allow the de\ufb01nition of a subtype in an overridden method with covariant: class Monkey extends Mammal { void eat(covariant Banana f) => print(\"Banana\"); } Now the code compiles. Usually the superclass method is the best place where you could use covariant because it removes the \"subtype constrain\" along the entire hierarchy. abstract class Mammal { void eat(covariant Fruit f); } class Human extends Mammal { // Ok void eat(Fruit f) => print(\"Fruit\"); Flutter Complete Reference 107",
  ". Inheritance and Exceptions } class Monkey extends Mammal { // Ok void eat(Banana f) => print(\"Banana\"); } Thanks to covariant Fruit at the top, any subclass is allowed to override eat() with Fruit or a subtype. This keyword can also be applied to setters and \ufb01elds. ..1 super and constructors Every subclass in Dart automatically tries to call the default constructor of the superclass. If there isn\u2019t one, you must call the superclass constructor manually in the initializer list. class Example { int a; Example(this.a); } class SubExample extends Example { int b; // If you don't call 'super(b)' the compilation will fail // because the father class has NO default constructor SubExample(this.b) : super(b); } The superclass constructor must be called in SubExample because the compiler has to somehow initialize the variable a of Example. However super is not needed when the class has a default constructor: // The compiler automatically generates the default constructor // which is just 'Example();' class Example { int a = ; } class SubExample extends Example { int b; // No need to call super SubExample(this.b); Flutter Complete Reference 108",
  ". Inheritance and Exceptions } Which is equivalent to... class Example { int a = ; Example(); } class SubExample extends Example { int b; SubExample(this.b) : super(); } ... but you shouldn\u2019t do this because the compiler adds the missing pieces for you. You should call the superclass constructor only when there are parameters to pass. The call to super(), in case of an initializer list, always goes last: // Compiles MyClass(int a) : _a = a, super(a*a); // Doesn't compile MyClass(int a) : super(a*a), _a = a; ..2 Abstract classes The abstract keyword de\ufb01nes a class that cannot be directly instantiated: only its derived classes can. An abstract class can de\ufb01ne one (or more) constructors as usual. abstract class Example { // This is an abstract method void method(); } Usually abstract classes contain abstract methods which can be de\ufb01ned putting a semicolon (;) instead of the body. You cannot de\ufb01ne an abstract method in a class that\u2019s not been marked with the abstract modi\ufb01er. // Wrong: doesn't compile class Example { // This method is abstract (no body) BUT the Flutter Complete Reference 109",
  ". Inheritance and Exceptions // class doesn't have the 'abstract' modifier void method(); } // Correct: it compiles abstract class Example { // Good job, this abstract method is in an // abstract class void method(); } If your class contains at least one method with no body, then it must be abstract and the children must provide an implementation. You could also do this: abstract class Example { void method(); } class ExampleTwo extends Example {} ExampleTwo is an abstract class too because it doesn\u2019t contain an implementation of method(); yet. A class is concrete (and thus not abstract) when every method has a body. abstract class Example { void method(); } class ExampleTwo extends Example { @override void method() { print(\"I'm not abstract!\"); } } Now ExampleTwo is a concrete class. As we\u2019ve already said, getters and setters can also be abstract and they\u2019re declared in the same way as methods (without a body). abstract class Example { final int _a; const Example(this._a); Flutter Complete Reference 110",
  ". Inheritance and Exceptions // Abstract getter int get calculate; // Abstract method int doSomething(); } ..3 Interfaces In contrast to other programming languages, Dart does not have an interface keyword and you have to use classes to create interfaces. Your class can implement more than a single inter- face. abstract class MyInterface { void methodOne(); void methodTwo(); } class Example implements MyInterface { @override void methodOne() {} @override void methodTwo() {} } The keyword is implements and, di\ufb00erently from a regular subclass, here you must override ev- ery method de\ufb01ned by the class/interface. The o\ufb03cial documentation states the following: \u009f Every class implicitly de\ufb01nes an interface containing all the instance members of the class and of any interfaces it implements. If you want to create a class A that supports class B\u2019s API without inheriting B\u2019s implementation, class A should imple- ment the B interface. In Dart when you use the term interface you are referring to a class that is going to be used by others along with implements because it only provides method signatures. The concept is the same you can \ufb01nd in Java, Delphi or C# with the only di\ufb00erence that Dart doesn\u2019t have a Flutter Complete Reference 111",
  ". Inheritance and Exceptions dedicated keyword. // Instead of the 'interface' keyword, 'abstract class' is used abstract class OneInterface { void one(); } abstract class TwoInterface { void two(); } class Example implements OneInterface, TwoInterface { @override void one() {} @override void two() {} } While extends can be used with only one class, implements works with one or more classes, which you should treat as interfaces (methods with no body). You could also do the following: class OneInterface { void one() {} } class TwoInterface { void two() {} } class Example implements OneInterface, TwoInterface { @override void one() {} @override void two() {} } Classes and abstract classes can both be treated as interfaces with the di\ufb00erence that in concrete classes there must be at least an empty body. For this reason, in the above example we\u2019ve put Flutter Complete Reference 112",
  ". Inheritance and Exceptions an empty body. \u009f We recommend to use abstract classes as interfaces so that you can write only the name of the method, like void test();. If you used a regular class you\u2019d have to write void test() {} which is identical but it has an unnecessary empty body. ...1 extends vs implements You\u2019ve just seen that extends is for subclasses and implements is for classes treated like if they were interfaces. It would be very fair if you were puzzled about the situation. Let\u2019s start with the technical di\ufb00erence: \u2022 When you use class B extends A {} you are NOT forced to override every method of class A. Inheritance takes place and you can override as many methods as you want. \u2022 When you use class B implements A {} you must override every method of class A. Inheritance does NOT take place because methods just provide an API, a \"skeleton\" that the subclass must concretize. In practical terms instead: \u2022 extends. This is the typical OOP inheritance that can be used when you want to add some missing features in a subclass. In chapter 8 we will see that it\u2019s a good practice deriving only abstract classes and not concrete classes. \u2022 implements. Interfaces are useful when you don\u2019t want to provide an implementation of the functions but just the API. It\u2019s like if the interface was wall socket and the class was the plug that adapts to the holes. While multiple inheritance is not allowed, you can extends a class and implements more than one. This is also how Java and C# behave, for example. // Error class A extends B, C, D {} // Valid class A extends B implements C, D {} It might be useful if we made two \ufb01nal examples so that you can visualize the di\ufb00erence. Flutter Complete Reference 113",
  ". Inheritance and Exceptions . When you have a common behavior for every children of your hierarchy, create an abstract class and use extends. Say that you want to read many popular document \ufb01les such as .pdf, .docx and .txt. Inheritance might be a very good idea:1 abstract class Reader { bool fileExists(String path) { // code... } double size(File file) { // code... } String readContents(); } Deciding whether a \ufb01le exists or not and getting its size is something common we always want to be able to call. Reading contents instead is speci\ufb01c to the implementation, it cannot be shared along the hierarchy, so it has to be abstract. class PDFReader extends Reader { @override String readContents() { // code... } } class DocxReader extends Reader { @override String readContents() { // code... } } class TxtReader extends Reader { @override String readContents() { // code... 1See appendix A for more info on the File class Flutter Complete Reference 114",
  ". Inheritance and Exceptions } } It\u2019s been the right choice because fileExists() and size() have been de\ufb01ned only once, so no code duplication, and they\u2019re available in every subclass \"for free\". If we used implements we\u2019d have had to de\ufb01ne all of methods in the subclasses, including the \"shared\" ones leading to code duplication. . When you don\u2019t have methods implementations to share/reuse in the subclasses and you just need to give the signature, use implements. Say that you want to create a few sort- ing algorithms by yourself: using interfaces is the way to go (this is known as \"Strategy pattern\"). // This is going to be the \"interface\" abstract class Sorter { void sort(); String averageComplexity(); } class MergeSort implements Sorter { @override void sort() {...} @override String averageComplexity() => \"n*log(n)\"; } class InsertionSort implements Sorter { @override void sort() {...} @override String averageComplexity() => \"n^\"; } Any sorting algorithm has its own implementation and a particular name, so there\u2019s no common behavior. You just know that every concrete implementation needs a sorting method (void sort()) and the average time complexity (String averageComplexity()). Thanks to implements subclasses have to override every method and adopt a common API. Flutter Complete Reference 115",
  ". Inheritance and Exceptions In summary, if you have common methods along the hierarchy go for subclasses otherwise use classes as interfaces. The usage of implements forces you to override every method; if this is not the behavior you\u2019re looking for, use extends. ..4 Mixins There\u2019s another important concept in Dart, which is the \"cousin\" of abstract classes and inter- faces. A mixin is simply a class with no constructor that can be \"attached\" to other classes to reuse the code without inheritance. mixin Swimming { void swim() => print(\"Swimming\"); bool likesWater() => true; } mixin Walking { void walk() => print(\"Walking\"); } If you use the special with keyword on a class, it acquires any method de\ufb01ned in the mixin. You could see mixins like a \"copy/paste\" tool to reuse methods. class Human with Walking { final String _name; final String _surname; Human(this._name, this._surname); void printName() => \"$_name $_surname\"; } void main() { final me = Human(\"Alberto\", \"Miola\"); // prints \"Alberto Miola\"; method is defined in the class me.printName(); // prints \"Walking\"; method is not defined in the class // but it's \"copied\" and \"pasted\" from the mixin. me.walk(); } Flutter Complete Reference 116",
  ". Inheritance and Exceptions The class Human doesn\u2019t have a walk() method inside but it\u2019s automatically imported from the Walking mixin. Since mixins are just classes without a constructor, you could also successfully compile the following code: // use 'class' instead of 'mixin' class Walking { void walk() => print(\"Walking\"); } class Human with Walking {} In general it\u2019d better if you used the mixin keyword since it helps both yourself, to remind what you want to do, and the IDE, which can give you useful hints. Furthermore, using the mixin keyword is less confusing than class. \u009f Note that your class must have no constructors declared in order to be used as mixin. class Walking { Walking(); void walk() => print(\"Walking\"); } // Does not compile class Human with Walking {} Even if you\u2019ve declared the empty non-argument constructor (Walking()) this class is not treated as a mixin. You should prefer mixin over class when you intend to accomplish this purpose. Some other important features o\ufb00ered by mixins are: . A class can have more than a single mixin associated to it and its subclasses inherit the imported methods. mixin Walking { void walk() {} } mixin Breathing { void breath() {} Flutter Complete Reference 117",
  ". Inheritance and Exceptions } mixin Coding { void code() {} } // Human only has walk() class Human with Walking {} // Developer has walk() inherited from Human and also // breath() and code() from the two mixins class Developer extends Human with Breathing, Coding {} . There\u2019s the possibility to constrain the usage of a mixin to subclasses of a certain type. In this way you can make a sort of \"restrictive reusability\": // Constrain 'Coding' so that it can be attached only to // subtypes of 'Human' mixin Coding on Human { void code() {} } // All good class Human {} class Developer extends Human with Coding {} // NO, 'Coding' can be used only on subclasses class Human with Coding {} // NO, 'Fish' is not a subclass of 'Human' so // you cannot attach the 'Coding' mixin class Fish with Coding {} Mixins are di\ufb00erent from abstract classes and interfaces because they do not involve inheritance at all: they don\u2019t create hierarchies. They are just a way to reuse code without having to deal with superclasses, overrides and so on. \u009f There is no rule of thumb to follow when it comes to the question \"when should I prefer mixins over interfaces/abstract classes?\" because the answer would be \"It depends!\". However, here\u2019s a general idea that you can follow to take your decision. Flutter Complete Reference 118",
  ". Inheritance and Exceptions In general your \ufb01rst choices should be abstract classes or interfaces, with all their implementations in the various subclasses. Mixins are very handy when di\ufb00erent pieces of architecture have the same identical code which cannot be shared due to a lack of inheritance. Let\u2019s say you have these classes in a folder: import 'dart:math'; abstract class FootballTeam { String name(); void playsWith() => print(\"Ball\"); double ballVolume(double radius) { const values = / * .; return values * pow(radius, ); } } class RealMadrid extends FootballTeam { ... } class LiverpoolFC extends FootballTeam { ... } And then, still in the same project, you have in another folder this hierarchy: abstract class VolleyballTeam { String nameAndAbbreviation(); void playsWith() => print(\"Ball\"); double ballVolume(double radius) { const values = / * .; return values * pow(radius, ); } } class TeamA extends VolleyballTeam { ... } class TeamB extends VolleyballTeam { ... } You see two separated hierarchies (which is good) with a few identical methods. You could create a superclass for VolleyballTeam and FootballTeam but it couldn\u2019t be possible due to the structure itself of your architecture. A good solution is the usage of a mixin which provides code sharing with no inheritance. mixin BallSports { Flutter Complete Reference 119",
  ". Inheritance and Exceptions void playsWith() => print(\"Ball\"); double ballVolume(double radius) { const values = / * .; return values * pow(radius, ); } } At this point you can get rid of the redundant methods and use the mixin to share the imple- mentation (across the hierarchy as well). In this way you\u2019ve removed code duplication, which is always a problem in terms of maintenance. // Somewhere in your project... abstract class FootballTeam with BallSports { String name(); } // Somewhere else in your project... abstract class VolleyballTeam with BallSports { String nameAndAbbreviation(); } No more code duplication because the mixin solved the problem. Both hierarchies are separated because they are two di\ufb00erent things but they have something in common. A mixin makes methods reusable without having to rely on inheritance. ..5 Good practices Generally, factory constructors are used to return \"default\" implementations of a certain class. For example, if you had a series of encryption algorithms, you could de\ufb01ne a default one in this way: abstract class EncryptionAlgo { // 'AESEncryption' is the default encryption algorithm factory EncryptionAlgo() { return AESEncryption(); } void decrypt(String filePath); } Flutter Complete Reference 120",
  ". Inheritance and Exceptions class AESEncryption extends EncryptionAlgo { ... } class RSAEncryption extends EncryptionAlgo { ... } class BlowfishEncryption extends EncryptionAlgo { ... } With this technique, you can use EncryptionAlgo to return an instance of AESEncryption: // 'encrypt' is actually 'AESEncryption' because you're calling the // factory constructor final encrypt = EncryptionAlgo(); You are NOT creating an instance of an abstract class (which is impossible): you\u2019re just calling the factory constructor of EncryptionAlgo which returns a AESEncryption. This technique is used to return \"default\" instances of a certain hierarchy. You could use an even shorter syntax: abstract class EncryptionAlgo { factory EncryptionAlgo() = AESEncryption; void decrypt(String filePath); } This kind of constructor assignment is just a shorter syntax to redirect a constructor to another. However, they must have the same number and type of arguments otherwise it won\u2019t compile. Basically you\u2019re telling the compiler to call the constructor of AESEncryption (along with the params, if any) when the factory is invoked. .2 Extension methods Starting from Dart .7 the team has added extension methods, a way to add functionalities to a library knowing nothing about its internal implementation. Let\u2019s take a look at the String class, which has a lot of methods: // A string var name = \"Alberto\"; // Some methods of the string class name.toUpperCase(); name.toLowerCase(); name.trimLeft() Flutter Complete Reference 121",
  ". Inheritance and Exceptions Earlier we worked hard to create a Fraction class and it would be really cool if we were able to integrate it with strings. Something like this: final Fraction value = \"/\".toFraction(); value.reduce(); value.negate(); Given a string, we could add the toFraction() method that returns a Fraction whenever possible. We don\u2019t have access to the String class and we can not edit the \ufb01le in which it\u2019s been declared, of course. Extension methods come to the rescue: extension FractionExt on String { bool isFraction() => ... // Converts a string into a fraction Fraction toFraction() => Fraction.fromString(this); } The this identi\ufb01er refers to the object on which you are calling the method. What\u2019s written as this.contains(\"/\") is evaluated to \"/\".contains(\"/\") is the example: extension FractionExt on String { // code... } void main() { var str = \"/\"; if (str.isFraction()) { final frac = str.toFraction(); } } With extension methods we\u2019ve just extended the String class with new functionalities without changing the de\ufb01nition of the class. Methods have been added \"from the outside\". \u009f Abstract classes, interfaces and mixins are for \"internal use\" in the sense that with them you touch the class directly from the inside. Extensions are for \"external use\" in the sense that you add methods from the outside without changing the internal Flutter Complete Reference 122",
  ". Inheritance and Exceptions part of the class. With extensions you can also de\ufb01ne getters, setters, operators, static \ufb01elds and/or methods. If you need to use some utility private functions inside the extension, just append an underscore (_) in front of the name. It\u2019s like with classes, where void _method() {} is private to its library. \u009f Extension methods also work with generic types. You could for example write extension Test<T> on List<T> {} where T is statically determined by the com- piler. Generics and collections will be discussed in the next chapter. ..1 Good practices Generally extension methods should be put in a dedicated \ufb01le. For example, the previous exten- sion of fraction could go on fraction_ext.dart so that it can be imported as a library. // === file fraction_ext.dart === // extension FractionExt on String { // code... } // === file main.dart === // import 'package:fraction_ext.dart'; void main() { final check = \"hello\".isFraction(); } Short and trivial operations should be implemented with extensions in order to improve the usability, the readability. Don\u2019t you agree that... final f = \"/\".isFraction(); ... looks better than a static method call? final f = Fraction.isFraction(\"/\"); Keep in mind that extension methods cannot be used if you\u2019re treating a variable with dynamic. They support type inference and then the compiler must always exactly know the types. // It compiles but gives a runtime exception Flutter Complete Reference 123",
  ". Inheritance and Exceptions dynamic f = \"/\"; f.isFraction(); Before moving on, let\u2019s try to make a simple summary of all the features we\u2019ve seen up to now in this chapter. \u2022 Internal use. These techniques are meant for \"internal use\" because they can work directly inside the de\ufb01nition of the class. \u2013 extends. It\u2019s the typical OOP inheritance: you don\u2019t need to override every method, getter or setter. Use it when there is a \"common\" behavior to share along the hierarchy. \u2013 implements. The \"interface\" OOP concept: you need to override every method, getter or setter. Use it when you want to de\ufb01ne an API for many types (they have no common behaviors to share). \u2013 mixin. A way to \"copy/paste\" methods into classes: they reduce code duplication and centralize the code. The imported methods are also shared along the hierarchy. \u2022 External use. These techniques are meant for \"external use\" because they cannot modify the class from the inside. \u2013 extension. They add functionalities to a class without changing its internal de\ufb01nition. They\u2019re generally used to \"improve\" a class without touching its internals. .3 The Object class Even if it\u2019s not explicitly written in the code, any Dart class descends from class Object {} which is at the root of any hierarchy. This is the same structure that some popular languages such as Java, C# and Delphi adopt. Every class can, and should, override the methods declared in Object. \u2022 String toString(). This method is very important and you should always override it because a string representation of an object is quite handy, especially while debugging. If you have it de\ufb01ned you can better handle the string conversion: final f = Fraction(, ); final s = \"My fraction is $f\"; String interpolation automatically calls toString() which makes the code shorter and more readable. Flutter Complete Reference 124",
  ". Inheritance and Exceptions \u2022 bool operator ==(SomeClass other). When you want to compare two objects you have to use the == operator. By default it doesn\u2019t really work as you\u2019d expect; it returns true only if two variables point to the same object. class Example { int a; Example(this.a); } void main() { final ex1 = Example(); final ex2 = ex1; print(ex1 == ex2); //true } The console outputs true because ex2 points to the same reference held by ex1; both variables point to the same object so they\u2019re equal. By default the == operator compares references and doesn\u2019t look at the object itself; it only cares about what\u2019s being pointed to. void main() { final ex1 = Example(); final ex2 = Example(); print(ex1 == ex2); //false } Logically we\u2019d think they were equal but the compiler tells us another story. ex1 and ex2 point to two di\ufb00erent objects that are logically equal but practically di\ufb00erent because each variable holds a di\ufb00erent reference. You have to override the equality operator to get the desired behavior: class Example { int a; Example(this.a); @override bool operator ==(Object other) { // . if (identical(this, other)) return true; Flutter Complete Reference 125",
  ". Inheritance and Exceptions // . if (other is Example) { final example = other; // . return runtimeType == example.runtimeType && a == example.a; } else { return false; } } // . @override int get hashCode => a.hashCode; } That\u2019s a lot of boilerplate code but you don\u2019t have any other choices. For sure if you come from the Java world you might have dealt with this exact same thing thousands of times. . The function identical() is provided by the Dart code API and checks if two objects have the same reference. . If the type of the compared object is equal to the type of the current object, a smart cast happens in the body to proceed with the comparison. Otherwise, false is returned. . Check if the runtime types are the same and then make a one by one comparison for every instance variable. . See the next point. Those two overrides allow a proper object comparison as you\u2019d expect. Running this ex- ample would output true because we\u2019ve taught operator== to look at the object itself and not only at the references. void main() { final ex1 = Example(); final ex2 = Example(); print(ex1 == ex2); // true -> that's what we wanted! } \u2022 int get hashCode. When you override the equality operator, you must always remember Flutter Complete Reference 126",
  ". Inheritance and Exceptions to also override hashCode. The hash code is useful when you call the identical() method and also when you use \"hash maps\" we\u2019re going to analyze in the next chapter. If you know what hash tables are, you are aware that the keys must not clash in order to keep good performances. Dart\u2019s implementation of hash tables guarantees O() in insertion if hash codes of di\ufb00erent objects return di\ufb00erent values (no collisions). ..1 Comparable<T> Other than overriding operator== and hashCode, if you wanted to do a precise and complete comparison setup of a class, you should also implement Comparable<T>. This is how a complete comparison logic for a Fraction class would look like: class Fraction implements Comparable<Fraction> { final int num; final int den; const Fraction(this.num, this.den): double toDouble() => num / den; @override int compareTo(Fraction other) { if (toDouble() < other.toDouble()) return -; if (toDouble() > other.toDouble()) return ; return ; } @override bool operator==(Object other) { ... }; @override int get hashCode { ... }; } Comparable<T> exposes the compareTo() method which can be used for ordering and sorting. The returned int value must follow this convention: \u2022 if this instance is naturally < than the other, return a negative number; \u2022 if this instance is naturally > than the other, return a positive number; Flutter Complete Reference 127",
  ". Inheritance and Exceptions \u2022 if the two instances are equal, return . Returning 1 and -1 is just a convention; it can be any positive or negative number. In our case, we have done the following: \u2022 a fraction is naturally < than another if its double representation is smaller than the other. For this reason, we return -1 in case the num / den ratio of the current instance were < than the other. if (toDouble() < other.toDouble()) return -; \u2022 a fraction is naturally > than another if its double representation is greater than the other. For this reason, we return 1 in case the num / den ratio of the current instance were > than the other. if (toDouble() > other.toDouble()) return ; \u2022 two fractions are equal if the rational number they represent is also equal. For this reason, we return 0 if none of the above statements passed. return ; In general, comparing \ufb02oating point numbers using <, <=, > and >= is safe. Comparing \ufb02oating point values with operator== is very error prone; two values that should be equal may not be due to arithmetic rounding errors. This is the reason why we use return 0 as \"fallback\" rather than checking for equality of double values. .4 Exceptions Dart code can throw exceptions to signal that an unexpected or erroneous behavior has happened during the execution. When you throw an exception you should really catch it otherwise your program will forcefully terminate with an error code. class Fraction { int _numerator; int _denominator; Fraction(this._numerator, this._denominator) { if (_denominator == ) { throw IntegerDivisionByZeroException(); } } Flutter Complete Reference 128",
  ". Inheritance and Exceptions } The denominator of a fraction cannot be zero and in our example the constructor is the best place to throw an exception. It signals that something\u2019s gone wrong, in this case an invalid parameter. You can only throw objects. \u009f The IntegerDivisionByZeroException() class is provided by Dart and it should be used when... a division by zero happens! Despite you can throw any object, classes with meaningful names should be preferred. class RandomClass() {} void main() { // It compiles. It's perfectly fine throw RandomClass(); } You could also throw a single string like throw \"Whoops\"; because String is a Dart class. There are a few interchangeable classes that can be thrown in exceptions. For sure, if you have a format error you\u2019re not going to throw a TimeoutException. \u2022 DeferredLoadException \u2022 FormatException \u2022 IntegerDivisionByZeroException \u2022 IOException \u2022 IsolateSpawnException \u2022 TimeoutException You can throw everything except for null. ..1 on and catch If you don\u2019t catch an exception, your program forcefully terminates but you never want to be in such situation. It\u2019s always a good idea handling exceptions by catching them. Flutter Complete Reference 129",
  ". Inheritance and Exceptions void main() { try { final f = Fraction(, ); } on IntegerDivisionByZeroException { print(\"Ouch! Division by zero!\"); } } This code is safe because the exception raised by the constructor of Fraction is caught by a try block. If you want to get an instance of the thrown exception, just add a catch statement: void main() { try { final f = Fraction(, ); } on IntegerDivisionByZeroException catch (exc) { // use the exc object doSomething(exc); print(\"Ouch! Division by zero!\"); } } exc is an instance of the thrown object that can only be used within the scope of on. This approach can be useful when there\u2019s the need to print a stack trace or any useful debugging info about the exception. void main() { try { final f = Fraction(, ); } on IntegerDivisionByZeroException { print(\"Division by zero!\"); } on FormatException { print(\"Invalid format!\"); } } You can handle code that could throw more than a single exception by specifying multiple catch clauses. The \ufb01rst clause that matches the thrown object will be picked to handle the error propagation. What if the above code threw an IOException or another object you haven\u2019t handled? The program would crash because there would be a not handled exception. Flutter Complete Reference 130",
  ". Inheritance and Exceptions void main() { try { final f = Fraction(, ); } on IntegerDivisionByZeroException { print(\"Division by zero!\"); } on FormatException { print(\"Invalid format!\"); } catch (e) { // You arrive here if the thrown exception is neither // IntegerDivisionByZeroException or FormatException print(\"General error: $e\"); } } The \ufb01nal catch is a fallback that captures everything else that didn\u2019t match the above types. You\u2019re guaranteed that this code is safe because, worst case, the two on will be skipped and the execution will fall inside the \ufb01nal catch. .. \ufb01nally The try - catch block protects your code against runtime exceptions that alter the normal execution \ufb02ow. As you know, if no exceptions occur nothing happens because the catch block doesn\u2019t execute. void main() { try { final f = Fraction(, ); } catch (e) { print(\"Error\"); } print(\"Finish\"); } This simple code only outputs \"Finish\" because no exceptions have been thrown. However, there is a way to force the execution of a part of the try statement. void main() { try { final f = Fraction(, ); Flutter Complete Reference 131",
  ". Inheritance and Exceptions } catch (e) { print(\"Error\"); } finally { print(\"Always here\"); } print(\"Finish\"); } The body of a finally block is always executed, no matter if an exception occurs or not. The above code prints \"Always here\" and then \"Finish\" on a new line. \u2022 The code inside on or catch is executed only if an exception is thrown and a valid handler for the object is provided. If no exceptions are thrown, nothing happens. \u2022 The code inside a finally block is always executed regardless the fact that an exception object is thrown or not. ..3 Good practices The Dart API provides the Exception interface which is implemented by all core library ex- ceptions. Production-quality code usually throws subtypes implementing one of the following classes. \u2022 Exception. Implement this interface to create errors that will be caught when something goes wrong. For example, doing this is a good idea: class FractionDivisionByZero implements Exception { final String message; const FractionDivisionByZero(this.message); @override String toString() => message; } We can throw the class FractionDivisionByZero speci\ufb01c object rather than a general purpose IntegerDivisionByZeroException. When you have to throw an object, imple- ment Exception and choose a proper name that describes what\u2019s gone wrong. Flutter Complete Reference 132",
  ". Inheritance and Exceptions \u009f The o\ufb03cial documentation 2 suggests to not use throw Exception(\"...\");. Yes, you could, but it\u2019s bad because it doesn\u2019t give a precise type that can be caught with the on keyword. \u2022 Error. You should subclass this type for all those programmer-relates errors such as going out from the bounds of a list or having an assertion that evaluates to false. Error is thrown in case of an unexpected program \ufb02ow and you should NOT catch it. class Example { int x; Example(this.x) : assert(x != ); } In debug mode, if x is 0 an AssertionError is thrown. You shouldn\u2019t catch it and that\u2019s perfectly \ufb01ne because you, the developer, must see that kind of error: it signals you\u2019ve coded something in the wrong way. The IDE will produce an alert when an object of type Error is being caught. \u009f In practice you\u2019re allowed to catch Errors but you shouldn\u2019t. This kind of exceptions signal that you, the programmer, failed something and you must see it because a \ufb01x is required! Error is an alert for the developer telling him that something really bad happened, such as an index gone out of the bounds or a critical I/O issue. The usage di\ufb00erence lies on the logical concept. \u2022 You almost always want to throw an object that implements Exception because you are the owner of the code and you decide what\u2019s wrong. Anyone else going to use your code will catch your exception object in order to know that something went wrong. \u2022 You want to extend (and not implement) Error if you\u2019re dealing with particular code that might cause I/O issues, lists out of bounds or other \"particular\" error that a programmer can do. Put in other terms, exceptions are \"logical errors\" that can be \ufb01xed while errors are \"language speci\ufb01c\" mistakes that cause core problems in your code. Other recommendations taken from 2https://api.dart.dev/stable/../dart-core/Exception-class.html Flutter Complete Reference 133",
  ". Inheritance and Exceptions the o\ufb03cial guidelines 3 are: . In a try block you should use on to catch speci\ufb01c types and decide what to do according with the related error. try { // code... } catch (e) { // handle... } This code is really bad because it catches everything, including Error (or its subtypes) which should not be caught. What you\u2019ve just seen is the \"Pok\u00e9mon exception handling\" and it\u2019s not a joke! Even the o\ufb03cial Dart doc mentions it. \u009f It actually makes sense: the Pok\u00e9mon motto is \"Gotta catch \u2019em all\" because the goal of the game is capturing any Pok\u00e9mon encountered during the journey. You don\u2019t want to be a Pok\u00e9mon programmer who bravely catches any exception with no regards, don\u2019t you? If you really need to \"eat\" as many exceptions as possible, use this version: try { // code... } on Exception catch (e) { // handle... } It\u2019s still not good but at least way better than before because Error is not captured and it\u2019s still free to propagate. . Use on SomeException catch (e) to implement a logic for any type of thrown object. . Don\u2019t \"eat\" exceptions. If you really need to do nothing when an exception occurs, print a message to the console or show a popup to notify your users that something\u2019s gone wrong. try { // Exception is 'eaten' because when caught, nothing happens } on Exception catch (e) {} 3https://dart.dev/guides/language/e\ufb00ective-dart/usage#error-handling Flutter Complete Reference 134",
  ". Inheritance and Exceptions . If you implement Exception, append it at the end of your custom class name such as FractionException or NumeratorNullException. The same concept applies when you deal with Error. . Do not catch exceptions objects whose type is Error. . If you want to rethrow an exception, you should use rethrow rather than throwing the same object again with throw . try { try { throw FormatException(); } on Exception catch (e) { print(\"$e\"); rethrow; } } catch (e2) { print(\"$e2\"); } try { try { throw FormatException(); } on Exception catch (e) { print(\"$e\"); throw e; } } catch (e2) { print(\"$e2\"); } . Both ways of rethrowing an exception are valid but you should prefer the usage of rethrow (on the left) because is preserves the original stack trace of the exception. throw instead resets the stack trace to the last thrown position. 4https://dart.dev/guides/language/e\ufb00ective-dart/usage#do-use-rethrow-to-rethrow-a-caught-exception Flutter Complete Reference   | Generics and Collections .1 Generic types Nowadays a very common feature of languages is the support for parameterized programming, also known as generic programming in the Dart, Java, C# and Delphi world. The biggest advantages brought from this approach are type-safety and code reusability. ..1 Introduction The best way to show how generics can be incredibly useful is via example. In Flutter you\u2019ll use very often caches to store data coming from your device or from the internet. Pretend you had to store a complex object: the \ufb01rst idea popping in your mind could be: class ComplexObjCache { final _obj = ComplexObj(); // Constructor, getters, setters, methods... } The next day you have the need for another cache, with the same structure, but it has to handle \ufb02oating point numbers. Good, you already know what to do: copy-paste the previous class and change the types from ComplexObj to double using the IDE refactor tool. class DoubleCache { final _obj = .; // Constructor, getters, setters, methods... } One week later you need the same cache also for Strings, integers, and other objects but things start to get complicated. You\u2019ve copy-pasted classes because they have the exact same structure and methods but the only di\ufb00erence is the data type. Flutter Complete Reference 136",
  ". Generics and Collections class ComplexObjCache { } class ComplexObj2Cache { } class ComplexObj3Cache { } class StringCache { } class IntegerCache { } class DoubleCache { } Massive code duplication is guaranteed to be a maintenance nightmare. With generics you can easily solve the problem using a placeholder type that will be evaluated at compile time. In general a single letter is enough, such as T or K, but there are no restrictions on the length (PIZZA would be valid for example). class Cache<T> { final T _obj; // Constructor, getters, setters, methods... } Using the <T> notation you\u2019re telling the compiler that, at compile time, the letter T has to be substituted with the type given by the actual instance. In this way you have a single class allowed to work with multiple types and thus maintenance gets way easier. \u009f For example, in final c = Cache<String>(\"\"); the letter T is substituted with String at compile time. Potential errors, such as bad type casts, produce a compila- tion error. ..2 Type safety Generics might remind you of dynamic, as it works with any type, and actually they could do the same things. For example, rather than Cache<T> you could have created a Cache with dynamic \ufb01elds: class Cache { dynamic _obj; dynamic get value => _obj; // Constructor, getters, setters, methods... } The biggest problem is that dynamic has zero type safety as it\u2019s intended to work with runtime casts. You\u2019d have to deal with long series of if statements for each dynamic variable because Flutter Complete Reference 137",
  ". Generics and Collections casts must be safe. The compiler and the IDE won\u2019t be able to help you with static analysis. \u009f Manually dealing with lots of casts and type checks is one of the worst mainte- nance nightmares, especially if you\u2019re in a complex architecture with tons of dynamic types. In addition, potential problems with types are spotted at runtime while with generics they\u2019re immediately caught by the compiler. With generics, casts are not needed because the compiler ensures a \"protection\" against wrong types usages. The code is said to be safe because type errors are known at compile time and not at runtime. class Cache<T> { final T _obj; T get value => _obj; // Constructor, setters, methods... } void main() { final cache = Cache<int>(); String value = cache.value; // Error! } The compiler generates an error because you\u2019re trying to assign an integer value (cache.value) to a string type. You\u2019ll also get an alert from the IDE before compiling and the debugger will \ufb01nd this error immediately. In contrary: // using 'class Cache {}', the non-generic one void main() { final cache = Cache(); String value = cache.value; // Compiles, but it's wrong! } Here you get no compilation errors because dynamic is evaluated at runtime. The IDE won\u2019t help you because it cannot predict the future and imagine that at runtime an int will be assigned to a String. Debugging might not be so easy and you\u2019re going to waste time. \u009f We\u2019ve said waste because you could have saved that time with generics! The compiler would have been able to tell you in which line the error was but the usage Flutter Complete Reference 138",
  ". Generics and Collections of dynamic defers everything at runtime, so no help at all. As you may have guessed, using generics in place of dynamic is almost always the best choice you can make. When you try to write parameterized code, always consider generics \ufb01rst! ..3 Usage There\u2019s nothing new about hierarchies of one or more generic types; what we\u2019ve already covered about classes and inheritances also applies here. They work in the same way as \"regular\" non- generic classes with the only di\ufb00erence that the type goes inside the diamonds < >. abstract class Cache<T> { final T _obj; Cache(this._obj); T get value => _obj; void handle(); } // . class LocalCache<T> extends Cache<T> { LocalCache(T obj) : super(obj); void handle() {} } // . class CloudCache<T, K> extends Cache<T> { CloudCache(T obj, K obj2) : super(obj); void handle() {} } There\u2019s the possibility to de\ufb01ne a in\ufb01nite number of generic types per class, they just need to be separated by commas in the diamond list (< >) with the letters inside. Generics also work with extends and implements. . A subclass must declare at least the same number of parameterized types de\ufb01ned by its superclass. . You cannot write LocalCache<A> extends Cache<T> {} because the compiler tries to pass Flutter Complete Reference 139",
  ". Generics and Collections A to the superclass constructor which expects a T. The letters must match. . You can declare how many parameters you want. In the above example T and K are separately treated even if they will be used to represent the same type. The usage of CloudCache<int, int> gives no problems because the compiler treats T and K as two di\ufb00erent entities and it doesn\u2019t care about the type they represent. There\u2019s the possibility to put constraints on the types if you don\u2019t want them be \"anything\". For example, if we wanted our caches to be used only with numbers, we could have done the following: abstract class Cache<T extends num> { } abstract class LocalCache<T extends num> extends Cache<T> { } abstract class CloudCache<T extends num, K> extends Cache<T> { } Remember that int and double are subclasses of num. With these changes, the generic type is allowed to be only a subtype of num and nothing else. void main() { // OK. 'int' and 'double' are subclasses of // 'num' so this is allowed final local1 = LocalCache<int>(); final local2 = LocalCache<double>(.); // NO. 'String' is not a subclass of 'num' // so this is NOT allowed final local3 = LocalCache<String>(); } You could also use LocalCache<num>(); but superclasses of num are not allowed. In Dart methods can return generic types and/or have it as parameter, you just have to put the diamonds after the name as you\u2019d do with classes. // T used as return type and parameter T printValue<T>(T val) { // ... return val; } // T user as parameter Flutter Complete Reference 140",
  ". Generics and Collections void check<T>(T val) { // ... return val; } void main() { // Diamond syntax uses the symbols '<' and '>' final a = printValue<int>(); final b = printValue<String>(\"\"); check<double>(.); } A non-generic class can have one or more generic methods inside: class Example { void doSomething<T>(T value) { ... } } .2 Collections Dart implements the most common types of containers using generics so that you can take advantage of type safety without having to deal with speci\ufb01c implementations for each type. We\u2019ve already seen all the bene\ufb01ts in the previous section so let\u2019s get started. ..1 List As you already know from chapter , the language doesn\u2019t have arrays but only lists. They\u2019re implemented with the List<T> generic container you\u2019ve already seen many times up to now: // The type of 'intList' is List<int> var intList = [, , -, , ]; // The type of 'stringList' is List<String> var stringList = [\"a\", \"hello\"]; Lists are -indexed and have many methods such as add(), length, clear() and so on; check out your IDE or the documentation 1 for a complete list. Like with any other generic type, you have the \"protection\" of the compiler against bad types assignments: 1https://api.dart.dev/stable/../dart-core/List-class.html Flutter Complete Reference 141",
  ". Generics and Collections final list = List<int>(); list.add(\"oops\"); This is clearly a compilation error because you\u2019re trying to assign a string to a container that expects only integers. There is a very nice syntax shortcut allowing you to insert a series of values directly in the array: // 'list1' contains [, ] var list1 = [, ]; // 'list2' contains [-, -, , , ] var list2 = [-, -, , ...list1]; Given a list (list1), you can put every element inside another list using the spread operator (...). If you aren\u2019t sure about the non-nullability of the source, you can add a safety check with the null-aware spread operator (...?). // this is null List<int>? list1; var list2 = [-, -, , ...list1]; // Error var list3 = [-, -, , ...?list1]; // All good There\u2019s the need to use ...? because elements are being added only if the source list is not null; if we had used ...list1 we would have got an error. A list can also be initialized by specifying the type in the diamonds: final list = const <int>[, , , ]; ...1 Collection statements Starting from Dart ., there\u2019s the possibility to use a very convenient syntax you might use some times in Flutter to add elements in a ListView (a scrollable container of UI items). You can put an if statement inside a list to decide whether it\u2019s the case to add or not an item. final hasCoffee = true; final jobs = [ \"Welder\", \"Race driver\", \"Journalist\", if (hasCoffee) \"Developer\" ]; Flutter Complete Reference 142",
  ". Generics and Collections This list contains for sure the \ufb01rst 3 elements but \"Developer\" is going to be added only if hasCoffee is true. Putting an if statement with no parenthesis in a list decides whether the element has to be added or not. const hasCoffee = true; final jobs = const [ \"Welder\", \"Race driver\", \"Journalist\", if (hasCoffee) \"Developer\" ]; If we declared const hasCoffee (rather than using final) then we could have also created a constant list of values. This is even better because the compiler could perform some optimizations at compile time. In a very similar way, you could also use a for loop: final numbers = [ , , , for(var i = ; i < ; ++i) i ]; Like it happened with the if, the for statement adds a series of items to the list. It has no parenthesis or return: just write the values as they are. In this case, the list cannot be const. ...2 Implementation If you were to look at the online source code 2 you\u2019d see that List<E> is de\ufb01ned as abstract class but objects can still be created in the \"normal\" way. You might be puzzled at this point: why can I instantiate an abstract class? final howIsItPossible = List<int>(); As you know, an abstract class cannot be instantiated and that\u2019s always true but List<E> de\ufb01nes a series of factory constructors to do the \"trick\". We have already seen this pattern in ... This is the actual implementation of List<E> in the Dart SDK. abstract class List<E> implements EfficientLengthIterable<E> { // code... 2https://github.com/dart-lang/sdk/blob/master/sdk/lib/core/list.dart Flutter Complete Reference 143",
  ". Generics and Collections external factory List([int? length]); // other code... } Thanks to this, when you write howIsItPossible = List<int>(); you\u2019re actually calling the factory constructor which returns a concrete implementation of List<E>. You cannot see it because of the external keyword, which loads the body of the constructor from the Dart VM, but the factory returns a concrete (non-abstract) class. \u009f The external keyword is used to interact with the Dart VM as it loads speci\ufb01c pieces of code. You\u2019ll never use it. It loads the body of a function directly from the internals of the SDK, which is almost always C++ code. So, instead of having a factory with a body... factory List([int? length]) { // Dart code here... } ... the de\ufb01nition is placed somewhere else. In other words, external is used to say \"the body of this function is not here, in the Dart \ufb01le, but it\u2019s located somewhere in the VM. // Thanks to 'external,' the body is not directly loaded from here, // the .dart file, but it's taken from somewhere else external factory List([int? length]); Unless you\u2019re a developer from the Dart team, this keyword is not for you. Because of factory List([int? length]) it seems you\u2019re instantiating an abstract class from your code but no, in reality you\u2019re calling a factory constructor returning a concrete instance. With this pattern, List<T> returns a default implementation which is generally good for most of the use cases. The subclasses returned by the factory can be: \u2022 Growable. You can increase and decrease the length of the list with no restrictions. A growable list has no length parameter in the constructor. // No int param in the parenthesis -> no length specified // so this list is growable final growable = List<int>(); growable.length = ; Flutter Complete Reference 144",
  ". Generics and Collections \u2022 Fixed. You can not increase and decrease the length of the list with no restrictions. A \ufb01xed list has the length parameter in the constructor. // int param in the parenthesis -> lenght is specified // so this list is fixed final growable = List<int>(); growable.length = ; // Error! In general creating a growable list with List<int>() is good but if you don\u2019t need to change the size of the container go for List<int>(). There are other useful factory constructors from this class: \u2022 filled() It creates a list of the given length and initializes each position with the elements you want. final example = List<int>.filled(, , growable: true); // Now example has this content: [, , , , ] \u2022 unmodifiable() It returns a copy of the given list in which you cannot call add, remove or other methods that would modify its content. var example = List<int>.unmodifiable([,,]); example.add(); // Runtime error \u2022 generate() Creates a list of the given length and \ufb01lls each position according with the value returned by the generator. This example \ufb01lls the array with the power of each number. var example = List<int>.generate(, (int i) => i*i); // Now example has this content: [, , , , ] Note that List.unmodifiable() creates a new copy of the list; if you just want to make an unmodi\ufb01able list without having to copy the contents, use UnmodifiableListView<T>. They both create two unmodi\ufb01able lists but in the second case, no copies are made (it\u2019s just a \"wrapper\" around a List<T> object). ..2 Set A Set<T> is a generic container in which there cannot be duplicate objects. Sets can be directly initialized using braces without having to create a new instance and then add elements with a loop. final keys = {, , , , , }; Flutter Complete Reference 145",
  ". Generics and Collections for(var key in keys) print(key); The console will output     5 and not      5 because duplicates are not added (no exceptions are thrown). Elements can be inserted by using functions like add() or addAll(); for any possible method on Set<T> you should check the o\ufb03cial documentation . \u009f When creating an empty set, there\u2019s the need to use the diamonds to specify the type. Otherwise, avoid using type inference and annotate the type directly: // . Direct type annotation Set<int> emptySet = {}; // . Type inference with diamonds final emptySet = <int>{}; // . This is a Map, not a set!! final emptySet = {}; Only in cases 1 and 2 you\u2019re creating an empty set. In 3 the compiler considers the final emptySet = {} like if it were a map of dynamic key/value pair. Set<T> supports the ... and ...? operators we\u2019ve seen earlier with lists. You can also use if and for collection statements. \u2022 Adding items in a Set<T> is pretty easy with add() but if you want to insert a series of values, you can also pass an array. final example = <int>{}; example.addAll([, , ]); \u2022 Use bool contains(T value); to check whether an element is in the set or not. \u2022 Remove elements with remove(). If you use the factory Set<T>.unmodifiable(Set<T>> other) you get an instance of the same set with no possibility to add/remove values. There\u2019s no UnmodifiableSetView<T>. 3https://api.dart.dev/stable/../dart-core/Set-class.html Flutter Complete Reference 146",
  ". Generics and Collections ...1 Implementation In Dart sets are abstract class Set<E> extends EfficientLengthIterable<E> and, like we\u2019ve already seen with lists, they use factory constructors to return concrete instances. The implementation is easier to understand because there is no external keyword. abstract class Set<E> extends EfficientLengthIterable<E> { // code... factory Set() = LinkedHashSet<E>; // code... } When we do something like final s = Set<int>(); we\u2019re not instantiating the abstract class, which is impossible, but we\u2019re calling factory Set() which returns a concrete class. These lines are equivalent... final set1 = Set<int>(); final set2 = LinkedHashSet<int>(); ... because in Dart a Set is implemented by default as a LinkedHashSet. This class is a hash- based implementation of a Set and it keeps track of the order in which elements have been inserted. ..3 Map Also known as dictionary, a Map<K,V> is an unordered generic collection that stores key-value pairs. You can retrieve the object you\u2019re looking for by using the associated key. final m = <int, String>{ : \"A\", : \"B\", : \"C\" }; Map.unmodifiable() creates an unmodi\ufb01able copy of the map while UnmodifiableMapView() just takes a reference (no copies are made). There are two ways to insert new pairs in the map: \u2022 Use the putIfAbsent() method to insert a new pair of values only if the key is not already in the list. final example = <int, String>{ Flutter Complete Reference 147",
  ". Generics and Collections : \"A\", : \"B\" }; // The key '' is already present, \"C\" not added example.putIfAbsent(, () => \"C\"); // The key '' is not present, \"C\" successfully added example.putIfAbsent(, () => \"C\"); The \ufb01rst parameter is the desired key while the second one is a no-param function returning the value to be inserted. \u2022 Use brackets [] to add an element at the given index without checking if the key is already in the collection. final example = <int, String>{ : \"A\", : \"B\" }; // \"A\" has '' as key and it's replaced with \"C\". // Now the map contains {: \"C\", : \"B\"} example[] = \"C\"; // The key '' is not present, \"C\" gets added example[] = \"C\"; Maps doesn\u2019t allow duplicate keys. When we do example[] = \"C\" there are no errors because the element with key 0 is updated with the new value. Retrieving a value from a map is fairly simple: var v = example[];. If you pass a key that\u2019s not in the map, a null reference is returned. final example = <int, String>{ : \"A\", : \"B\" }; final ex1 = example[]; // ex1 = \"A\" final ex1 = example[]; // ex1 = null In general it\u2019d be better using bool containsKey(T key); before accessing the item as it tells Flutter Complete Reference 148",
  ". Generics and Collections whether the key is present or not in the map. The removal of an element simply happens with the remove method. ...1 Implementation You\u2019ve already seen how lists and sets work and maps are no di\ufb00erent; the core library de\ufb01nes an abstract class with a factory constructor that returns a concrete instance. It\u2019s the usual pattern adopted by the Dart API for collections. abstract class Map<K, V> { // code... external factory Map(); // code... } The Dart VM loads the body of the constructor from its internals thanks to the external keyword. If you could read the code, you\u2019d see that the constructor returns a concrete instance of a class called LinkedHashMap. There are three types of maps you can use. . LinkedHashMap<K, V>. It\u2019s the default class returned by the factory constructor of Map so when you use final map = <int, int>{} you get an instance of LinkedHashMap. It\u2019s based on a hash-table, the insertion order is remembered and you can iterate over key/values. . HashMap<K, V>. It\u2019s based on a hash table and null can be a valid key. The insertion order is not remembered so if you iterate over key/value pairs you won\u2019t get them in the order in which they have been added. . SplayTreeMap<K, V>. It\u2019s based on a self-balancing BST and keys are compared with the comparator function you\u2019re asked to pass in the constructor. If the comparison func- tion is not passed, the compiler assumes that keys implement the class Comparable<T> 4 interface. The \ufb01rst implementation, the default one, guarantees the insertion order, the second one doesn\u2019t care about the order and the last keeps the keys sorted. There is not the best implementation because you have to choose one of them according with what you have to do; in general the default is good. 4https://api.dart.dev/stable/../dart-core/Comparable-class.html Flutter Complete Reference 149",
  ". Generics and Collections .3 Good practices You\u2019ve seen that the language o\ufb00ers three important categories of containers and in general you should use them with their default implementations. A \"default\" map for example is generally final myMap = <int, int>{}; but if you need to keep the keys sorted, go for a SplayTreeMap. From the o\ufb03cial documentation : \u2022 Use the literal initialization syntax when you\u2019re good with the default implementation given by the language. Instead, for speci\ufb01c implementations, use regular constructors or factories. final example = List<int>(); // Bad final example = <int>[]; // Good \u2022 When you iterate on a container prefer doing for(item in list) {} instead of using the forEach() method which adds verbosity to the code. The loop is clearer. However, if you have a function that can be referenced such as print, you can use list.forEach(print);. \u2022 There\u2019s a function called cast() we\u2019ve never discussed because it\u2019s not good to use. Don\u2019t do casts with cast<T>() because it adds verbosity and it actually doesn\u2019t do a neat work. Ditch it. Each container o\ufb00ers a series of factories, such as unmodifiable() to return a collection with no add/remove operations (it\u2019s a read-only container). Refer to the docs 6 for a complete list of utilities methods. ..1 operator== and hashCode You already know from . \"The Object class\" how to properly override the equality operator AND the hashCode property. Sets and maps heavily use comparisons and the hash code of a given object so you really want to do a good override. \u009f Very shortly, imagine a hash table as a table with two columns: the key is on the left and the value is on the right. The key is needed to search values because, if present, you\u2019ll get access to the associated object: that\u2019s why maps are key/value pairs. 5https://dart.dev/guides/language/e\ufb00ective-dart/usage#collections 6https://api.dart.dev/stable/../dart-core/dart-core-library.html Flutter Complete Reference 150",
  ". Generics and Collections Common implementations of maps and sets are based on hash tables and the hash code determines how an item should be stored in the container. You should always override the equality operator and hashCode in your classes. \u2022 bool operator==(Object other). We\u2019ve already seen how to override it in .. \u2022 int get hashCode. There are multiple ways to correctly override this getter but what\u2019s important is that a di\ufb00erent integer is returned for every di\ufb00erent value. class Test { final int a; final int b; final String c; Test(this.a, this.b, this.c); bool operator==(Object other) {...} int get hashCode { const prime = ; var result = ; result = prime * result + a.hashCode; result = prime * result + b.hashCode; return prime * result + c.hashCode; } } In general, it\u2019s a good practice taking every instance variable of the class and perform a series of multiplications with prime numbers. In this way, every time you create an instance of the same object, such as Test(, , \"a\"); you\u2019ll always get the same hash code. Any other object, will return a di\ufb00erent value. If you had a class with a lot of member variables, there would be for sure a lot of boilerplate code. The Equatable 7 package by Felix Angelov overrides operator== and hashCode in your class automatically so that you won\u2019t have to deal with multiplications and comparisons. class Test extends Equatable { final int a; final int b; 7https://pub.dev/packages/equatable Flutter Complete Reference 151",
  ". Generics and Collections final String c; Test(this.a, this.b, this.c); @override List<Object> get props => [a, b, c]; } You just need to subclass Equatable and override the props getter passing it every final \ufb01eld of your class. The package does nothing special internally: it overrides operator== (with identical()) and hashCode (with a series of XORs similarly to what we did). It\u2019s much less code for you to write! class Test extends SomeClass with EquatableMixin { final int a; final int b; final String c; Test(this.a, this.b, this.c); @override List<Object> get props => [a, b, c]; } Extending Equatable might not always be possible because, for example, your class might al- ready have a superclass and Dart doesn\u2019t allow multiple inheritance. In this case, use a mixin which does the same work. \u009f If your class is NOT immutable, because not every instance \ufb01eld is final, do NOT override operator== and hashCode. Overriding hashCode with a mutable ob- ject could break hash-based collections. This is also written in the o\ufb03cial Dart design guidelines . If your class is mutable, do not de\ufb01ne a custom equality logic because it could break hash-based collections; for the same reasons, do not use Equatable if you class is not immutable. 8https://dart.dev/guides/language/e\ufb00ective-dart/design#avoid-de\ufb01ning-custom-equality-for-mutable-classes Flutter Complete Reference 152",
  ". Generics and Collections ..2 Transform methods Collections give you a very nice way to \ufb01lter data and act on them with a series of methods that can be chained. There are similarities in Java with streams and in C# with LINQ queries. void main() { // Generate a list of 20 items using a factory final list = List<int>.generate(, (i) => i); // Return a new list of even numbers final List<String> other = list .where((int value) => value %  == ) // . .map((int value) => value.toString()) // . .toList(); // . } In this example we\u2019re creating a list containing numbers from 0 to 19 using the generate factory constructor. The interesting part is how we\u2019ve built other so that it contains only strings representing even numbers. . The where() method iterates across the entire collection and returns a boolean expression. Here we analyze each element of the list, represented by int value, and we discard it in case it\u2019s not even. This method is a \"\ufb01lter\" that adds values only if the boolean expression returns true. . The map() method transforms a type into another. Since other must be a list of strings, we transform each \ufb01ltered element (represented by int value) into a String value. . Now that we have a \ufb01ltered list of transformed values, the terminal function returns an instance of a list. Manually doing this kind of operation is actually verbose because you should create a function with temporary variables, loops and conditional statements. This syntax instead is elegant and very easy to understand. \u009f While you traverse a collection with these methods, do NOT alter the content of the container itself! If you have a list of strings, don\u2019t change each item calling, for example, toUpper() while you\u2019re in a where condition. Flutter Complete Reference 153",
  ". Generics and Collections The example is shown with a list but these methods are also available for sets and maps. There are two kind of operations: \"intermediate\" operations to process data and \"terminal\" operations to return values. Intermediates are meant to elaborate data and can be chained while terminals are called at the end to \"group\" the data. \u2022 Intermediates. This is a category of functions that can be chained like you\u2019ve seen above to create complex expressions. Most of them accept a function whose parameter is the element of the collection being accessed. \u2013 where(): goes through the entire list and discards elements that evaluate the condition to false. \u2013 map(): transforms the element from a type to another. \u2013 skip(): skips the \ufb01rst n elements of the source collection. \u2013 followedBy(): concatenates this container with another one, passed as parameter. \u2022 Terminals. This is a category of function that can only be called at the end of the chain to return a value or an object. \u2013 toList()/toSet()/toMap(): gathers the elaborated data through the \"pipes\" and returns an instance of a list/set/map. \u2013 every(): returns a boolean indicating if every element of the collection satis\ufb01es the given condition. \u2013 contains(): returns true or false whether the collection contains or not the object you\u2019re looking for. \u2013 reduce(): reduces a collection to a single value which can be the result of operations in the elements of the container. You cannot use reduce() on empty collections. For example: final list = <int>[, , , , ]; final sum = list.reduce((int a, int b) => a + b); print(sum); // 15 The variable sum contains the sum of the elements in the list since reduce((a,b) => c) takes 2 elements of the source (a, b) and performs the given action on them (in this case, it sums the values). Flutter Complete Reference 154",
  ". Generics and Collections \u2013 fold(). It\u2019s very similar to reduce() but it asks for an initial value and the returned type doesn\u2019t have to be the same of the collection. final list = <int>[, , , , ]; final sum = list.fold(, (int a, int b) => a + b); print(sum); // 15 Both reduce() and fold() can do the same things but the latter is more powerful. First of all, fold() can de\ufb01ne a custom initial value for the operations: final list = <int>[, , , , ]; final sum1 = list.fold(, (int a, int b) => a + b); final sum2 = list.fold(, (int a, int b) => a + b); print(sum1); // 15 print(sum2); // 20 With fold() you can perform operations on di\ufb00erent data types while with reduce() you cannot. In this example, we\u2019re computing the sum of the lengths of strings in a collection. final list = ['hello', 'Dart', '!']; final value = list.fold(, (int count, String item) => count + item.length); print(value); // 10 count has the same type of the initial value (0 in this case, which is an int) and item represents an object in the collection. The returned value of the function must match the type of the initial value. You can\u2019t do the same in the other way: final list = ['hello', 'Dart', '!']; // It doesn't compile list.reduce((String a, String b) => a.length + b.length); print(value); This version doesn\u2019t work because reduce() expects the return type of the callback to be a String, the same type of the container. With fold() you don\u2019t have this constrain: it will always work. In reality, reduce() can be seen as a shortcut of the following: final withReduce = list.reduce(someCallback); Flutter Complete Reference 155",
  ". Generics and Collections final withFold = list.skip().fold(list.first, someCallback); The two versions are equivalent but withReduce is just shorter. We strongly encourage you to use this \ufb02uent syntax when you have to work on collections rather than using temporary variables and/or conditional statements. Flutter Complete Reference   | Asynchronous programming .1 Introduction Nowadays computers and mobile devices are very fast and users are well aware of this; they hate when the application \"freezes\" for a moment or if it doesn\u2019t always react immediately to inputs. There are however some situations in which the user must wait: \u2022 database operations; \u2022 usage of the internet connection, which might be slow and thus the entire process could take longer than expected; \u2022 many I/O operations might slow down your app\u2019s performances due to the policies adopted by the OS. In Flutter for example you often use an internet connection and, in the worst case, the user has to wait a few seconds. You must use asynchronous programming to show something like an animated progress bar while, at the same time, data are processed in the background. \u009f We\u2019ll talk about this in the Flutter part but the idea is that the app should never stop at a single long task. Asynchronous programming is made for executing time-consuming operations in the background so that, in the meanwhile, we can do something else. Let\u2019s say you\u2019re working in a team and a colleague of yours sends you this function which is going to be use very often in your application. int processData(int param1, double, param2) { var value = ; Flutter Complete Reference 157",
  ". Asynchronous programming for(var i = ; i < param1; ++i) { for (var j = ; j < param1*param2; j++) { // a lot of work here... } } return httpGetRequest(value); } Suppose that the two nested loops may take up to 2 seconds to complete and the network request at the end adds other hundreds of milliseconds. For sure this function is slow as it returns the int after quite a lot of time (in the order of seconds). void main() { final data = processData(, .); print(data); print(\"Welcome to... Dart!\"); } The main() function is going to be \"blocked\" for some seconds due to the long execution time of processData. The entire \ufb02ow is stuck due to a bottleneck produced by a function call and the app itself looks like it\u2019s frozen. .2 Futures A Future<T> represents a value or an error that will be available in the future. This generic class should be used whenever you\u2019re working with time-consuming functions returning a result after a notable amount of time. Here\u2019s what you can do to easily slim your execution \ufb02ow: Future<int> processData(int param1, double, param2) { var value = ; for(var i = ; i < param1; ++i) { for (var j = ; j < param1*param2; j++) { // a lot of work here... } } Flutter Complete Reference 158",
  ". Asynchronous programming final res = httpGetRequest(value); return Future<int>.value(res); } It\u2019s almost identical the original code: we\u2019ve just changed the type from int to Future<int> and the \ufb01nal statement, which uses a named constructor of Future to return a new instance. Of course you must be sure that the Future<T>.value() object is built with the proper type. \u009f The code didn\u2019t change so much but there\u2019s a huge di\ufb00erence in how the function is going to be called. In addition, every time you see Future<T> as return value, you immediately \ufb01gure out the usage and thus you write your code consequently. Since the function now returns a Future<T> we have to treat it di\ufb00erently: // Types are explicit for sake of simplicity void main() { Future<int> val = processData(, .); val.then((result) => print(result)); } The then() callback gets called once the execution has \ufb01nished, when the value is ready to be used. Thanks to a Future<T> you\u2019re able to execute the time-consuming task in the background and be noti\ufb01ed of the completion via then(). // Types are explicit for sake of simplicity void main() { Future<int> val = processData(, .); val.then((result) => print(result)) .catchError((e) => print(e.message)); } Methods can be chained; catching potential exceptions thrown during the background execution happens via catchError(), which is the equivalent of a try catch block. Of course you can create more complex chains such as: val.then((result) => anotherFunction1(result)) .then((another) => anotherFunction2(another)) .then((ending) => anotherFunction3(ending)) Flutter Complete Reference 159",
  ". Asynchronous programming .catchError((e) => print(e.message)); There are not limits, you can always append a then() or a catchError(). You might have noticed that this approach is quite verbose and it\u2019s not so easy to read when many methods are chained. \u009f That\u2019s the reason why async and await must be your primary choice; they dras- tically reduce the verbosity making the code look almost identical to its synchronous counterpart. In certain cases, you might want to wait for a series of Future<T>s to complete but you still don\u2019t want to block the execution. This is the perfect use case for Future.wait<T>(). Future<int> one = exampleOne(); Future<int> two = exampleTwo(); Future<int> three = exampleThree(); Future.wait<int>([ one, two, three ]).then(...).catchError(...); The wait() method takes a list of Future<T>s, executes them and waits until everyone has \ufb01nished. You can chain then() and/or catchError() because wait() returns a Future<T>. The API is very rich of useful named constructors you can use: \u2022 Future<T>.delayed() final future = Future<int>.delayed(const Duration(seconds: ), ()=> ); Creates a Future<T> object that starts running after the given delay (in this case, it executes after 1 second). \u2022 Future<T>.error() final future = Future<double>.error(\"Fail\"); Creates a Future<T> object that terminates with an error. Other than the message, you can also pass as second parameter the stack trace. Flutter Complete Reference 160",
  ". Asynchronous programming \u2022 Future<T>.value() final future = Future<String>.value(\"Flutter Complete Reference\"); Creates a Future<T> object that completes immediately returning the given value. Basi- cally, this constructor is used to \"wrap\" a non-future value into a future value. \u2022 Future<T>.sync() final future = Future<void>.sync(() => print(\"Called immediately\")); Creates a Future<T> object that immediately calls the given callback. Generally, when calling then() you don\u2019t know when its body will be executed. In this case, you know that the callback is called immediately. This constructor is intended to be used when a Future<T> has to execute immediately but in practice, there are a very few usages (we will see one in ..2 for example). ..1 Comparison In this section we\u2019re comparing a synchronous code snippet, which uses a \"simple\" int, and its asynchronous version, which uses a Future<int>, to emphasize the di\ufb00erent behaviors. . Non-future version (synchronous code). int processData(int param1, double, param2) { // takes 4 or 5 seconds to execute... } void main() { final data = processData(, .); print(\"func result = $data\"); print(\"Future is bright\"); } Nothing di\ufb03cult to understand up to here, you can easily predict what the console is going to output (10 is just there as example, it doesn\u2019t matter): func result = ; Future is bright Both print() statements are executed in sequence (as usual) but they appear after a few seconds. There is a visible delay which temporarily \"freezes\" the program because Flutter Complete Reference 161",
  ". Asynchronous programming processData() blocks the execution \ufb02ow while performing calculations. . Future version (asynchronous code). Future<int> processData(int param1, double param2) { // function that takes 4 or 5 seconds to execute... } void main() { final process = processData(, .); process.then((data) => print(\"result = $data\")); print(\"Future is bright\"); } The output is now di\ufb00erent: Future is bright result = ; // <-- printed after 4 or 5 seconds With the usage of a Future<T> object the execution \ufb02ow doesn\u2019t get blocked anymore. The then(...) callback returns immediately so that other operations can take place; its body will be executed later once data are actually ready. If you had written... final process = processData(, .); process.then((data) { print(\"result = $data\"); print(\"Future is bright\"); }); ... then the console would have printed ... result = ; Future is bright ... as in the \ufb01rst example. The body of then() executes synchronously in our example so operations are executed in sequence. Inside a then() callback you can execute asynchronous code as well but it\u2019s di\ufb03cult to read, due to the verbosity of the code, and hard to understand, in case there were too much asynchrony in the \ufb02ow. Flutter Complete Reference 162",
  ". Asynchronous programming \u009f To put it very simply, when you use then() you\u2019re telling Dart: \"Continue doing your work, I don\u2019t want to wait for the operation to \ufb01nish. When the result will be ready, notify me with the callback\". If you have to deal with time-consuming operations, using a Future<T> is basically a must because blocking the execution \ufb02ow is dangerous and wrong. Thanks to asynchronous code you keep your app always busy and responsive, which is a fundamental user experience factor. ..2 async and await The usage of async and await makes the code less verbose and consequently easier to understand. It\u2019s just syntactic sugar to avoid the usage of then() to write callbacks: \u2022 Using then. void main() { final process = processData(, .); process.then((data) => print(\"result = $data\")); } \u2022 Using async and await. void main() async { final data = await processData(, .); print(\"result = $data\") } The above snippets are equivalent because the result is the same but the syntax is di\ufb00erent. Let\u2019s start with three very important facts: . You can use await only in a function marked with async. . To de\ufb01ne an asynchronous functions, put the async keyword before the body. . You\u2019re allowed to call await only on a Future<T>. Our main() has the async modi\ufb01er so that we\u2019re allowed to call await. Calling await on a Future moves the execution to the background and proceeds once the computation is done (which is exactly what then() does). To be clear, writing... processData(, .).then((data) => print(\"result = $data\")); Flutter Complete Reference 163",
  ". Asynchronous programming ... is the same as ... final data = await processData(, .); print(\"result = $data\"); ... because the lines after the await keyword are executed only when the Future<T> completed (without blocking). In regard to the previous example, this code... void main() async { final data = await processData(, .); print(\"result = $data\"); print(\"Future is bright\"); } ... is equivalent to ... void main() { final process = processData(, .); process.then((data) { print(\"result = $data\"); print(\"Future is bright\"); }); } ... but absolutely NOT equivalent to ... void main() { final process = processData(, .); process.then((data) { print(\"result = $data\"); }); print(\"Future is bright\"); } because everything after await is executed only when the Future is completed. You\u2019re guaran- teed that functions are asynchronously executed and you won\u2019t block the normal execution \ufb02ow. Exceptions are also easier to catch because... void main() { processData(, .) .then((result) => print(result)) .catchError((e) => print(e.message)); Flutter Complete Reference 164",
  ". Asynchronous programming } ... gets simpli\ufb01ed with the usage of async and await: void main() async { try { final result = await processData(, .); print(result); } on Exception catch (e) { print(e.message); } } The second version is closer to what you\u2019re used to see in the traditional synchronous world. Furthermore there are no nested methods/callbacks and thus the code is way shorter and more readable. ..3 Good practices The \ufb01rst thing stated by the o\ufb03cial 1 usage guidelines is \"prefer async/await over using raw futures\". Since asynchronous code can be hard to read and debug, you should prefer async and await over a chain of then() and catchError(). Future<String> example() async { try { final String data = await httpGetRequest(); final String other = await anotherRequest(data); return other; } on Something catch (e) { print(e.message); return \"fail\"; } } If it weren\u2019t for await it would look like \"normal\" synchronous code with no callbacks at all. It\u2019s neater and more readable if compared to the following: Future<String> example() { return httpGetRequest().then((data) { 1https://dart.dev/guides/language/e\ufb00ective-dart/usage#asynchrony Flutter Complete Reference 165",
  ". Asynchronous programming anotherRequest(data).then((otherData) { return otherData; }); }).catchError((e) { print(e.message); return \"\"; }); } It\u2019s not a matter of e\ufb03ciency or performances because both examples are \ufb01ne. The problem is about writing code with potentially many nested callbacks and functions that become impossible to read (the so called \"callback hell\"). \u009f Again, thanks to await asynchronous code can be written in the same way as synchronous code. Other than leading to less boilerplate, it\u2019s also easier to read, maintain and understand! Returning a Future<T> from a function can be done via named constructor Future.value() or, more easily, by making the function async and returning the plain value. The compiler will make an automatic conversion. // Use the named constructor Future<int> example() => Future<int>.value(); // Use async and the compiler wraps the value in a Future Future<int> example() async => ; Both ways are valid but maybe you should prefer the second approach as it\u2019s a bit less ver- bose. .3 Streams In Dart a stream is a sequence of asynchronous or synchronous events we can listen to. There\u2019s no need to check for updates because the stream noti\ufb01es us automatically when there\u2019s a new event available. Flutter Complete Reference 166",
  ". Asynchronous programming This picture helps you to visualize how streams are intended to be used and who are the main actors involved. A generator is a source of information that lazily generates new data with a certain frequency; the stream is the pipe in which generated data \ufb02ow. \u2022 Generator. Creates new data and sends them over the stream. \u2022 Stream. It\u2019s the place in which the generated data \ufb02ow. You can start listening to a stream so that, when the generator emits new data, you will be noti\ufb01ed. \u2022 Subscribers. A subscriber is someone interested in the data travelling in the stream. If new data are sent over the stream by the generator, everyone listening (subscribers) will be noti\ufb01ed. A generator has to emit data only into a stream and nowhere else because a stream is the only reference for listeners to subscribe. There are two types of generators: . Asynchronous generators: they return a Stream<T> object. Because of this, you have to deal with an asynchronous \ufb02ow of data that has to be handled by a subscriber with await. . Synchronous generators: they return an Iterable<T> object. Because of this, you have to deal with a synchronous \ufb02ow of data that can be handled in a loop because data are sent in a sequential order. A Flutter developer is used to work with Stream<T> because the framework has many asyn- Flutter Complete Reference 167",
  ". Asynchronous programming chronous generators. In practice, unless you\u2019re creating a package or a speci\ufb01c tool, you won\u2019t create generators too often but still you should at least be aware of how they generally work. Futures and streams are at the basics of Dart\u2019s asynchronous model. ..1 Streams and generators As a basic example, we\u2019re going to create an asynchronous generator producing 100 random numbers, one per second. In order to tell the compiler that this function is a generator, it has to be marked with the async* modi\ufb01er. Stream<int> randomNumbers() async* { // . final random = Random(); for(var i = ; i < ; ++i) { // . await Future.delayed(Duration(seconds: )); // . yield random.nextInt() + ; // . } } // . . Since the function is a generator of asynchronous events (random numbers), the return type must be of type Stream<T>. The async* modi\ufb01er allows the usage of yield to emit data. . The loop generates 100 random numbers. . The Future.delayed(...) named constructor creates a Future that returns after a certain delay given by the Duration2 object. It\u2019s used to \"sleep\" the execution \ufb02ow for a certain time without blocking. . The yield keyword pushes data on the stream. It is responsible of sending new events on the stream and it doesn\u2019t alter the loop (it continues to cycle regularly). . When a function has the async* modi\ufb01er there cannot be a return statement. It would also be logically wrong because data are already sent over the stream by yield and thus you\u2019d have nothing to return when the generator \"turns o\ufb00\". So generators are created with the async* modi\ufb01er and events are emitted on the stream with the yield keyword. To make a comparison, here\u2019s the synchronous version of the generator which has a similar structure. // contains the 'sleep' function import 'dart:io'; 2See appendix A.3 to know more about Duration Flutter Complete Reference 168",
  ". Asynchronous programming Iterable<int> randomNumbers() sync* { final random = Random(); for(var i = ; i < ; ++i) { sleep(Duration(seconds:)); yield random.nextInt() + ; } } The sync* star modi\ufb01er tells the compiler that this function is a synchronous generator. Due to its nature of being synchronous you cannot use futures and thus we must use sleep() instead of awaiting Future.delayed(). \u009f Asynchronous generators are meant to be used with asynchronous code. Syn- chronous generators are meant to be used with synchronous code. Intuitively, if your code needs to await something, you\u2019re going to need an asynchronous generator. Both kind of generators start emitting data on demand, meaning that values are produced when a listener starts iterating on Iterator<T> or starts listening to Stream<T>. There can be more than a single yield statement in the same block and it would simply push many values, in sequence, on the stream: Stream<int> randomNumbers() async* { final random = Random(); for(var i = ; i < ; ++i) { await Future.delayed(Duration(seconds: )); yield random.nextInt() + ; yield random.nextInt() + ; yield random.nextInt() + ; } } This code emits 3 random number at each iteration so the stream is going to generate 300 values before completing. Streams can also be created using a series of useful named constructors for a \"quick setup\": Flutter Complete Reference 169",
  ". Asynchronous programming \u2022 Stream<T>.periodic() final random = Random(); final stream = Stream<int>.periodic( const Duration(seconds: ), (count) => random.nextInt() ); Creates a new a stream that repeatedly emits events at the given Duration interval. The argument of the anonymous function starts at 0 and then increments by 1 for each event emitted (it\u2019s an \"event counter\"). \u2022 Stream<T>.value() final stream = Stream<String>.value(\"Hello\"); Creates a new stream that emits a single event before completing. \u2022 Stream<T>.error() Future<void> something(Stream<int> source) async { try { await for (final event in source) { ... } } on SomeException catch (e) { print(\"An error occurred: $e\"); } } // Pass the error object something(Stream<int>.error(\"Whoops\")); Creates a new stream that emits a single error event before completing; the behavior is very similar to Stream<T>.value(). \u2022 Stream<T>.fromIterable() final stream = Stream<double>.fromIterable(const <double>[ ., ., ., ., ., ., ., ., ., . ]); Creates a new single-subscription stream that only emits the values in the list. \u2022 Stream<T>.fromFuture() Flutter Complete Reference 170",
  ". Asynchronous programming final stream = Stream<double>.fromFuture( Future<double>.value(.) ); Creates a new single-subscription stream from the given Future<T> object. In particular, when the Future<T> completes, 2 events are emitted: one with the data (or the error) and another to signal the stream has terminated (the \"done\" event). \u2022 Stream<T>.empty() final stream = Stream<double>.empty(); This kind of stream does nothing: it just immediately sends a \"done\" event in order to signal the termination. You should really check out the Stream<T> online documentation for a complete refernece of all the methods you can call on it. The most \"popular\" ones for example are: \u2022 drain(...): it discards all the events emitted by the stream but signals when it\u2019s either done or an error occurred; \u2022 map(...): transforms the events of the current stream into events of another type; \u2022 skip(int count): skips the \ufb01rst count event on the stream; ..2 Subscribers The generator is now ready to periodically emit new random numbers and thus we can subscribe to get noti\ufb01ed for new values. Stream<int> randomNumbers() async* { // see code above... } void main() async { // . final stream = randomNumbers(); // . await for (var value in stream) { // . print(value); } print(\"Async stream!\"); // . Flutter Complete Reference 171",
  ". Asynchronous programming } . Since we\u2019re dealing with an asynchronous stream, there\u2019s the need to mark the function with async because we\u2019re going await soon. . We subscribe to the stream by simply getting a reference to it. This is the moment in which the generator starts emitting data because someone has just started listening (on-demand initialization). . When dealing with streams, the await for loop is able to \"catch\" values sent over the stream by a yield in the generator. It works exactly like a regular for loop. . The string is printed when the loop terminates so it will appear at the end. To be precise, the example is almost good because generators are generally put inside classes and exposed with a getter, which returns a Stream<T> instance, or with a listen() method which does a manual subscription. Let\u2019s give a look at the synchronous version of the generator: Iterable<int> randomNumbers() sync* { // see code above... } void main() { final stream = randomNumbers(); for(var value in stream) { print(value); } print(\"Sync stream!\"); } Apart from a plain for instead of an await for the code is identical. The List<T> and Set<T> classes are both Iterable<T>, exactly like most types in the collection library. Exceptions are caught in the usual way: void main() { final stream = randomNumbers(); try { await for(var value in stream) { print(value); Flutter Complete Reference 172",
  ". Asynchronous programming } } on Something catch (e) { print(\"Whoops :(\"); } } Other than data events a stream can also send error events, which may occur because an exception has been thrown in the generator. Here\u2019s another example of a stream continuously sending data at a given interval: Stream<int> counterStream([int maxCount = ]) async* { final delay = const Duration(seconds: ); var count = ; while (true) { if (count == maxCount) { break; } await Future.delayed(delay); yield ++count; } } void main() async { await for(var c in counterStream) { print(c); } } Each second a new number is printed to the console until maxCount is reached; if you wanted the loop to last forever, just remove the if condition. For an even more detailed coverage about streams, check out the o\ufb03cial Flutter YouTube channel along with the documentation which is full of details and examples: . Stream usage: https://dart.dev/tutorials/language/streams . Generators: https://dart.dev/articles/libraries/creating-streams . Stream docs: https://api.dart.dev/stable/../dart-async/Stream-class.html In Flutter the StreamBuilder<T> object is used to subscribe to a stream and we\u2019re going to use Flutter Complete Reference 173",
  ". Asynchronous programming it quite often, especially in Part III of the book. ..3 Di\ufb00erences Key di\ufb00erences for asynchronous and synchronous streams are summarized in this short table: Asynchronous Synchronous Returns a Stream<T> Returns an Iterable<T> Mark function with async* Mark function with sync* Can use await Cannot use await Subscribers have to use await for Subscribers have to use for In both cases yield is used to send data on the stream and there must not be a return statement in the function. You might be wondering: \"If I wanted to write a generator, should I make it synchronous or asynchronous?\" \u009f As we\u2019ve already said, you rarely need to write a generator if you work with Flut- ter, unless you\u2019re doing something speci\ufb01c. In most of the cases you will subscribe to streams so you won\u2019t have to decide anything because the generator is exposed by the library. A reasonable answer to the question would be \"it depends\" because there are cases and cases. As a general guideline we can say that a good decisional aspect is whether you have to use Future<T> or not. \u2022 If you have to deal with Future<T>s because of network usages or I/O operations for example, you are forced to use an asynchronous generator otherwise you can\u2019t use await. \u2022 When you don\u2019t have to deal with asynchrony and you have the need of sending a series of sequential data, go for a synchronous stream. Sometimes, especially when using the \ufb02utter_bloc library we will cover in chapter , it can be Flutter Complete Reference 174",
  ". Asynchronous programming useful splitting the logic of a Stream<T> into multiple pieces. This is the case where yield* is required: Stream<int> numberGenerator(bool even) async* { if (even) { yield ; yield* evenNumbersUpToTen(); yield ; } else { yield -; yield* oddNumbersUpToTen(); yield -; } } Stream<int> evenNumbersUpToTen() async* { ... } Stream<int> oddNumbersUpToTen() async* { ... } Basically yield* is used to \"pause\" the execution and start emitting values from the other stream; once \ufb01nished, the source stream is \"restarted\" so that it can regularly send its values again. To be more clear, here\u2019s an example of what happens when numberGenerator(true) is called: \u2022 The value 0 is emitted with yield, the \"normal\" way of sending data on the stream. \u2022 Because of yield*, numberGenerator pauses and starts emitting values generated from the other stream (evenNumbersUpToTen). \u2022 Once evenNumbersUpToTen has completed, numberGenerator resumes and executes the next yield statement. In practice yield* is used to say \"stop here, emit values from the other stream and when it\u2019s completed you\u2019re free to restart your regular \ufb02ow\". This pattern is used when a stream should internally use another stream to split the logic in multiple functions to make the code more readable. ..4 Using a controller The examples we\u2019ve shown so far aren\u2019t very useful actually. In particular, the creation of an \"in place\" stream hasn\u2019t much use cases a part from examples and demos. You\u2019re already familiar with this simple setup: Flutter Complete Reference 175",
  ". Asynchronous programming Stream<String> someStream() async* { ... } void main() async { final stream = someStream(); } The stream is started as soon as we do the stream = someStream(); assignment. This is the manual way of creating streams but it doesn\u2019t scale well on larger applications. Especially in Flut- ter, you\u2019ll \ufb01nd out that StreamController<T> is a more convenient way to work with streams. We\u2019re going to create a more complex stream that periodically produces random numbers. /// Exposes a stream that continuously generates random numbers class RandomStream { /// The maximum random number to be generated final int maxValue; static final _random = Random(); Timer? _timer; late int _currentCount; late StreamController<int> _controller; /// Handles a stream that continuously generates random numbers. Use /// [maxValue] to set the maximum random value to be generated. RandomStream({this.maxValue = }) { _currentCount = ; _controller = StreamController<int>( onListen: _startStream, onResume: _startStream, onPause: _stopTimer, onCancel: _stopTimer ); } /// A reference to the random number stream Stream<int> get stream => _controller.stream; // other methods coming soon... } Flutter Complete Reference 176",
  ". Asynchronous programming Notice how we\u2019ve used triple slashes (/// ) to document the code . The Timer class comes from the dart:async package: it\u2019s a count-down timer that can be con\ufb01gured to \ufb01re once or repeatedly. It counts down from the given duration up to 0 and then triggers the callback. It has two constructors: \u2022 Timer(Duration duration, void callback()) Executes once the callback after the given duration. \u2022 Timer.periodic(Duration duration, void callback(Timer timer)) The callback is invoked repeatedly with duration intervals. A timer can be stopped with cancel(). We\u2019re using it to push each second new random numbers in the stream, handled by StreamController<T>. This class is basically a wrapper around a stream with many facilities to easily send data, errors and done events. \u2022 onListen: this callback is called when the stream is listened to (new subscription made). \u2022 onCancel: this callback is called when the stream is canceled (subscription canceled). \u2022 onPause: this callback is called when the stream is paused (subscription paused). \u2022 onResume: this callback is called when the stream is resumed (subscription resumed). A StreamController<T> is a very handy tool to easily manage a Stream<T>. Thanks to get stream we expose to the outside a reference to the stream so that listeners can subscribe and receive events. This is how we\u2019ve de\ufb01ned the callbacks of the controller: void _startStream() { _timer = Timer.periodic(const Duration(seconds: ), _runStream); _currentCount = ; } void _stopTimer() { _timer?.cancel(); _controller.close(); } void _runStream(Timer timer) { _currentCount++; _controller.add(_random.nextInt(maxValue)); 3More on documenting code in ..2 Flutter Complete Reference 177",
  ". Asynchronous programming if (_currentCount == maxValue) { _stopTimer(); } } We have declared Timer? _timer as a nullable variable because we cannot immediately initialize the timer in the constructor. Doing so would be an error because events would start being emitted on the stream from the beginning, even if there are no listeners! RandomStream({this.maxValue = }) { _currentCount = ; _controller = StreamController<int>(...); // WRONG! In this way, the timer is started and thus events are // emitted on the stream immediately (even if no one is listening) _timer = Timer.periodic(...); } We safely use the ?. operator to access the nullable variable. Inside _startStream() we actually initialize the timer so that it pushes new random values every 1 second. The actual processing is done inside _runStream(): // New value added to the stream. Listeners will be notified _controller.add(_random.nextInt(maxValue)); // When the maximum value is reached, we need to stop both the // timer AND close the controller to stop the stream. if (_currentCount == maxValue) { _stopTimer(); } We can now play with our RandomStream class. In this example, we\u2019re subscribing to the stream using listen() and then we cancel the subscription after a certain delay. You\u2019ll see that random numbers are printed to the console only 3 times in total. void main() async { final stream = RandomStream().stream; await Future.delayed(const Duration(seconds: )); // The timer inside our 'RandomStream' is started final subscription = stream.listen((int random) { Flutter Complete Reference 178",
  ". Asynchronous programming print(random); }); await Future.delayed(const Duration(milliseconds: )); subscription.cancel(); } After 2 seconds, we subscribe to the stream using listen() but numbers are printed only three times because, 3 seconds later, we cancel the subscription. As you can see, StreamController<T> is more complex to use but more powerful and scalable: it\u2019s the preferred way to work with streams in Dart and Flutter. .4 Isolates Many popular programming languages such as Java and C# have a very wide API to work with multiple threads and parallel computation. They can handle complex multithreading scenes thanks to the various primitives they support. Dart however has none of the following: \u2022 there is no way to start multiple threads for heavy background computation; \u2022 there is no equivalent, for example, of thread-safe types such as AtomicInteger; \u2022 there are no mutexes, semaphores or other classes to prevent data races and all those problems arisen from multithreaded programming. The Dart code (and thus Flutter applications) is run inside an isolate which has its own private area of memory and an event loop. An isolate can be seen as a special thread in which an event loop processes the instructions. If you aren\u2019t familiar with these concepts, we will break down for you what is going on: Flutter Complete Reference 179",
  ". Asynchronous programming Any program runs in a process which can be made up of one or more threads. Some program- ming languages (picture on the left) allow you to manually create multiple threads to execute long running tasks in the \"background\" not to block the UI. \u009f All the threads living on a process share the same memory. You need to be aware of this because writing the same data, at the same time, in the same memory area can lead to problematic situations known as data races. In Dart, a process is made up of one or more isolates containing an event loop. Di\ufb00erently from classic threads, each isolate allocates its own memory area so there are no data sharing issues. In other words, the key di\ufb00erence is that threads do share the same memory while isolates don\u2019t. Thanks to this fact, Dart needs no data synchronization primitives since problems like data races can never happen by default. If we made a zoom on an isolate, it would look like this: Flutter Complete Reference 180",
  ". Asynchronous programming The white event rectangles can be anything from I/O disk operations, HTTP requests, actions triggered by a \ufb01nger tap in the Flutter framework and so on. The gear on the right is the event loop, a sort of machinery that continuously executes events. You might be asking yourself: if there\u2019s only a single thread, how is asynchronous code executed? Let\u2019s take a look at those 2 simple examples: . Let\u2019s say that somewhere in our Dart program (or Flutter app) there are two methods which get called in sequence. They are synchronous, because inside they use no asynchronous code (no Stream<T>s or Future<T>s). // this is called first var json = myModel.readFromDisk(); // and this is called after the above final result = computeIntegerValue(); The event loop processes incoming events in order one by one so \ufb01rst it executes the I/O operation and then the computation. Here\u2019s a visual representation of the situation: Flutter Complete Reference 181",
  ". Asynchronous programming The second event is processed only when the \ufb01rst is \ufb01nished. If there were no events available, the event loop would be in \"idle\" waiting for new work to do. The event loop is the \"engine\" that actually executes the Dart code you\u2019ve written. . Let\u2019s now see another example in which a Future<T> is involved in order to understand how asynchronous code is processed. The same strategy is also applied when it comes to streams. void printName() async { final int id = generateId(); final String name = await HttpModel.getRequest(id); print(name); } As you already know, what comes after await is executed only when the Future<T> has terminated. In this case, the value will be printed only when the HTTP request is \ufb01nished. Pretend to have this code: printName(); final time = getTime(); The \ufb01rst event to be executed is printName() but since it internally calls await, what comes after (the print(name) statement) is separated and added later as a new event in the queue! This is the actual sequence that will be processed: Flutter Complete Reference 182",
  ". Asynchronous programming In practice, asynchronous calls are divided in multiple events: the synchronous part and the callbacks. What comes after an await is not executed immediately because there\u2019s the need to wait for the Future<T> to \ufb01nish. In order to not waste time, the callback is divided from the event, \"remembered\" and added in the queue again later (when the Future<T> \ufb01nished). // This part is executed immediately; it's the rightmost rectangle on // the image final int id = generateId(); final String name = await HttpModel.getRequest(id); // This callback is executed later; it's the leftmost rectangle on the // image. This part \"separated\" and added later in the event loop again // to complete the execution print(name); Splitting function calls is fundamental because it avoids events on the queue to wait for futures to \ufb01nish. If printName() were executed entirely, the event loop would have been blocked until the Future<T> completed and other events would have to wait. The event loop should always be busy but it shouldn\u2019t execute long-lived events otherwise others will be blocked. In addition, other than events \ufb01red by your app there are also other kind of actions to be performed such as garbage collection. To sum it up, here\u2019s a comparison with other programming languages: \u2022 Java or C#. You can create multiple threads to run time-consuming work in the back- ground. Threads share memory, which can be dangerous, but you have a rich API with mutexes, atomic types and so on to keep consistency in your program. \u2022 Dart. There\u2019s only a single thread with its own memory. You cannot create multiple threads. The event loop processes anything sequentially as soon as possible. In order to Flutter Complete Reference 183",
  ". Asynchronous programming not waste time, asynchronous calls are split so that callbacks are executed in a second moment in order to not block the loop. ..1 Multiple isolates and Flutter A single Dart application can have more than a single isolate; you can create them by using Isolate.spawn() from the \"dart:isolate\" library. Isolates have their own event loop and memory area, there are no dependencies or shared components at all. The only way they have to communicate is via messages. Each isolate has a port from which messages enter and exit; they are respectively represented by ReceivePort and SendPort. A message is regularly processed by the event loop as any other action but this really is the only way to communicate. \u009f There\u2019s the possibility to also spawn new isolates in Flutter but you\u2019d have to use Future<T> compute(...) rather than Isolate.spawn. Working with isolates is quite low level and it\u2019s something you generally don\u2019t do on a regular basis. Using async/await is almost always enough. To make a practical example, if you had a Flutter app with a really time-expensive data computing your frame rate might drop under Flutter Complete Reference 184",
  ". Asynchronous programming 60fps. This is the case for a new isolate: // Very computational-heavy task int sumOfPrimes(int limit) {...} // Function to be called in Flutter Future<int> heavyCalculations() { return compute<int, int>(sumOfPrimes, ); } The compute() method requires the function to be executed (which cannot be an anonymous function) and the parameters it needs (if any). If you had the need for multiple input parameters, simply wrap them into a model class and pass it as a dependency, like this: // Model class class PrimeParams { final int limit; final double another; const PrimeParams(this.limit, this.another); } // Use the model as parameter int sumOfPrimes(PrimeParams data) { final limit = data.limit; final another = data.another; ... } // Function to be called in Flutter Future<int> heavyCalculations() { final params = PrimeParams(, .); return compute<PrimeParams, int>(sumOfPrimes, params); } In compute<Q,R> the parameters are de\ufb01ned as follows: Q is the type of the parameter needed by the function and R is the return type. In chapter 16 we will discuss when it\u2019s convenient using separated isolates in Flutter applications to optimize performances. Flutter Complete Reference   | Coding principles with Dart This chapter is a big \"good practice\" section as it contains some well-known suggestions from the OOP world. We\u2019d love to also talk about design patterns, TDD, clean code and much more but these contents go beyond the scope of this book. Many people have written books and articles on these topics, we recommend you read up on these for more in-depth details. \u2022 Design patterns are a series reusable solutions to common, well-known problems. The original concept came by a group of four people, called Gang of four, but nowadays new patterns come out in parallel with the evolution of languages. \u2013 Look for any recent book or resource that includes the widest range of patterns. They apply to any programming language; the programming language in which they\u2019re explained is not so relevant. \u2022 TDD, abbreviation of Test Driven Development, is a programming style strongly centered on code testing. You have to \ufb01rst write the tests, cover every possible case and only after this process you can start coding. \u2013 https://resocoder.com/\ufb02utter-clean-architecture-tdd \u2022 DDD, abbreviation of Domain Driven Design, is a programming style which focuses on code maintainability and separation of concerns. We recommend to follow Reso Coder\u2019s DDD course which gives a step-by-step explanation about DDD using Dart and Flutter. \u2013 https://resocoder.com/\ufb02utter-\ufb01rebase-ddd-course \u2022 Dart has a very wide, user-friendly documentation in which you can \ufb01nd examples for almost any topic. It\u2019s a wide growing resource that tells you how to properly write Dart code through good practices and articles. \u2013 https://dart.dev/guides/language/e\ufb00ective-dart \u2013 https://dart.dev/tutorials Flutter Complete Reference 186",
  ". Coding principles with Dart That said, you can of course completely skip this part since it has no core Dart or Flutter concepts but we encourage you to at least know what SOLID and DI are about. These concepts are valid regardless the programming language in which they\u2019re applied. .1 SOLID principles The term SOLID should actually be written as S.O.L.I.D. because it\u2019s an acronym for 5 design principles, one for each letter, which help the programmer writing maintainable and \ufb02exible code. ..1 Single Responsibility Principle Very intuitively, this principle (abbreviated with SRP) states that a class should only have a single responsibility so that it could change for one reason and no more. In other words, you should create classes dealing with a single duty so that they\u2019re easier to maintain and harder to break. class Shapes { List<String> cache = List<>(); // Calculations double squareArea(double l) { /* ... */ } double circleArea(double r) { /* ... */ } double triangleArea(double b, double h) { /* ... */ } // Paint to the screen void paintSquare(Canvas c) { /* ... */ } void paintCircle(Canvas c) { /* ... */ } void paintTriangle(Canvas c) { /* ... */ } // GET requests String wikiArticle(String figure) { /* ... */ } void _cacheElements(String text) { /* ... */ } } This class totally destroys the SRP as it handles internet requests, painting and calculations all in one place. You\u2019ll have to make changes very often to Shape because it has many duties, all in one place; maintenance for this class is not going to be pleasant. What about this? Flutter Complete Reference 187",
  ". Coding principles with Dart // Calculations and logic abstract class Shape { double area(); } class Square extends Shape {} class Circle extends Shape {} class Rectangle extends Shape {} // UI painting class ShapePainter {} // Networking class ShapesOnline {} There are 3 separated classes focusing on a single task to accomplish: they are easier to read, test, maintain and understand. With this approach the attention of the developer is focused on a certain area of interest (such as mathematical calculations on Shape) rather than on a messy collection of methods, each with di\ufb00erent purposes. ..2 Open closed principle The open closed principle states that in a good architecture you should be able to add new behaviors without modifying the existing source code. This concept is notoriously described with the sentence \"software entities should be open for extensions but closed for modi\ufb01cations\". Look at this example: class Rectangle { final double width; final double height; Rectangle(this.width, this.height); } class Circle { final double radius; Rectangle(this.radius); double get PI => .; } Flutter Complete Reference 188",
  ". Coding principles with Dart class AreaCalculator { double calculate(Object shape) { if (shape is Rectangle) { // Smart cast return r.width * r.height; } else { final c = shape as Circle; return c.radius * c.radius * c.PI; } } } Both Rectangle and Circle respect the SRP as they only have a single responsibility (which is representing a single geometrical shape). The problem is inside AreaCalculator because if we added other shapes, we would have to edit the code to add more if conditions. class Rectangle {...} class Circle {...} class Triangle {...} class Rhombus {...} class Trapezoid {...} class AreaCalculator { double calculate(Object shape) { if (shape is Rectangle) { // code for Rectangle... } else if (shape is Circle) { // code for Circle... } else if (shape is Triangle) { // code for Triangle... } else if (shape is Rhombus) { // code for Rhombus... } else { //code for Trapezoid... } } } Having added 3 new classes, the double calculate(...) must be changed because it requires Flutter Complete Reference 189",
  ". Coding principles with Dart more if conditions to handle proper type casts. In general, every time that a new shape is added or removed, this method has to be maintained due to the presence of type casts. We can do better! // Use it as an interface abstract class Area { double computeArea(); } // Every class calculates the area by itself class Rectangle implements Area {} class Circle implements Area {} class Triangle implements Area {} class Rhombus implements Area {} class Trapezoid implements Area {} class AreaCalculator { double calculate(Area shape) { return shape.computeArea(); } } Thanks to the interface, now we have the possibility to add or remove as many classes as we want without changing AreaCalculator. For example, if we added class Square implements Area it would automatically be \"compatible\" with the double calculate(...) method. \u009f The gist of this principle is: depend on abstractions and not on implementations. Thanks to abstract classes you work with abstractions and not with the concrete implementations: your code doesn\u2019t rely on \"prede\ufb01ned\" entities. ..3 Liskov Substitution Principle The Liskov Substitution Principle states that subclasses should be replaceable with superclasses without altering the logical correctness of the program. In practical terms, it means that a subtype must guarantee the \"usage conditions\" of its supertype plus something more it wants to add. Look at this example: Flutter Complete Reference 190",
  ". Coding principles with Dart class Rectangle { double width; double height; Rectangle(this.width, this.height); } class Square extends Rectangle { Square(double length): super(length, length); } We have a big logic problem here. A square must have 4 sides with the same length but the rectangle doesn\u2019t have this restriction. We\u2019re able to do this: void main() { Rectangle fail = Square(); fail.width = ; fail.height = ; } At this point we have a square with 2 sides of length 4 and 2 sides of length ... which is ab- solutely wrong! Sides on a square must be all equal but our hierarchy is logically \ufb02awed. The LSP is broken because this architecture does NOT guarantee that the subclass will maintain the logic correctness of the code. \u009f This example also shows that inheriting from abstract classes or interfaces, rather than concrete classes, is a very good practice. Prefer composition (with interfaces) over inheritance. To solve this problem, simply make Rectangle and Square two independent classes. Breaking LSP does not occur if you depend from interfaces: they don\u2019t provide any logic implementation as it\u2019s deferred to the actual classes. ..4 Interface Segregation Principle This principle states that a client doesn\u2019t have to be forced to implement a behavior it doesn\u2019t need. What turns out from this is: you should create small interfaces with minimal methods. Generally it\u2019s better having 8 interfaces with 1 method instead of 1 interface with 8 methods. Flutter Complete Reference 191",
  ". Coding principles with Dart // Interfaces abstract class Worker { void work(); void sleep(); } class Human implements Worker { void work() => print(\"I do a lot of work\"); void sleep() => print(\"I need 10 hours per night...\"); } class Robot implements Worker { void work() => print(\"I always work\"); void sleep() {} // ?? } Robots don\u2019t need to sleep and thus the method is actually useless, but it still needs to be there otherwise the code won\u2019t compile. To solve this, let\u2019s just split Worker into multiple interfaces: // Interfaces abstract class Worker { void work(); } abstract class Sleeper { void sleep(); } class Human implements Worker, Sleeper { void work() => print(\"I do a lot of work\"); void sleep() => print(\"I need 10 hours per night...\"); } class Robot implements Worker { void work() => print(\"I always work\"); } This is de\ufb01nitely better because there are no useless methods and we\u2019re free to decide which behaviors should the classes implement. Flutter Complete Reference 192",
  ". Coding principles with Dart ..5 Dependency Inversion Principle This is very important and useful: DIP states that we should code against abstractions and not implementations. Extending an abstract class or implement an interface is good but descending from a concrete classed with no abstract methods is bad. // Use this as interface abstract class EncryptionAlgorithm { String encrypt(); // <-- abstraction } class AlgoAES implements EncryptionAlgorithm {} class AlgoRSA implements EncryptionAlgorithm {} class AlgoSHA implements EncryptionAlgorithm {} Dependency injection (DI) is a very famous way to implement the DIP. Depending on abstractions gives the freedom to be independent from the implementation and we\u2019ve already dealt with this topic. Look at this example: class FileManager { void secureFile(EncryptionAlgorithm algo) { algo.encrypt(); } } The FileManager class knows nothing about how algo works, it\u2019s just aware that the encrypt() method secures a \ufb01le. This is essential for maintenance because we can call the method as we want: final fm = FileManager(...); fm.secureFile(AlgoAES()); fm.secureFile(AlgoRSA()); If we added another encryption algorithm, it would be automatically compatible with secureFile as it is a subtype of EncryptionAlgorithm. In this example, we\u2019re respecting the 5 SOLID principles all together. Flutter Complete Reference 193",
  ". Coding principles with Dart .2 Dependency Injection Two classes are said to be \"coupled\" if at least one of them depends on the other. Class A depends on class B when you can\u2019t compile class A without the presence of class B. This can be very dangerous, let\u2019s see why. class PaymentValidator { final Date date; final String cardNumber; const PaymentValidator(this.date, this.cardNumber); // Uses the MasterCard payment circuit void validatePayment(int amount) { ... } } class PaymentProcessor { late final _validator; PaymentProcessor(String cardNumber) { _validator = PaymentValidator(DateTime.now(), cardNumber); } Date get expiryDate => _validator.date; void pay(int amount) => _validator.validatePayment(amount); } abstract class Checker { PaymentValidator mastercardCheck(); } class CheckerOne extends Checker { /*... code ... */ } class CheckerTwo extends Checker { /*... code ... */ } Both Checker and PaymentProcessor have a strong dependency on PaymentValidator because it\u2019s essential in order to compile. Subclasses, of course, inherit the dependency too. Flutter Complete Reference 194",
  ". Coding principles with Dart Let\u2019s say you\u2019ve written this code at work. One day, your project manager tells you to ditch Mastercard and replace it with PayPal. You\u2019ll quickly get a stomach ache as soon as you realize that, from an apparently small change, the whole architecture has to be refactored. . Paypal just requires an email but your Mastercard implementation requires date and card number. You\u2019re forced to entirely change PaymentValidator but by consequence you also need to update both PaymentProcessor and Checker as they\u2019re strong dependencies. class PaymentValidator { final String _email; const PaymentValidator(this._email); void validatePayment(int amount) { ... } } class PaymentProcessor { late final PaymentValidator _validator; PaymentProcessor(String email) : _validator = PaymentValidator(email); void pay(int amount) => _validator.validatePayment(amount); } Flutter Complete Reference 195",
  ". Coding principles with Dart There\u2019s been a \"cascade\" e\ufb00ect because changes made to a single class had consequences to other classes as well. . The above changes break another part of the code: the abstract class Checker also depends on PaymentValidator so there\u2019s the need to \ufb01x the code. abstract class Checker { // earlier it was called 'mastercardCheck()' PaymentValidator payPalCheck(); } This change has consequences on any subclass of Checker which has to be updated. De- pendencies on superclasses are inherited by its children and thus the coupling propagates. . There are no ways to solve this problem other than manually updating every single subclass of Checker. Your IDE will come to the rescue with a refactor tool but maintenance is a pain anyway. As you\u2019ve just seen, an apparently small and quick change on a class propagated to an entire hierarchy and other big components of our project. All of this happened because classes are strongly coupled and they depend on implementations rather than abstractions. ..1 Constructor injection Using dependency injection and abstractions rather than implementations, the above problems fade away. Dependencies passed from the outside create a weak coupling which is safer than a strong one as it relies on abstractions. abstract class PaymentValidator { const PaymentValidator(); void validatePayment(int amount); } class MasterCard implements PaymentValidator { // Define date, card number and the constructor const MasterCard(); void validatePayment(int amount) {...} } class PayPal implements PaymentValidator { // Define an email and the constructor Flutter Complete Reference 196",
  ". Coding principles with Dart const PayPal(); void validatePayment(int amount) {...} } The PaymentProcessor class is still going to have a PaymentValidator dependency but it\u2019s weak because it\u2019s just an interface. Using \"constructor injection\" we pass from the outside a concrete implementation, which can later be replaced with anything else. class PaymentProcessor { final PaymentValidator _validator; const PaymentProcessor(this._validator); void pay(int amount) => _validator.validatePayment(amount); } // And then we can freely use PayPal or MasterCard void main() { final p1 = const PaymentProcessor(MasterCard()); final p2 = const PaymentProcessor(PayPal()); } In this case, we\u2019re passing an instance of a concrete class via constructor and that\u2019s fundamental. PaymentProcessor knows nothing about the implementation details of the validator object, it just knows he has to call validatePayment(int). We can also use const constructors now! \u2022 This code is very \ufb02exible and maintainable. If your boss told you to add support for the Visa circuit as well, you would simply have to create a new subtype of PaymentValidator. class Visa implements PaymentValidator { const Visa(); void validatePayment(int amount) {...} } No changes are required to the existing code and you at the same time you\u2019re still embracing S.O.L.I.D. principles. The architecture is robust! \u2022 PaymentProcessor now doesn\u2019t care anymore about Mastercard, Paypal or whatever be- cause they\u2019re given from the outside. Internally he weakly depends on an abstraction which just gives an abstraction: the implementation is passed via constructor. \u2022 You have a series of classes, one per payment method, that are super easy to test. You Flutter Complete Reference 197",
  ". Coding principles with Dart could make a \"mock\" class for unit tests just like a regular validator type: class TestValidator implements PaymentValidator { const TestValidator(); void validatePayment(int amount) {...} } Last thing we need to refactor is the Checker class as it has to return an abstraction rather than an implementation. abstract class Checker { PaymentValidator paymentCheck(); } class CheckerOne extends Checker {...} class CheckerTwo extends Checker {...} Since PaymentValidator is abstract, any class along the hierarchy inherits a weak dependency which is safe. ..2 Method injection Constructor injection is used when you class really needs an external dependency to work. When you have an \"optional\" dependency not strictly required from your class, you can use method injection. abstract class CheckProcessor { const CheckProcessor(); bool isActive(); } class MastercardCheck implements CheckProcessor { final MasterCardApi _api; const MastercardCheck(this._api); bool isActive() async => await _api.isOnline(); } class PaypalCheck implements CheckProcessor { final PaypalApi _api; Flutter Complete Reference 198",
  ". Coding principles with Dart const PaypalCheck(this._api); bool isActive() async => await _api.available(); } These classes connect to the internet, perform some GET requests and return true or false whether the service provider is online or not. Let\u2019s say this feature is not essential in our archi- tecture but it\u2019s nice to have it. It might be used but it\u2019s not certain. class PaymentProcessor { final PaymentValidator _validator; const PaymentProcessor(this._validator); void pay(int amount) => ... bool isProcessorActive(CheckProcessor check) => return check.isActive(); } In this way, if we wanted to check the availability of the service we could do this: void main() { final api = MasterCardApi(...); final processor = MasterCard(api); final checker = MastercardCheck(); final payment = PaymentProcessor(processor); final isOnline = payment.isProcessorActive(checker); } Note the di\ufb00erence: while the processor is fundamental, and thus it\u2019s passed via constructor, the connection checker made with isProcessorActive is not always required. So in general: \u2022 constructor injection is for essential dependencies that your class is always going to use; \u2022 method injection is for optional dependencies that you class might use. Actually both type of injection use the same concept, which is depending on abstractions and passing implementations from the outside, but they di\ufb00er in order of \"importance\". Dependencies passed via constructor are fundamental while the ones passed via method are just useful but not essential. Flutter Complete Reference  \"Programs must be written for people to read, and only incidentally for machines to execute.\" Abelson and Sussman Part II The Flutter framework   | Basics of Flutter .1 Structure and tools Android Studio (AS), along with the o\ufb03cial plugin, is Google\u2019s \ufb01rst-choice IDE which o\ufb00ers a very pleasant development experience. Alternatively, Flutter apps can also be created using Vi- sual Studio Code (VS Code), Emacs or any text editor along with the Flutter command line tool. \u009f The o\ufb03cial Flutter documentation gives you a step-by-step install guide 1 for Windows, macOS and Linux. Please follow it carefully to properly setup your envi- ronment. We have used Android Studio .., which is the latest version at the time of writing this book. Any new Flutter project, whether it\u2019s created with Android Studio or VS Code, requires a series of \ufb01les and directories for both you and the IDE. Most of them can safely be ignored because you\u2019ll spend basically all of your time inside lib/ and test/. 1https://\ufb02utter.dev/docs/get-started/install Flutter Complete Reference 203",
  ". Basics of Flutter This is what we get on Windows using Android Studio but depending on the IDE you\u2019re using, there might be some di\ufb00erent con\ufb01guration \ufb01les. Regardless the operating system and the IDE, for sure there will always be at least: \u2022 android/ and ios/: These folders contain platform-speci\ufb01c code for each OS and they\u2019re automatically managed by the IDE and the compiler. The structure is exactly the same you\u2019d get with a new Android project on Android Studio or iOS project on XCode. \u2022 lib/: This folder is essential: it contains the Dart source code of your Flutter app. You\u2019re going to spend a countless amount of hours in here. \u2022 test/: Unit tests, widget tests and integration tests all go in this folder.",
  "is a in-depth guide on how to properly test your Flutter apps. \u2022 pubspec.yaml: This \ufb01le is fundamental as it de\ufb01nes a Dart package and lists dependencies of your Flutter app. \u2022 README.md: It\u2019s the typical markdown \ufb01le you can \ufb01nd in any git repository. It\u2019s used for your git repository and at the same time as \"home page\" at https://pub.dev in case you wanted to publish a package. All the other \ufb01les or folders we haven\u2019t mentioned in the above list are automatically managed by the IDE (or the compiler) so you shouldn\u2019t care about them. Flutter Complete Reference 204",
  ". Basics of Flutter ..1 Folder structure Before starting your coding journey, it\u2019d be a good idea to have a solid background in folder structure and organization. The o\ufb03cial Flutter documentation doesn\u2019t give any guideline about this since you\u2019re free to do what you prefer. We have some suggestions for you: \u2022 lib/. Your app\u2019s source code goes here. Grouping \ufb01les in proper folders is essential if you don\u2019t want to get lost in your own architecture so, before coding, mind the structure. \u2013 routes/ \u2013 models/ \u2013 widgets/ \u2013 main.dart \u2013 routes.dart You could mind your project\u2019s folder structure starting from this simple skeleton. routes/ contains your app\u2019s pages, models/ is for the \"business logic\" and widgets/ is for reusable UI widgets. \u2013 localizations/ \u2013 routes/ \u2013 widgets/ \u2013 models/ \u2217blocs/ \u2217providers/ \u2217repositories/ \u2217... \u2013 main.dart \u2013 routes.dart If you plan to make your apps available in multiple languages, consider grouping all the lo- calization logic inside localizations/. A complete coverage about localization techniques in Flutter will be discussed in detail in chapter . Structure folders with many sub folders. Flutter Complete Reference 205",
  ". Basics of Flutter \u2022 test/. Flutter has a powerful automated testing suite; we recommend splitting test \ufb01les according with their use case. \u2013 unit/ \u2013 widget/ \u2013 integration/ We will cover testing in depth in chapter . There would be the possibility to throw all your \ufb01les inside a single folder (for example lib/) with no structure but... no! In a medium-large app architecture, maintenance is going to be painful because there\u2019s no logical organization. ..2 The pubspec.yaml \ufb01le This \ufb01le is very important and it deserves to be properly described. It gives you control on: dependencies used by Flutter, resources/assets of your app and the versioning system for pro- duction binaries. \u009f YAML is a data-serialization language commonly used for con\ufb01guration \ufb01les. It exposes a series of settings in a human-readable way; it has no punctuation as it relies on indentation and line breaks. Indentation and line breaks are very important because there are no semicolons or commas as separators. We\u2019re only giving an overview of the most important attributes but of course the o\ufb03cial documentation 2 will give you a full reference. \u2022 version. Any package is required to specify a version number which increments at any release; in chapter 24 we\u2019ll see how to write a Flutter package that can be uploaded to https://pub.dev. Here you see a library with its version number: 2https://dart.dev/tools/pub/pubspec Flutter Complete Reference 206",
  ". Basics of Flutter When you\u2019re releasing an app for the Google Play store or the Apple App store, this number is used to assign a version value to the product. For example if you had... version: ..+ ... it would mean that your app\u2019s version name would be ..0 and the build number would be . In the Android world, inside build.gradle, the \ufb01eld versionName would be ..0 and versionCode would be . \u2022 sdk. This section contains the constraints indicating which SDK versions your app sup- ports. The Dart team recommends to always include a lower and an upper bound but you could simply use \">= .\" and it\u2019d be valid anyway. environment: sdk: \">=.. <..\" With the above range you can use everything coming from version .7 onward so Dart extensions for example (introduced in .) are supported. \u2022 uses-material-design. Ensures that your Flutter app is able to use icons from the Google Material design 3 project. They are pretty common in the Google world, especially in Android as they\u2019re the default icons being used in many apps. Having uses-material-design: true icons are already available, you\u2019ve nothing to down- load or setup because they\u2019re bundled in the Flutter SDK. Icons are actually vectorial images so they resize without quality loss. 3https://material.io/ Flutter Complete Reference 207",
  ". Basics of Flutter \u2022 dependencies. This is probably the most important label because it declares any package the app is going to depend on. You just need to go to https://pub.dev, look for a package and add a new line. dependencies: flutter: sdk: flutter http: ^..2 provider: ^..+2 flutter_svg: ^..1 On the left there\u2019s the name of the package while on the right there\u2019s the version being downloaded from the repository. They have been added in this very simple way: . open https://pub.dev; . search for \"http\" or any other meaningful keyword; . choose a package from the list and click on the Installing tab; . copy/paste the given installation string, in our case \"http: ^..\" \u2022 assets. This label speci\ufb01es the paths to static resources your app will use such as images, SVG vectorials, audio/video \ufb01les or simple text. For example, you could create a folder called images/ and put everything in there without having to list \ufb01les one by one. flutter: assets: - images/ - files/text/myFile.txt - audio/ In the second line we have imported a text \ufb01le giving the exact location. The root of the project is the directory in which you have the pubspec.yaml \ufb01le. When you declare any kind of asset, the starting point for the path is the root. \u2022 fonts. By convention this label is put at the bottom of the \ufb01le, after assets. You can download font \ufb01les from https://fonts.google.com and import them directly in your app. flutter: assets: - images/ Flutter Complete Reference 208",
  ". Basics of Flutter fonts: - family: Roboto fonts: - asset: fonts/Roboto-Regular.ttf - asset: fonts/Roboto-Italic.ttf style: italic - family: RobotoMono fonts: - asset: fonts/Righteous-Regular.ttf weight: 400 Once you\u2019ve downloaded the .ttf \ufb01les from Google Font, create a folder called (by con- vention) fonts/ and put the \ufb01les in there. There\u2019s nothing more to do because Flutter will take care of automatically loading them. \u2013 https://pub.dev/packages/google_fonts Starting from January 2020 there\u2019s an o\ufb03cial Flutter package called google_fonts which retrieves fonts from https://fonts.google.com/ and caches them. This is ideal for develop- ment: no need to place font assets in the font/ folder because they will be automatically downloaded and cached. Text( 'This is Google Fonts', // Download 'pacific' and cache it style: GoogleFonts.pacific(), ), However, you could download font \ufb01les anyway and include them as assets because it\u2019s faster and more secure. You might be in trouble if the user opened your app for the \ufb01rst time with no internet connection. The Google Fonts package will prioritize pre-bundled \ufb01les over http fetching, so you could do the following: . While developing, use http font fetching from the internet, which is very convenient. . Before publishing the app, go to https://fonts.google.com/, download the font \ufb01les you need and move them to the font/ folder in your Flutter project. . Open the pubspec.yaml \ufb01le and add font/ under assets so that google_fonts can automatically load font \ufb01les from there. Flutter Complete Reference 209",
  ". Basics of Flutter flutter: assets: - images/ - fonts/ There is no need to have the fonts section because \ufb01les are already included as assets. In this way google_fonts will load font assets at startup rather than at the \ufb01rst usage. However, if a given font is required and it\u2019s not in the assets, it will be downloaded and cached automatically. In summary, we recommend the usage of google_fonts for development but you should provide font \ufb01les as assets so that they can be loaded at startup (rather than at runtime, via HTTP request). ..3 Hot Reload If you know the basics of HTML, you\u2019re aware of the fact that any edit to an .html \ufb01le can be seen immediately clicking the refresh button of the browser. It\u2019s literally a matter of seconds because you just need to save the \ufb01le and press F5. Flutter works in the same way! Thanks to the hot reload feature, you can refresh the UI in your emulator (or physical device) while writing Dart code. There is no need to make a build every time and wait for gradle/Xcode to complete. It\u2019s like if you pressed F5 in your browser to refresh the HTML source \ufb01le. \u009f You have to Run the app in debug mode for the \ufb01rst time but then you can press Flutter Complete Reference 210",
  ". Basics of Flutter the yellow lightning which is the Hot reload button. You\u2019ll see the UI immediately updated and fully functional in sync with the latest code you\u2019ve written. Hot reload is blazing fast as it takes less than a second to refresh the UI. It increases a lot the productivity because changes are immediately applied and ready to be tested, no need to wait for build processes. Hot reload works in most of the cases but in certain circumstances you have to stop and re-run the app entirely: \u2022 when you make changes to the initState() method (more in it in the next chapter) \u2022 when you change the de\ufb01nition of a class into an enum and vice versa, \u2022 when you make changes to static \ufb01elds in classes, \u2022 when you make changes to code inside void main() {}. In debug mode Flutter uses the JIT compilation model that, in combination with the Dart Vir- tual Machine, allows fast injection of the source code and quick incremental rebuilds. In other words, we can say that \"Flutter\u2019s hot reload is super fast!\". \u009f While creating Flutter apps, it\u2019s common having an Android or iOS simulator on the right of the screen and your favorite IDE in the remaining space. This is the fastest way to write code and see the results immediately with the hot reload feature. ..4 Linter rules After hours of coding, you might forget to give a generic class the type and thus the compiler automatically assigns dynamic. It\u2019s all good because compilation successfully executes but the code is not type safe and thus you\u2019re not following the good practices. \u009f A linter is a very helpful tool that reads the source code and spots syntax errors, suspicious constructs, styling errors and much more. By default Dart\u2019s linter is very permissive and it marks something as error only when really needed. Making the linter more severe is very productive as it can discover problems and potential bugs even before executing the code. In order to do this there\u2019s the need to create a \ufb01le called analysis_options.yaml in the same folder as the pubspec. Flutter Complete Reference 211",
  ". Basics of Flutter analyzer: strong-mode: implicit-casts: false implicit-dynamic: false linter: rules: - avoid_unused_constructor_parameters - await_only_futures - directives_ordering - empty_constructor_bodies - empty_statements - hash_and_equals - implementation_imports - null_closures - package_api_docs - slash_for_doc_comments - test_types_in_equals - throw_in_finally - type_init_formals Visit the o\ufb03cial Dart documentation 4 to get a complete list of any linter rule. We strongly encourage you to create an analysis_options.yaml for every Flutter app or Dart project you create. There is also the possibility to change the default behavior of the linter: analyzer: errors: include_file_not_found: error dead_code: warning For example, by default when a given include \ufb01le could not be found a warning is emitted. If you want this issue to be more important, it can be treated as an error by overriding its severity to one of these levels: \u2022 error: causes static analysis to fail; \u2022 warning: static analysis doesn\u2019t fail unless warnings are treated as errors by the analyzer; \u2022 info: just an message info which doesn\u2019t make static analysis fail; \u2022 ignore: ignores the given rule. 4https://dart-lang.github.io/linter/lints/ Flutter Complete Reference 212",
  ". Basics of Flutter Basically in errors you can rede\ufb01ne the severity of warnings and errors as you want. In general the default setup is \ufb01ne as it is, you don\u2019t need to override rules and in particular try to avoid using ignore. Visit the o\ufb03cial documentation 5 to get a complete list of any overrideable property. \u009f The analysis_options.yaml \ufb01le summarizes the Dart\u2019s good practices guidelines so that you don\u2019t have to remember everything. The IDE is able to read this \ufb01le and emit visual messages for you. Very simply put, having proper rules set on analysis_options.yaml is like having something that guides you to follow Dart\u2019s best practices. Go to the Resources page of our website to download a good template we recommend you to use. ..5 Tree shaking and constants Using import \"package:flutter/foundation.dart\" might be very useful while developing and debugging Flutter apps. It exposes three constant boolean values the developer can use to execute a series of instructions according with the build mode: \u2022 Debug mode. if (kDebugMode) { // code to be executed when running the app in debug mode... } \u2022 Pro\ufb01le mode. if (kProfileMode) { // code to be executed when running the app in profile mode... } \u2022 Release mode. if (kReleaseMode) { // code to be executed when running the app in release mode... } When building a Flutter app (in any mode), \"tree shaking\" is automatically performed. It\u2019s basically the compiler removing dead code depending on variables being constant or not plus other factors. For example, look at this piece of code: 5https://pub.dev/documentation/analyzer/latest/analyzer/analyzer-library.html Flutter Complete Reference 213",
  ". Basics of Flutter String get name { if (kDebugMode) { return \"Demo\"; } else { return _real(); } } The Run button of Android Studio and VS Code builds the app in debug mode so the above code will always return \"Demo\". The other statement (return _real();) is automatically removed by the compiler because it will never be reached. According with the build mode, after the compilation the same piece of code can look like this: . Debug mode Pro\ufb01le mode Release mode String get name { return \"Demo\"; } String get name { return _real(); } String get name { return _real(); } . You should really use these constants while developing your apps as they\u2019re very useful. There\u2019s also no need to manage them because the compiler will automatically remove the unused parts (dead code is automatically discarded). Tree shaking works with any constant value: const isGood = true; if (isGood) { print(\"Good!\"); } else { print(\"Bad!\"); } The compiler will remove the else branch because it\u2019s considered to be dead code. Flutter Complete Reference 214",
  ". Basics of Flutter .2 Widgets and State In Flutter everything that appears on the screen is called \"widget\" because, technically speaking, it\u2019s a descendant of the Widget class. When you create user interfaces in Flutter you make a composition of widgets by nesting them one inside the other. \u009f If you talk about widgets you refer to buttons, text \ufb01elds, animations, containers and even the UI page itself. Anything appearing on the screen or interacting with it is a widget. Widgets everywhere! When you nest widgets one inside the other you create a hierarchy called \"widget tree\" in which there are parents and children. In a fresh new Flutter project, the IDE prepares a sample application in main.dart having this minimal structure: import 'package:flutter/material.dart'; void main() { runApp(MyApp()); } class MyApp extends StatelessWidget { @override Widget build(BuildContext context) {...} } As you know, any Dart program must have a void main() {} entry point and Flutter is no exception; the runApp() method takes an instance of a Widget and makes it the root of the widget tree. At the beginning you get a tree with a single leaf (the root itself): In the next section we will see that a class in Flutter becomes a widget when it inherits from StatelessWidget or StatefulWidget. For now, note that the runApp() method has made the Flutter Complete Reference 215",
  ". Basics of Flutter class called MyApp the root of the tree. Let\u2019s add more contents to see how the widget tree expands. void main() => runApp(const MyApp()); class MyApp extends StatelessWidget { const MyApp(); // Good idea! @override Widget build(BuildContext context) { return Column( children: <Widget>[ Text(\"Hello\"), Text(\"Flutter), ] ); } } The method Widget build(BuildContext context) adds new leaves to the widget tree in order to place new graphical items in the UI. Widgets are nested one inside the other using named parameters in the constructors to make the reading of the code very expressive. This is the new situation: Flutter Complete Reference 216",
  ". Basics of Flutter The addition of widgets makes the tree bigger and places new items on the screen. The context parameter in build(BuildContext context) gives important information about the position of the leaf in the tree. In particular: \u2022 A BuildContext instance is used by Flutter to know details about the widget when the tree is being traversed; \u2022 We will see that calling SomeWidget.of(context) returns the closest widget in the tree whose type is SomeWidget; \u2022 Each widget has its own BuildContext instance which becomes the parent context of the widget(s) returned by its build method. Other than passing an instance of BuildContext to widgets\u2019 constructors you won\u2019t do anything else with it. It\u2019s intended to be used by Flutter to get info about the widget tree; the developer hardly never is asked to use it directly. \u009f The interpolation of classes, nested with named constructors, embraces the so called declarative UI design which is the typical Flutter coding style. Flutter Complete Reference 217",
  ". Basics of Flutter ..1 Basic widgets Flutter has a countless amount of widgets that can be found both in the core library or online at https://pub.dev. We\u2019re immediately going to list the most important ones but you\u2019ll discover many others while reading the book. \u009f We strongly encourage you to visit the online catalog as it showcases the most important UI widgets for both material (Android) and cupertino (iOS) styles. The Flutter team is very active and the catalog is improved/expanded very often. ...1 Text You wouldn\u2019t be surprised to \ufb01nd out that the Text widget is used to display a piece of text on the screen. It\u2019s highly customizable as you can change the color, the font using font assets or the Google Font package and much more. const Text( \"Text on the screen\", style: TextStyle( color: Colors.amber, fontSize: , wordSpacing: , ), ); It just requires a string as a parameter, which is the text being displayed on the UI, and the styling is made with the TextStyle() 6 class. It de\ufb01nes many properties of the text itself and it\u2019s also the place in which the google_fonts package can be used. Text( \"Text on the screen\", style: GoogleFonts.lato( textStyle: const TextStyle( color: Colors.amber, fontSize: , wordSpacing: , ), 6https://api.\ufb02utter.dev/\ufb02utter/painting/TextStyle-class.html Flutter Complete Reference 218",
  ". Basics of Flutter ), ); ...2 Row This widget places one or more children in the horizontal axis with the given space constraints. It\u2019s used very often when you need to have multiple items aligned side by side. There is no const constructor for Row but you can assign it, when possible, to the children value. Row( mainAxisAlignment: MainAxisAlignment.center, children: const [ Text(\"Hello\"), Text(\"Flutter!\"), Text(\"!!\"), ], ), You can easily \ufb01gure out that there will be three Text widgets side by side at the center of the screen. By default, a row tries to totally cover the available horizontal space; you can make sure it shrinks to \ufb01t the width of its content using: Row( mainAxisSize: MainAxisSize.min, ), Widgets in rows can be placed in di\ufb00erent ways according to the value of mainAxisAlignment. The default behavior is start but of course it can be changed passing di\ufb00erent values to the constructor. \u2022 center. Places the items at the center of the row. \u2022 start. Places the items at the beginning of the row. Flutter Complete Reference 219",
  ". Basics of Flutter \u2022 end. Places the items at the end of the row. \u2022 spaceAround. Places the items with equal distance between each other and the margins. \u2022 spaceBetween. Places the items with an evenly space between them. ...3 Column This widget places one or more children in the vertical axis with the given space constraints. A Column is the opposite of a Row as it has the same purpose but it works in the opposite direction (vertical rather than horizontal). Flutter Complete Reference 220",
  ". Basics of Flutter Column( mainAxisAlignment: MainAxisAlignment.center, children: const [ Text(\"Hello\"), Text(\"Flutter!\"), Text(\"!!\"), ], ), It\u2019s identical to a Row but here items are placed one above the other because a Column works in the vertical axis. It tries to totally cover the available vertical space; you can make sure that it shrinks to \ufb01t the height of its content using Column( mainAxisSize: MainAxisSize.min, ), You can place widgets in di\ufb00erent ways just by passing a new alignment to the mainAxisAlignment parameter of the constructor. It\u2019s completely identical to a Row because alignments work in the same way. A column does NOT have a scroll behavior so if there\u2019s not enough space, you\u2019ll get an over\ufb02ow error at runtime. Flutter Complete Reference 221",
  ". Basics of Flutter ...4 ListView A ListView is basically a Column with scrolling behavior as it places one or more children in the vertical axis, in sequence. This widget is very widely used because it provides the possibility to scroll contents when they are bigger than the screen size. ListView( children: const [ Text(\"Hello\"), Text(\"Flutter!\"), Text(\"!!\"), ], ), Widgets are aligned to the top and the scrolling direction is vertical by default but of course you can change it. With scrollDirection you can decide whether the list has to scroll in the horizontal or vertical axis. ListView( scrollDirection: Axis.horizontal, ), When the content of the list is known in advance, children are simply declared inside a list as you\u2019ve seen above. The ListView.builder(...) named constructor is very useful when the list has to be built based on an existing collection. // Somewhere in the code there's a list of 100 integers final myList = List<int>.generate(, (i) => i); // The 'builder' named constructor builds a list of widgets // by taking the 'myList' list as data source. ListView.builder( itemCount: myList.length, itemBuilder: (context, index) { return Text(\"${myList[index]}\"), }, ), The o\ufb03cial Flutter documentation 7 suggests to use the builder(...) named constructor when the data source is a long list because it e\ufb03ciently manages the children. So, rather than manually 7https://\ufb02utter.dev/docs/cookbook/lists/long-lists Flutter Complete Reference 222",
  ". Basics of Flutter \ufb01lling a long ListView with a for loop, use its builder() which is more e\ufb03cient. ...5 Container This widget is the equivalent of a <div></div> tag in the HTML world; it\u2019s a general purpose container you can use to customize painting, positioning, sizing and much more. A Container is very widely used since it accomplishes many use cases such as making rounded borders or working with shapes. It might seem a complex result to achieve but it\u2019s actually very easy because a container is made exactly for this kind of purposes. Widget build(BuildContext context) => Container( height: , width: , color: Colors.blueGrey, alignment: Alignment.center, transform: Matrix4.rotationZ(-.), child: const Text( \"Containers!\", style: TextStyle( color: Colors.white, fontSize:  ) ) Flutter Complete Reference 223",
  ". Basics of Flutter ); The rotation is obtained thanks to transform: Matrix4.rotationZ(-.), which de\ufb01nes how to place an object in the 3D space. This is often used in animations but you\u2019ll have to wait until chapter 14 to read more. In order to style a Container you have to use a BoxDecoration class: Container( child: const Center(...), width: , height: , decoration: const BoxDecoration( shape: BoxShape.circle, boxShadow: [ BoxShadow( color: Colors.grey, spreadRadius: , blurRadius: , offset: Offset(, ), ), ], gradient: LinearGradient( begin: Alignment.topCenter, end: Alignment.bottomCenter, colors: [ Color.fromARGB(...), Color.fromARGB(...) ], ) ), ); In this example we\u2019ve created a circle with a shadow behind and a linear gradient as back- ground. The BoxShadow class is very similar to the CSS box-shadow property, exactly like LinearGradient which can of course interpolate more than two colors. It isn\u2019t the only type of gradient you can use: \u2022 LinearGradient: a progressive transition of two or more colors along a straight line; \u2022 RadialGradient: a progressive transition of two or more colors radiating around a central Flutter Complete Reference 224",
  ". Basics of Flutter point; \u2022 SweepGradient: a progressive transition of two or more colors with a circular sweep on a central point. You can also have rounded borders with borderRadius: BorderRadius.circular(.) or a simple plain background color with the color: property. Be sure to check out the o\ufb03cial documentation about BoxDecoration 8 to see how you can fully customize a Container. ...6 Stack and Positioned Thanks to the Stack widget you can overlap widgets and freely position them on the screen using Positioned. Even if children are placed outside the bounds of the UI, no over\ufb02ow errors will appear because a Stack doesn\u2019t constrain the bounds of width and height. Stack( children: [ Container( width: , height: , decoration: const BoxDecoration( color: Colors.red ) ), const Text(\"Hello\"), ] ) With this simple example, the UI is created with a red box and the Text widget is painted in front of the Container. The order in which you place the widgets really matters because children at the bottom of the list are placed, relatively, in front of the ones at the top. The foreground widget goes at the end of the list. Stack( children: [ const Text(\"Hello\"), Container( 8https://api.\ufb02utter.dev/\ufb02utter/painting/BoxDecoration-class.html Flutter Complete Reference 225",
  ". Basics of Flutter width: , height: , decoration: const BoxDecoration( color: Colors.red ) ), ] ) In this case the red box would be placed in front of the Text widget because, in order, it comes after and thus \"Hello\" is not visible because covered by the Container. You could however decide to move the text at a speci\ufb01c position of the screen: Stack( children: const [ Positioned( top: , left: 65 child: Text(\"Hello\"), ), ] ) You could also have used a negative o\ufb00set such as left: -15 to position the text outside the bounds of the visible area. ..2 Stateless and Stateful widgets A class becomes a Flutter widget when it subclasses StatelessWidget or StatefulWidget and overrides the Widget build(...); abstract method. That\u2019s it: the main task of a widget is laying out other widgets on the tree using the build() method. \u009f You already know from the previous examples how widgets are laid out inside build() to compose the UI. They\u2019re nested one inside the other. Before creating a widget the developer must decide whether the state will change during the time or not. If the state changes at some point, then it means that something has happened such as: Flutter Complete Reference 226",
  ". Basics of Flutter \u2022 the user has tapped on a button and thus something in the UI must change; \u2022 the device has been rotated and the UI must be repainted; \u2022 there\u2019s a new event on a stream and a widget depending on it is noti\ufb01ed (and thus a rebuild happens in order to re\ufb02ect the changes brought by the stream). In other words, you have to ask yourself if the widget is immutable or if it\u2019s \"dynamic\", in the sense that something might change during the time. The decision translates into Dart code by extending one of these two classes. \u2022 Stateless widget. Use this kind of widget when you need to create a piece of UI that is not going to change over the time. It\u2019s a \"standalone\" block that doesn\u2019t depend on external events or sources; it just relies on its constructor and the internal data. class MyName extends StatelessWidget { // Notice the constant constructor const MyName(); @override Widget build(BuildContext context) { return Row( mainAxisAlignment: MainAxisAlignment.spaceAround, children: const [ Icon(Icons.person), Text(\"Flutter developer\"), ] ); } } This is a perfect example of a StatelessWidget because the contents will always be the same; no external dependencies or streams are going to change the text or the icon. Once created, the widget is \"static\" because it will never change: it\u2019s a \"solid block\". class MyName extends StatelessWidget { final String name; const MyName({ // use the annotation '@required' if your Dart version does not //support nnbd required this.name Flutter Complete Reference 227",
  ". Basics of Flutter }); @override Widget build(BuildContext context) => const Text(name); } By convention Flutter widgets have named optional parameters in the constructor; in case they were required, use the required keyword. Since this class is immutable it\u2019s a very good idea marking the instance variables as final so that a const constructor can be de- clared. \u009f Even if the class takes a string from the outside, via constructor, it still doesn\u2019t change over the time. The given name will always be the same and thus the widget will never change/rebuild, so a stateless solution is \ufb01ne. If you\u2019re working with Dart .9 or lower versions, instead of the required keyword you\u2019re going to use the @required annotation. \u2022 Stateful widget. Use this kind of widget when you need to create a piece of UI that is going to change over the time. In this case the UI is going to dynamically change due to external events such as the received response of an HTTP request or the callback triggered by a button tap. class Counter extends StatefulWidget { // Don't forget the constant constructor! const Counter(); @override _CounterState createState() => _CounterState(); } // Notice the underscore: the state is a package-private class class _CounterState extends State<Counter> { int _counter = ; @override Widget build(BuildContext context) { return Column( Flutter Complete Reference 228",
  ". Basics of Flutter children: [ Text(\"$_counter\"), IconButton( child: Icon(Icons.add), onPressed: () { setState(() => _counter++); } ), ], ); } } Buttons and UI design will be introduced in the next section, they aren\u2019t key point now. In this widget the main actor is the IconButton: once tapped by the user, the onPressed callback is triggered and the _counter variable is incremented. . Counter is the widget itself and thus it\u2019s inserted in the widget tree; _CounterState is the mutable state of the Counter widget. When Flutter rebuilds the widget tree to refresh the UI, the build(...) method of State<T> is called. . This is the standard pattern for the creation of a stateful widget and you should really follow it. Both Android Studio and VS Code can automatically create the boilerplate for you. . Subclasses of State<T> gain access to the setState(...) method which rebuilds the widget (it\u2019s like a refreshing tool). . Member instances, such as _counter, survive to rebuilds. Only what\u2019s inside the build() method is refreshed. When you tap on the button, the onPressed callback is activated: setState(...) executes its body and then Flutter rebuilds the widget. In our example, int _counter gets incre- mented by 1 and then the widget is refreshed so that Text can display the new updated value. \u009f The variable _counter belongs to the state State<Counter> object and for this reason it\u2019s not reset when the widget is rebuilt. Remember that the state \"survives\" when a build happens. Flutter Complete Reference 229",
  ". Basics of Flutter Counter is the widget (what\u2019s inserted on the tree) while _CounterState is the state. The state survives to rebuilds but its build() method doesn\u2019t. If you\u2019re not convinced yet, we\u2019re going to tell you that this snippet works as intended. class _CounterState extends State<Counter> { int _counter = ; @override Widget build(BuildContext context) { return Column(...); } } The state survives to rebuilds so _counter is not reinitialized to zero, it keeps the count. Only what\u2019s inside the build method is refreshed. If you did this... class _CounterState extends State<Counter> { @override Widget build(BuildContext context) { int _counter = ; return Column(...); } } ... your counter would always be zero! It\u2019s still correctly incremented by setState() which nicely does _counter++ but then the widget is rebuilt and the \ufb01rst line does _counter = 0 which sets it back to zero. If you used the constructor of a StatefulWidget to set some data, the associated State<T> class can get a reference to them by simply using the widget getter. Again, try to use const as much as possible. class WidgetDemo extends StatefulWidget { final int id; const WidgetDemo(this.id); @override _WidgetDemoState createState() => _WidgetDemoState(); } Flutter Complete Reference 230",
  ". Basics of Flutter class _WidgetDemoState extends State<WidgetDemo> { @override Widget build(BuildContext context) { return Text(\"The given id is ${widget.id}\"); } } In the above example, WidgetDemo is allowed to have a const constructor because once in- serted in the widget tree, it will never change. What really changes is its state, represented by _WidgetDemoState, which in fact cannot have a constant constructor. ...1 Good practices First of all, there\u2019s the need to say that there are NO performance di\ufb00erences between a stateful widget and a stateless widget. You don\u2019t have to think that a stateless widget is an optimized version of a stateful one or vice versa. \u009f Actually a StatelessWidget can be seen as a StatefulWidget without the setState() method. When creating a stateful widget, the state is clearly visible because it\u2019s a separated private class: // Widget class Counter extends StatefulWidget { ... } // Widget's state class _CounterState extends State<Counter> { ... } A stateless widget is just syntactic sugar for those cases in which you don\u2019t need to create a custom state. A StatelessWidget has a state too but you can\u2019t see it because it\u2019s not meant to be manually changed. You could use StatefulWidgets all day all night without having problems but it wouldn\u2019t make sense. If the state doesn\u2019t change, go for a StatelessWidget which is less boilerplate code and it exposes less methods. Here\u2019s a guideline to help you deciding which one should be used: \u2022 When every instance variable of your widget can be marked with the final modi\ufb01er, use a stateless widget with a const constructor. class PersonWidget extends StatelessWidget { final String name; Flutter Complete Reference 231",
  ". Basics of Flutter final String age; const PersonWidget({ required this.name, required this.age }); @override Widget build(BuildContext context) { ... } } This is an immutable class because it has final variables and a constant constructor: once instantiated, the widget will never change. This is a \"static block\", widget that doesn\u2019t change over the time. \u2022 When your widget has some variables that cannot be final because they might change over the time, use a stateful widget. It might happen when you have to lazily initialize some values or you\u2019re waiting for an asynchronous request. class Counter extends StatefulWidget { const Counter(); @override _CounterState createState() => _CounterState(); } class _CounterState extends State<Counter> { int _counter = ; @override Widget build(BuildContext context) { ... } } In this case _counter cannot be final because the build() method is going to alter it. When an instance variable can be changed over the time, by consequence the state of the widget will also change. In this case, a StatefulWidget is the right choice. \u2022 In all those cases where a widget is something \"static\" that doesn\u2019t depend on anything external, consider making it stateless as you don\u2019t need to change its state. class AuthorsWidget extends StatelessWidget { const AuthorsWidget(); Flutter Complete Reference 232",
  ". Basics of Flutter @override Widget build(BuildContext context) { return Row( children: [ Text(\"Alberto Miola\"), Text(\"Felix Angelov\"), Text(\"R\u00e9mi Rousselet\"), Text(\"Matej Re\u0161et\u00e1r\"), ] ); } } This widget doesn\u2019t need to change its state nor it depends on external data. It\u2019s just a single reusable \"block\". To sum it up, a StatelessWidget is good when you have to make independent \"reusable\" widgets or when you don\u2019t need to change the state of your widget. In all the other cases, consider using a StatefulWidget. ..3 Keys You might have noticed that any widget provided by Flutter has the optional key parameter. Very simply, it\u2019s used to uniquely identify a widget in the tree, like when a primary key is assigned to a column of a relational database. There are mainly four types of keys (they\u2019re all sub-types of Key): \u2022 ValueKey<T>. Suppose you created a shopping list using a ListView and a series of Text widgets (with no duplicated strings). A key can be assigned in this way: final itemKey = ValueKey<String>(\"item-id-\"); // and then on the build method... Text( itemText, key: itemKey, ) Use a ValueKey when you have an object represented by an unique and constant value. Flutter Complete Reference 233",
  ". Basics of Flutter In this case, the String doesn\u2019t change and the list doesn\u2019t have duplicates so it\u2019s a good choice. It is the default type of key returned by Key: abstract class Key { const factory Key(String value) = ValueKey<String>; } \u2022 ObjectKey. Suppose you had a list of complex objects, such as List<Task> where Task is internally made up of other classes. final list = [ Task( owner: const OwnerData(...), date: \"...\", duration: const Duration(...), ) ] When you\u2019re not guaranteed that a single \ufb01eld is unique but a combination of multiple values is, go for an ObjectKey. In this case, we\u2019re sure that each Task is unique but some might have the same date for example. However, we know that there cannot be 2 tasks with the same owner/date/duration combination so the object itself is unique. \u2022 UniqueKey. This key is only equal to itself: there\u2019s only one across the entire app. Use an UniqueKey when there are no constant unique values (so no ValueKey) and no single combinations of values (so no ObjectKey). \u2022 GlobalKey. You will see it in action in chapter 19 as it\u2019s also used to work with input validation on form \ufb01elds. Generally, global keys are useful to keep in sync the state of multiple widgets. In practice, a ValueKey is used when a single value can uniquely represent an object (like an id). ObjectKey is good when there isn\u2019t a single unique value but a combination of properties (such as name, surname, birthday and \ufb01scal code) can be unique. In Flutter, we will see you\u2019ll need a GlobalKey. In any other case, go for a UniqueKey. Flutter Complete Reference 234",
  ". Basics of Flutter The bar at the bottom represents how many \ufb01elds combined together represent an unique entity. In general keys can safely be ignored because there are only a few cases in which they\u2019re useful (in fact key is optional). Here\u2019s when you might have the need to uniquely identify a widget with a Key: . In chapter 16 you\u2019ll see that a key can be useful while testing to easily identify a widget on the tree. Being it unique, Flutter can quickly reach the widget on the tree and obtain a reference to it. . Imagine you had two tabs having, in both pages, a scrollable list. You want to store the scroll position even when tabs are swiped so that the user doesn\u2019t have to start scrolling from the top every time. // Tab layout is covered in chapter 21 TabBarView( controller: tabController, children: [ ListView.builder( key: const PageStorageKey<String>(('list1'), itemBuilder: (context, index) {...}, ), ListView.builder( key: const PageStorageKey<String>(('list2'), Flutter Complete Reference 235",
  ". Basics of Flutter itemBuilder: (context, index) {...}, ), ] ) A PageStorageKey<T> (subclass of ValueKey<T>) is used to remember the scrolling position of a list when the page of a tab is changed. If you didn\u2019t use a PageStorageKey, the scroll position of the lists will be reset to 0 every time that a tab is changed (the position is not remembered by default). Keys are also useful when you want to swipe to dismiss an item from a list: you\u2019ll see and example later in ... Of course, you might decide to de\ufb01ne an unique key for any widget you create but it would be useless. .3 Rebuilds and optimization The framework traverses the widget tree very often. The build() method is called, for sure, the \ufb01rst time the UI is rendered. It will be called more than once during your app\u2019s lifetime but you can\u2019t predict how many times because lots of factors can trigger a re-build: \u2022 calling setState, \u2022 rotating the screen of the device, \u2022 awaiting the result of a future, \u2022 listening to incoming stream events. When we say \"the framework does many rebuilds\" we mean that the method build() of a speci\ufb01c widget is called more than once. Because of the structure of the widget tree, every children will be rebuilt as well because there must be consistency along the hierarchy. \u009f Flutter is very e\ufb03cient at traversing the widget tree and rebuilding the leaves. However, if you write bad code your app might su\ufb00er of performance issues or it won\u2019t always run at 60 fps (on average). Even if Flutter is very fast, you don\u2019t have to abuse of its e\ufb03ciency because your goal should always be: \"allow rebuilds of widgets only when it\u2019s really needed\". Let\u2019s see what can be done in order to write good code that doesn\u2019t waste time and memory. Flutter Complete Reference 236",
  ". Basics of Flutter ..1 const constructor You already know something from .. \"const constructors\" and now it\u2019s time to see why they\u2019re so useful in Flutter. Let\u2019s say you had this simple widget: class ExampleWidget extends StatelessWidget { const ExampleWidget(); @override Widget build(BuildContext context) {...} } Since there\u2019s a constant constructor de\ufb01ned for this class, you\u2019re allowed to create a constant list of widgets. Of course, it would have been the same if you used a Row or a Column: ListView( children: const [ ExampleWidget(), ExampleWidget(), ExampleWidget(), ExampleWidget(), ] ); If you mark a list with const by consequence every object inside it will also be constant. Flutter builds constant widgets one time only. Using const constructors on widgets is like caching them: once created, they will never be re-built again. \u009f It really makes sense! If the class is allowed to have a const constructor, then it\u2019s immutable. It will never change over the time so Flutter doesn\u2019t have to rebuild it more than once. A constant constructor on a big subtree can save a lot of compu- tational time. Try to use const constructors as much as possible because the build method of a constant widgets is executed only once (at the time of the creation). Any subsequent re-build will simply ignore every widget whose constructor have been marked with const. class ExampleWidget extends StatelessWidget { // No constant constructor Flutter Complete Reference 237",
  ". Basics of Flutter @override Widget build(BuildContext context) {.} } In this case there isn\u2019t a constant constructor and thus the widget cannot be inserted in the tree us- ing const ExampleWidget(). Stateful widgets can have a const constructor too of course: class Example extends StatefulWidget { const Example(); @override _ExampleState createState() => _ExampleState(); } Try to use constant constructors as much as possible but don\u2019t get obsessed with them because they can\u2019t be created in every situation. In certain cases, const constructors can cache very large subtrees and save much computational time! constant version not-constant version ListView( children: const [ ExampleWidget(), ExampleWidget(), ExampleWidget(), // ... + other 7 entries ] ); ListView( children: [ ExampleWidget(), ExampleWidget(), ExampleWidget(), // ... + other 7 entries ] ); The visual di\ufb00erence is minimal but the computational di\ufb00erence is big. If ExampleWidget had a very complex build() method, the performance gap would be even bigger. Without const, the entire list is unnecessarily rebuilt many times. ..2 Prefer widget composition over functions It\u2019s common knowledge that code duplication is bad and so you\u2019ll create very often reusable widgets. For example, many apps have a \"footer\" which includes icons and a bit of text about the copyrights. Flutter Complete Reference 238",
  ". Basics of Flutter class FooterWidget extends StatelessWidget { const FooterWidget(); @override Widget build(BuildContext context) { return Column( mainAxisSize: MainAxisSize.min, children: [ Row( mainAxisAlignment: MainAxisAlignment.spaceAround, children: const [ Icon(Icons.email), Icon(Icons.tablet_mac), ] ), const Text(\"Developed by X\"), ] ); } } We\u2019ve decided to make FooterWidget stateless because it\u2019s a reusable block of code that doesn\u2019t change its state and it\u2019s not in\ufb02uenced by external events. It lives on its own and it can be reused in many di\ufb00erent pages to show a footer at the bottom: \u2022 there is a constant constructor because the class has no mutable variables; \u2022 in Column we can\u2019t use children: const [...] because Row does not de\ufb01ne a constant constructor. Nevertheless, we can manually put const in the single child inside, where possible. That\u2019s how you should write widgets and the same concept applies if it were a stateful one, no di\ufb00erences. Instead, what you absolutely DON\u2019T have to do is this: Widget footerWidget(BuildContext context) => Column( mainAxisSize: MainAxisSize.min, children: [ Row( mainAxisAlignment: MainAxisAlignment.center, Flutter Complete Reference 239",
  ". Basics of Flutter children: const [ Icon(Icons.email), Icon(Icons.tablet_mac), Icon(Icons.tune) ] ), const Text(\"Developed by X\"), ] ); } It\u2019s a function returning the Column widget with its children: you should absolutely NEVER prefer functions over widgets because: \u2022 Functions of course doesn\u2019t have const constructors. \u2022 Flutter is forced to rebuild widgets returned by a function every time because it knows nothing about them (no BuildContext is provided). \u2022 Classes are leaves of the widget tree but functions aren\u2019t and thus there\u2019s no BuildContext available. Widgets can be cached thanks to const constructors; functions can NOT be cached and thus they\u2019re executed every time. You should (or actually... must!) always rely on reusable widgets rather than functions. .4 Architecture In this section we\u2019re giving a general overview of the architecture of the framework digging a bit more into the details. Flutter is divided into three layers (it\u2019s said to be a layered system) where each depends on the one below. Layers are made up of libraries written in di\ufb00erent languages. Flutter Complete Reference 240",
  ". Basics of Flutter The embedder is written in di\ufb00erent languages according with the platform in which Flutter has to run: Objective C++ for iOS / macOS, Java / C++ for Android and C++ for Linux / Windows. It\u2019s a native application that takes care of \"hosting\" your Flutter contents on the OS. When the app is started, the embedder provides a valid entrypoint, obtains threads for UI and rendering, starts the Flutter engine and much more. Flutter Complete Reference 241",
  ". Basics of Flutter \u009f The embedder is at the lowest layer and it directly interacts with the operating system providing entry points for access to services. The developer mostly works on the third layer and sometimes on the second, but never on the \ufb01rst. The engine is the heart of Flutter, it\u2019s mostly written in C++ and it\u2019s always packaged in the binary produced by the flutter build tool. It\u2019s a portable runtime for hosting Flutter application which includes core libraries for network I/O, \ufb01le, animations and graphics. The engine is exposed to the developer via import \"dart:ui\", which basically wraps C++ sources into Dart classes. For the web world, the situation is di\ufb00erent: The C++ engine is designed to work with the operating system but for the web Flutter has to Flutter Complete Reference 242",
  ". Basics of Flutter deal with a browser. For this reason, the approach has to be di\ufb00erent. Dart can be compiled to JavaScript thanks to the highly-optimized dart2js compiler so, by consequence, Flutter apps can be ported as well. There are 2 ways to deploy an application for the web: . HTML mode. Flutter uses HTML, CSS, JavaScript and Canvas. . WebGL mode. Flutter uses CanvasKit, which is Skia compiled to WebAssembly. For the web, there\u2019s no need for the Dart runtime because your Flutter app is compiled to JavaScript as we\u2019ve already said. The produced code is already mini\ufb01ed and it can be deployed to any server. At the time of publishing this book (September ), web support for Flutter is only available in the beta channel. \u009f In case you didn\u2019t know, WebAssembly is recognized 9 by the W3C as the 4th language to natively run on browsers along with HTML, CSS, and JavaScript. We- bAssembly can be both AOT and JIT compiled. ..1 Element and RenderObject You\u2019ve already seen that, to build the UI, the developer has to create a widget tree by nesting widgets one inside the other. In reality, Flutter doesn\u2019t only rely on widgets because internally there are two other kinds of trees maintained in parallel . Through this section, we\u2019re assuming that SomeText is just a simple widget showing some text. class MyWidget extends StatelessWidget { const MyWidget(); @override Widget build(BuildContext context) { return Container( decoration: BoxDecoration(), child: SomeText( text: \"Hello\" ), ); 9https://www.w3.org/TR/wasm-core-/ 10See \"The Layer Cake\" by Frederik Schweiger on Medium Flutter Complete Reference 243",
  ". Basics of Flutter } } When it\u2019s time to render, Flutter calls the build() method of the widget which might introduce some new widgets, in case of nesting. In our case, the widget tree will contain Container, SomeText plus some more you actually don\u2019t see. In fact, if you looked at the de\ufb01nition of a Container... if (decoration != null) current = DecoratedBox(decoration: decoration, child: current); ... you\u2019d notice that an instance of DecoratedBox is added under the hood if a decoration is given. For this reason, if you made a DevTools 11 inspection you\u2019d see more children than you actually inserted. It\u2019s because widgets might insert other widgets inside but you just don\u2019t see it; the tree actually looks like this: Some boxes are in grey to visualize the fact they haven\u2019t been added by you. Along with the widget tree, Flutter also builds in parallel the element tree and the render tree. They are created calling respectively createElement() and createRenderObject() on the widget being traversed. Note that createElement() is always called on widgets but createRenderObject() is only called on elements whose type is RenderObjectElement. So yes, at the end Flutter works with 3 trees. 11More on it in chapter 16 Flutter Complete Reference 244",
  ". Basics of Flutter An Element can hold a reference to a widget and the respective RenderObject. There are a lot of new things you\u2019ve never seen up to now so let\u2019s carefully analyze the trees to understand how Flutter really works. \u2022 Render tree. A RenderObject contains all the logic to render the corresponding widget and it\u2019s expensive to create. They take care of the layout, the constraints, hit testing and painting. The framework keeps them in memory as much as possible, changing their properties whenever there\u2019s a chance. They can be of many types: \u2013 RenderFlex \u2013 RenderParagraph \u2013 RenderBox ... During the build phase, the framework updates or creates a new type of RenderObject only when a RenderObjectElement is encountered in the element tree. \u2022 Element tree. An Element is the link between a Widget and its respective RenderObject so it holds references inside. Elements are very good at comparing items and looking for changes but they don\u2019t perform rendering. They can be of two types: \u2013 ComponentElement. An element that contains other elements. It\u2019s associated to a widget that can nest other widgets inside. abstract class ComponentElement extends Element { ... } Flutter Complete Reference 245",
  ". Basics of Flutter \u2013 RenderObjectElement. An element that takes part in painting, layout and hit testing phases. abstract class RenderObjectElement extends Element { ... } The element tree is basically a series of ComponentElement or RenderObjectElement, de- pending on the widget they refer to. In our example, a Container is a ComponentElement because it can host other widgets inside. \u2022 Widget tree. It\u2019s made up of classes extending StatelessWidget or StatefulWidget. They\u2019re used by the developer to build the UI and are not expensive to be created (much less than a RenderObject). Whenever the widget tree is changed (by a state management library for example), Flutter uses the element tree to make a comparison between the new widget tree and the render tree. An Element is a \"middle way\" between a Widget and a RenderObject used to make quick comparisons needed to keep the trees updated. . A Widget is \"light\" and it\u2019s instantiated quickly so frequent rebuilds aren\u2019t a problem at all. Widgets are all immutable and that\u2019s why the state of a StatefulWidget is implemented in another separated class. A stateful widget itself is immutable but the state it returns can mutate. class Example extends StatefulWidget { const Example(); @override _ExampleState createState() => _ExampleState(); } class _ExampleState extends State<Example> { @override Widget build(BuildContext context) { ... } } The widget itself (Example) is immutable and so its mutable state (_ExampleState) is implemented in another class. A StatelessWidget is immutable as well. . A RenderObject is relatively \"expensive\" and it takes time to instantiate so it\u2019s recreated only when really needed. Most of the times they\u2019re internally modi\ufb01ed (reusability is the key). Flutter Complete Reference 246",
  ". Basics of Flutter For each rebuild, Flutter traverses the entire tree looking for changes on widgets. If the type of the Widget changed, then it\u2019d be removed and replaced together with its associated Element and RenderObject. All the 3 subtrees would also be recreated. If the Widget were of the same type and just some properties changed, the Element would stay untouched and the RenderObject would be updated (and not recreated). Let\u2019s see an example: Widget build(BuildContext context) { return Container( decoration: BoxDecoration(), child: SomeText( text: \"Hello\" ), ); } This is what we had earlier. Of course, on the \ufb01rst build the 3 trees are entirely created but from now on, the framework will try to recreate the render tree as less as possible. Let\u2019s say our state management library changed the text of SomeText. Widget build(BuildContext context) { return Container( decoration: BoxDecoration(), child: SomeText( text: \"Hello world!\" ), ); } When a rebuild happens, thanks to the element tree, Flutter notices that the type is still the same (SomeText) but an internal property (text) has changed. By consequence, the associated RenderObject just needs an update, which is cheap. Flutter Complete Reference 247",
  ". Basics of Flutter This process is very fast because the RenderObject is not recreated but it\u2019s just modi\ufb01ed. Widgets and elements are also quick to update so this is a good situation. Let\u2019s now say that our library replaces SomeText with Flutter\u2019s Text widget. Widget build(BuildContext context) { return Container( decoration: BoxDecoration(), child: Text(\"Hello world!\"), ); } While traversing the tree, the framework notices again the change thanks to the element tree. In particular, this time the type of the widget is completely di\ufb00erent so there\u2019s the need to rebuild the entire subtrees (widgets, elements and renders). Flutter Complete Reference 248",
  ". Basics of Flutter The associated RenderObject is not updated: it has to be entirely recreated because the wid- get has a di\ufb00erent type and thus there\u2019s no way to reuse the old instance. In summary, Flutter relies on 3 trees to e\ufb03ciently handle the rendering and tries to reuse RenderObjects as much as possible. Thanks to Elements, the framework knows when something has changed on Widgets. \u009f The BuildContext parameter you see in any build() method basically represents the Element associated to the widgets. In reality, BuildContext objects are Element objects. The Flutter team created BuildContext to avoid the direct interaction with Element, which should be used by the framework and not by you. The render tree is the one that actually takes care of painting elements to the UI. The widget tree is manually built by you, the developer. The element tree is maintained by the framework to decide whether it\u2019s time to update or recreate a RenderObject. ..2 Foreign Function Interface Thanks to the dart:ffi library, also known as Foreign Function Interface, your Dart code can directly bind to native APIs written in C. FFI is very fast because there\u2019s no serialization required to pass data since calls are made to dynamically or statically linked libraries. Here\u2019s a an example: // demo.h void print_demo() {}; Flutter Complete Reference 249",
  ". Basics of Flutter // demo.c #include <stdio.h> #include \"demo.h\" void print_demo() { printf(\"Dart FFI demo!\"); } int main() { print_demo(); return ; } We\u2019re going to call void print_demo() written in C inside a Dart app thanks to FFI. To keep the example simple, we assume that every \ufb01le is in the same folder and the following Dart code is all inside main.dart. Let\u2019s start with the fundamentals: import \"dart:ffi\" as FFI; // Signature of the function in C typedef print_demo_c = FFI.Void Function(); // Signature of the function in Dart typedef PrintDemo = void Function(); The \ufb01rst typedef uses FFI to represent the signature of the C function we\u2019re going to call. It\u2019s basically used to represent the C function into its Dart counterpart, identi\ufb01ed by PrintDemo. Of course, you have to declare two typedef whose signatures match. import \"dart:ffi\" as FFI; typedef print_demo_c = FFI.Void Function(); typedef PrintDemo = void Function(); void main() { // Open the library final path = \"demo_lib.dll\"; // On Windows final lib = FFI.DynamicLibrary.open(path); // Create a \"link\" from C to Dart Flutter Complete Reference 250",
  ". Basics of Flutter final PrintDemo demo = lib .lookup<FFI.NativeFunction<print_demo_c>>('print_demo') .asFunction(); // Call the function demo(); } In general, when working with FFI you always have to create two typedef: one for the \"C side\" and the other for the \"Dart side\". When building the C code, various \ufb01les are created but you\u2019re only interested in the one with the following extension: .dll on Windows, .so on Linux and .dylib on macOS. On Windows, be sure that your compiler properly exports to the DLL the functions Dart has to use. int sum(int a, int b) { return a + b; } The above code can easily be used by Dart in the same way we did earlier in the demo function. Inside dart:ffi you\u2019ll \ufb01nd many types representing the C primitive ones, such as Int32, Double, UInt32, Handle and much more. typedef sum_c = FFI.Int32 Function(FFI.Int32 a, FFI.Int32 b); typedef Sum = int Function(int a, int b); Check out the o\ufb03cial documentation 12 for some nice examples on how to interact with structs, strings and SQLite databases. ..3 Method channels Available only for mobile and desktop, method channels allow Dart to call platform-speci\ufb01c code of your hosting app. Data are serialized from Dart and then deserialized in Java, Kotlin, Swift or Objective-C. Look how easy it is: const channel = MethodChannel(\"person\"); final name = await channel.invokeMethod<String>(\"getPersonName\"); print(name); // 'name' is a regular Dart string As example, let\u2019s say the above code is going to call the getPersonName(): String function declared in a native Android app written in Kotlin. There\u2019s a similar setup to do in the native 12https://api.dart.dev/stable/../dart-\ufb03/dart-\ufb03-library.html Flutter Complete Reference 251",
  ". Basics of Flutter part as well but it\u2019s very simple to understand: // Initialization val channel = MethodChannel(flutterView, \"person\") channel.setMethodCallHandler {call, result -> when (call.method) { \"getPersonName\" -> result.success(getPersonName()) else -> result.notImplemented() } } // This function is defined somewhere fun getPersonName(): String { return \"Alberto\" } In both cases, the MethodChannel instance has to be created with the same name (\"person\") oth- erwise the \"link\" between Dart and Kotlin won\u2019t work. The name of the function matches the ac- tual name on the native side just for convenience but it\u2019s not required. With invokeMethod<T>() you can also pass parameters in case the function were asking for some. For example, if you called this in Dart... const channel = MethodChannel(\"random\"); final random = await channel.invokeMethod<int>(\"getRandom\", ); ... it would mean that you\u2019re expecting a method on the native language called getRandom asking for a single integer parameter. This example instead is written in Swift but the logic is always the same (just a di\ufb00erent syntax): // Initialization let chl = FlutterMethodChannel(name: \"random\", binaryMessenger: flutterView) chl.setMethodCallHandler { (call: FlutterMethodCall, result: FlutterResult) -> Void in switch (call.method) { case \"getRandom\": result(getRandom(call.arguments as! Int)) default: result(FlutterMethodNotImplemented) } } // This function is defined somewhere Flutter Complete Reference 252",
  ". Basics of Flutter func getRandom(value: Int) -> Int { return Int.random(in: ...value); } Thanks to call.arguments you access the argument passed via method channel which could be, for example, a primitive type or a map. A MethodChannel is a common interface for both Dart and the other native language that allows Flutter to send/receive messages. This is a scheme of how method channels are implemented: In the native code, method channels must be called in the main thread and not in a background Flutter Complete Reference 253",
  ". Basics of Flutter one (in Android, the \"main\" thread is actually called UI thread). To sum up, the communication \ufb02ow works like this: . Flutter sends a message to the iOS or Android part of the app using a method channel; . the underlying system listens on the method channel and so the message is received; . one or more platform-speci\ufb01c APIs are called, using the native programming language; . a response is sent back to the client (Flutter) which processes the result. You can\u2019t do the same with FFI because there are no libraries to be linked and data need seri- alization/deserialization: method channels work di\ufb00erently and require a native implementation as well. Flutter Complete Reference   | Building UIs in Flutter Flutter allows the developer to completely customize the UI: you have control over each single pixel of the screen. Layouts can be created from scratch but for common use-cases there are a series of built-in widgets that are going to save hours of work. .1 Material Flutter gives you a series of pre-built components to create apps embracing the typical Android design, also known as Material Design. It\u2019s very likely you\u2019ve already seen this kind of UI appearance somewhere, in landscape mode: Flutter Complete Reference 255",
  ". Building UIs in Flutter This is a classic example of material design with a Floating Action Button (FAB) on the bottom right and an app bar at the top. There are two possible ways to create the above material layout: \u2022 Not recommended. Create the entire layout from scratch using stateless and stateful widgets. Actually there\u2019d be quite a lot of work to do because you\u2019ll have to deal with screen dimensions, positioning, buttons and so on. \u2022 Recommended. Import the material.dart package and use the MaterialApp() widget provided by Flutter. It represents the \"skeleton\" of a UI following the material design guidelines ; it\u2019s very convenient: Widget build(BuildContext context) { return MaterialApp( home: Scaffold( appBar: AppBar( title: const Text(\"Flutter\"), actions: const [ Padding( padding: EdgeInsets.only(right: ), child: Icon(Icons.info), ) ] ), drawer: const Drawer(), body: const Center( child: Text(\"Wow nice book\"), ), floatingActionButton: FloatingActionButton( onPressed: () {}, child: const Icon(Icons.add), ), ), ); } } The big advantage is that you don\u2019t have to write thousands of lines of code trying to 1https://material.io/design/guidelines-overview/ Flutter Complete Reference 256",
  ". Building UIs in Flutter emulate the material design aspect. Flutter already gives you everything you need and with MaterialApp you\u2019re guaranteed to create a beautiful material app. The constructor of class MaterialApp(...) has many interesting parameters we will cover later in the book, such as the ones for setup pages navigation and localization. We\u2019re now giving you a showcase of the most relevant material widgets. ..1 Sca\ufb00old As you\u2019ve seen in the preceding code snippet, class Scaffold(...) implements the basic ma- terial design layout structure for you. Other than providing the typical Android \"look-and-feel\" it gives the possibility to handle many other widgets: \u2022 AppBar. It\u2019s always placed at the top of the screen and it\u2019s the Java/Kotlin equivalent of the Toolbar class. If the Scaffold had a drawer, an hamburger button would automatically be added to handle the opening/closing of the menu. While navigating back and forth between your app\u2019s pages (or routes, in the Flutter world) the AppBar automatically adds a \"back\" button, the typical left arrow. Scaffold( appBar: AppBar( // Set this to false if you don't want the // back button to automatically appear next // to the title while navigating among pages automaticallyImplyLeading: false, // Title title: const Text(\"App Bar without Back Button\"), ) ) Flutter Complete Reference 257",
  ". Building UIs in Flutter Buttons on the right are called action buttons and they can be set by passing a list of widgets to the actions named parameter. In general, actions are clickable icons that visually represent what\u2019s the purpose of that button. Scaffold( appBar: AppBar( actions: [ IconButton( icon: const Icon(Icons.info), onPressed: () {...} ), ] ) ) \u2022 Drawer. A drawer is a container that horizontally slides from a side of the screen to show a series of items. In general it\u2019s used to display a combination of icons and texts that route the user to speci\ufb01c pages of the app. Flutter Complete Reference 258",
  ". Building UIs in Flutter By default a drawer slides from the left to the right but you can also create an endDrawer which slides in the opposite direction, from right to left. It\u2019s still the same Drawer() class but it\u2019s assigned to another constructor named parameter. Scaffold( // The 'classic' left to right drawer drawer: Drawer( child: ListView( ListTile( leading: const Icon(Icons.people), title: const Text(\"Item \"), onTap: () {}, ), ListTile( leading: const Icon(Icons.train), title: const Text(\"Item \"), onTap: () {}, ) ) ), // The same as before but this slides // from the right to the left endDrawer: Drawer() ) \u2022 Floating Action Button. Also known as FAB, it is a special rounded button with elevation that usually appears on the bottom-right corner of the screen. By using a \ufb02oat- ingActionButtonLocation you can decide the position of the widget: Scaffold( floatingActionButton: FloatingActionButton( child: const Icon(Icons.add), backgroundColor: Colors.red, onPressed: () {...}, ), ) This snippet adds a FAB to the default position of the screen (bottom-right): Flutter Complete Reference 259",
  ". Building UIs in Flutter Do you want to have it at the center rather than on the right? There are many positions available you can use: floatingActionButton: FloatingActionButton( child: const Icon(Icons.add), backgroundColor: Colors.red, onPressed: () {}, ), floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat, A Scaffold can only have a single FAB. The Scaffold widget is for sure very important as it\u2019s the base building block for material user interfaces and probably you\u2019ll use it very often. In the third part of the book you\u2019ll see many examples highlighting the strength of this widget.  ..2 Material widgets Flutter provides a very big collection of widgets that follow the o\ufb03cial material guidelines. The Flutter team constantly improves them and adds new ones as time goes by. We\u2019re not going to make a full list of every kind of widget because you\u2019ll encounter them in the practical examples of Part III. 2https://api.\ufb02utter.dev/\ufb02utter/material/Sca\ufb00old-class.html Flutter Complete Reference 260",
  ". Building UIs in Flutter ...1 Buttons Buttons are fundamental in any kind of app because they\u2019re the most intuitive way to tell the user that, when pressed, something is going to happen. Flutter has many material widgets created to follow material guidelines for buttons. \u2022 RaisedButton. This is a typical Android button with a rectangular shape and a default elevation (the shadow behind). When hovered the elevation increases so that you can visually see the interaction with the button. \u2022 FlatButton. It\u2019s very similar to a RaisedButton with the di\ufb00erence that here there is no elevation and nothing happens visually when you tap on it. It\u2019s like a \"static\" version of a RaisedButton. \u2022 ButtonBar. It\u2019s an horizontal container holding a series of button. It can be useful in those cases where you have a dialog and you want to show two buttons like NO and YES. ButtonBar( alignment: MainAxisAlignment.center, Flutter Complete Reference 261",
  ". Building UIs in Flutter children: [ FlatButton( onPressed: () {}, child: const Text(\"No\") ), RaisedButton( onPressed: () {}, child: const Text(\"YES\") ), ], ); \u2022 IconButton. You\u2019ve already seen an example in the AppBar as they make icons clickable; it\u2019s a button whose content is a material Icon rather than a plain string. ...2 Dialogs The most common type of dialog is the one that asks you for the con\ufb01rmation or rejection of an action; this kind of widget is well-known as AlertDialog. You have to use the showDialog(...) method to make it appear on the screen. showDialog<void>( context: context, builder: (BuildContext context) { return AlertDialog( title: const Text(\"Example\"), content: const Text(\"Do you like this book?\"), actions: [ FlatButton( child: const Text(\"Yes\"), onPressed: () {}, ), FlatButton( child: const Text(\"Sure\"), onPressed: () {}, ) Flutter Complete Reference 262",
  ". Building UIs in Flutter ] ); } ); By default a dialog can be closed just by tapping outside of the white area of the box. If you don\u2019t want this behavior, just set barrierDismissible: false and the dialog will disappear only if a button is pressed. Of course you can fully customize the dialog as much as you want because the content parameter can be any widget such as an image. You could use icons or raised buttons instead of the \ufb02at ones. You could even change the borders of the dialog. It\u2019s just a matter of using RoundedRectangleBorder and Flutter will take care of everything Flutter Complete Reference 263",
  ". Building UIs in Flutter else. showDialog<void>( context: context, builder: (BuildContext context) { return AlertDialog( title: const Text(\"Example\"), content: const Text(\"Do you like this book?\"), actions: [...], shape: RoundedRectangleBorder( borderRadius: BorderRadius.circular(), ) ); } ); If you want the dialog to look like a circle, use instead CircleBorder as border shape. In order to close a dialog there\u2019s the need to use class Navigator {} which will be fully covered in chapter . AlertDialog( actions: [ FlatButton( child: const Text(\"Close\"), onPressed: () => Navigator.pop(context), ), ] ); There are also other kinds of dialogs you could use in your applications: \u2022 SimpleDialog. This is a simple dialog in which the user can choose between a series of options. The selected value will be asynchronously returned by T showDialog<T>(). final type = await showDialog<String>( context: context, builder: (BuildContext context) { return SimpleDialog( title: const Text(\"Cake flavor?\"), children: [ Flutter Complete Reference 264",
  ". Building UIs in Flutter SimpleDialogOption( onPressed: () => Navigator.pop(context, \"chocolate\"), child: const Text(\"Chocolate\"), ), SimpleDialogOption( onPressed: () => Navigator.pop(context, \"apple\"), child: const Text(\"Apple\"), ), ] ); } ); Very shortly, the Navigator class is used to navigate between routes (your app\u2019s pages) and close alert dialogs (which are routes too). The pop() method removes the currently visible route from the screen and thus the alert disappears. As always, this is fully customisable because instead of a boring plain text you could have put any widget such as images or a coloured text with a fancy font. \u2022 showBottomSheet. This method animates a dialog that slides from the bottom of the Flutter Complete Reference 265",
  ". Building UIs in Flutter screen up to a certain height, which is determined by the size of the contained widget. In general it\u2019s a good idea having a Container as \"base\" child which has an easy setup for height, shape and colors. showBottomSheet<String>( context: context, builder: (BuildContext context) { return Container( color: Colors.blueAccent, height: , child: const Center( child: Text( \"BottomSheet\", style: TextStyle( color: Colors.white, ) ) ), ); } ); The result of this code is a blue stripe at the bottom of the screen which slides up and shows its content. Calling Navigator.pop(context); closes the dialog which slides down until it disappears. .2 Cupertino The CupertinoApp widget is the Apple counterpart of MaterialApp as it focuses on the typical iOS design. It\u2019s a series of pre-built components that allow you to create applications that follow the typical iOS UI style. Flutter Complete Reference 266",
  ". Building UIs in Flutter The same recommendations we made for material also apply here. You could create an iOS theme from scratch but it would require a lot of time and testing; it\u2019s not worth the e\ufb00ort because you can use Flutter\u2019s cupertino components. Widget build(BuildContext context) { return CupertinoApp( home: const CupertinoPageScaffold( navigationBar: CupertinoNavigationBar( middle: Text(\"Cupertino App\"), ), child: Center( child: Text(\"Cupertino theme!\"), ), ), ); } The constructor of class CupertinoApp() has many interesting parameters we will cover later in the book, such as the ones to setup page navigation and localization. We\u2019re now giving you a showcase of the most relevant cupertino widgets. Flutter Complete Reference 267",
  ". Building UIs in Flutter ..1 CupertinoPageSca\ufb00old There are two main kind of sca\ufb00olds in the cupertino library: the CupertinoPageScaffold, which has a navigation bar at the top, and the CupertinoTabScaffold, which uses tabs to display contents. CupertinoApp( home: const CupertinoPageScaffold( // It's a \"plain\" bar with the title and some icons navigationBar: CupertinoNavigationBar( middle: Text(\"Page title\"), trailing: Icon(CupertinoIcons.info), ), child: Center( child: Text(\"Body of the app\") ) ), ); The CupertinoTabBar widget instead implements the tab navigation pattern in a typical iOS style. It allows multiple pages to be shown in a single view by tapping on the icons at the bottom but there\u2019s no swipe gesture enabled. The onTap callback is triggered when the user taps on an icon: The only required widget is the icon but the text that lies underneath can be omitted if it\u2019s not needed. Visit the o\ufb03cial documentation 3 to see any custom parameter that can be set for this widget. CupertinoTabScaffold( 3https://api.\ufb02utter.dev/\ufb02utter/cupertino/CupertinoTabBar-class.html Flutter Complete Reference 268",
  ". Building UIs in Flutter tabBar: CupertinoTabBar( onTap: (index) {...}, activeColor: Colors.blue, items: const [ BottomNavigationBarItem( icon: Icon(Icons.home), title: Text(\"Home\"), ), BottomNavigationBarItem( icon: Icon(Icons.email), title: Text(\"E-mail\"), ), ], ), tabBuilder: (context, index) {...} ), Once icons have been de\ufb01ned via items, the tabBuilder parameter de\ufb01nes which pages have to be shown when an item is tapped. When the tab becomes inactive, its content is automatically cached in the widget tree for better reusability in subsequent calls. CupertinoTabScaffold( tabBar: CupertinoTabBar(...) tabBuilder: (context, index) => CupertinoTabView( builder: (context) { switch (index) { case : return const PageOneWidget(); case : default: return const PageTwoWidget(); } }, ), ), In general, CupertinoTabScaffold should be your \ufb01rst choice when a tabbed layout is required for your UI; if it\u2019s not the case, go for CupertinoPageScaffold which is basically a \"plain\" iOS Flutter Complete Reference 269",
  ". Building UIs in Flutter page. ..2 Cupertino widgets Flutter provides a very big collection of widgets that follow the iOS design guidelines. At the time of writing this book, the cupertino library has less widgets than material but the Flutter team has stated in their roadmap 4 that the collection is going to grow over the time. \u2022 CupertinoAlertDialog. An iOS alert dialog that noti\ufb01es the user and requires an action, de\ufb01ned by buttons. Typ- ically an instance of CupertinoAlertDialog is passed as child widget to showDialog(), which displays the dialog. showDialog<void>( context: context, builder: (context) { return CupertinoAlertDialog( title: const Text(\"Cupertino Alert\"), content: const Text(\"iOS alert dialog\"), actions: <Widget>[ CupertinoButton( child: const Text(\"Ok\"), onPressed: () => Navigator.pop(context), ) 4https://github.com/\ufb02utter/\ufb02utter/wiki/Roadmap Flutter Complete Reference 270",
  ". Building UIs in Flutter ], ); } ), Generally iOS dialog buttons are red, in case of a deletion action, or in old blue, in case of a default option. Rather than using a CupertinoButton, a CupertinoDialogAction would be better: CupertinoAlertDialog( actions: <Widget>[ CupertinoDialogAction( isDefaultAction: true, child: const Text(\"Ignore\"), onPressed: () {...}, ), CupertinoDialogAction( isDestructiveAction: true, child: const Text(\"Delete\"), onPressed: () {...}, ), ], ); isDestructiveAction: true makes the text red while isDefaultAction: true makes it blue. \u2022 CupertinoButton. It\u2019s a typical \ufb02at iOS button which has no background color by default but of course it can be set via color property. When tapped, the onPressed callback is triggered. CupertinoButton( child: const Text(\"iOS Button\", style: TextStyle( Flutter Complete Reference 271",
  ". Building UIs in Flutter color: CupertinoColors.white ), ), color: CupertinoColors.activeBlue, onPressed: () {...}, ), The cupertino library has less widgets than material because an iOS button style has less \"vari- ants\" than the Android counterpart but still it\u2019s fully customizable. Be sure to check the cupertino catalog 5 in the o\ufb03cial Flutter documentation. .3 Building layouts ..1 Platform support You have just seen that the framework has a lot of useful pre-built components you can use to create beautiful UIs. Before starting the development you have to think about what the end user needs and how many platforms you have to support at the same time. At the time of writing this book, Flutter is at production quality only for mobile devices. Web support is in beta while desktop support is still in early alpha. Nevertheless, it\u2019s just a matter of time because in the future Flutter will target any platform. For this reason, your apps should adopt to various screen sizes and input types. ...1 Single OS The simplest case is the one in which you have to create an application that is going to run exclusively on Android or iOS, not in both. If the structure of the app is fairly \"standard\", Material or Cupertino widgets are enough to do the work. To be more precise, saying \"standard\" in the Android world refers to the fact of having at least: \u2022 a horizontal bar at the top with the title and maybe a series of buttons; 5https://\ufb02utter.dev/docs/development/ui/widgets/cupertino Flutter Complete Reference 272",
  ". Building UIs in Flutter \u2022 a menu sliding from the right/left of the screen (a Drawer); \u2022 probably a FAB or a layout with swipeable tabs. A Scaffold helps you to easily create a layout with the above characteristics but if you want to have a completely di\ufb00erent structure or something very particular, don\u2019t use it. Look at these two examples: Both are Android apps and you can immediately see that the one on the left is very close to a \"traditional\" material app: it has a drawer, and app bar, icons and a swipeable tab on the bottom. Flutter Complete Reference 273",
  ". Building UIs in Flutter \u009f The example on the right would be impossible to realize with a Scaffold because it has a completely di\ufb00erent structure from the one that a Scaffold proposes, so in this case you\u2019d have to create everything from scratch. The thing is: don\u2019t use the material library when your app\u2019s design has nothing to do with ma- terial guidelines. If the layout is very particular, it\u2019d be better if you created it from scratch and it\u2019s perfectly doable in Flutter. Don\u2019t force yourself using Flutter\u2019s material/cupertino libraries because they aren\u2019t always the right choice for the UI you\u2019re going to implement. \u009f Of course the same recommendations also appliy to the cupertino library. If your iOS app is going to look quite di\ufb00erent to what is a \"standard\" iOS design, go for a complete custom UI and don\u2019t rely on cupertino. ...2 Multiple OSes This is the hardest case and probably the most common because, in general, companies want their app to be available for both Android and iOS. Here\u2019s where cross-platform tools, such as Flutter, come to the rescue. As always, they can become your enemy if misused but we have some recommendations for you. \u009f In the following paragraphs, let\u2019s pretend that you\u2019re asked to create an app for a restaurant with the possibility to make a reservation, see the menu and a gallery of images. UI consistency is very important: the app should look exactly the same in any OS it\u2019s running on. Surely your customer will ask not only for the same design, but also for identical functionalities. This is what we suggest: \u2022 DO NOT use material and cupertino to create two di\ufb00erent versions for the same app. For example, doing this is absolutely wrong: // Contains 'TargetPlatform' import 'dart:io' show Platform; void main() { Flutter Complete Reference 274",
  ". Building UIs in Flutter if (Platform.isAndroid) { runApp(const AndroidVersion()); } else { runApp(const iOSVersion()); } } // Uses MaterialApp class AndroidVersion extends StatelessWidget {} // Uses CupertinoApp class iOSVersion extends StatelessWidget {} With this approach, you\u2019re forced to keep 2 separate versions of the same app and all the advantages of cross-platform development are gone. This is the same as having two separated native projects in Java/Kotlin and Objective-C/Swift! \u2022 DO create an nice UI for both operating systems so that you can write the code only once. Even if this might seem obvious, it\u2019s still worth saying rather then taking it for granted. Flutter is made for this purpose. import 'dart:io' show Platform; void main() => runApp(RestaurantApp()); class RestaurantApp extends StatelessWidget { const RestaurantApp(); // Depending on the platform, return a different logo String _logoName() { if (Platform.isIOS) { return \"Welcome iOS user!\"; } return \"Welcome Android user!\"; } Widget build(BuildContext context) {...} } In this example, the same single codebase works for both Android and iOS. Certain settings Flutter Complete Reference 275",
  ". Building UIs in Flutter may di\ufb00er according to the OS type but it\u2019s \ufb01ne since there\u2019s still a single project being maintained. You should try as much as possible to not depend on OS-speci\ufb01c settings or con\ufb01gurations; always try, when possible, to make your architecture working \ufb01ne regardless the OS on which it runs. Writing robust cross-platform applications is not easy but Flutter gives you a great boost in the correct direction! ..2 Responsive UIs High quality apps are responsive because they automatically adapt to the size of the screen by rearranging the UI in order to properly \ufb01ll all the available space. Just think of an orientation changing in your mobile phone for example: the horizontal space increases/decreases and your UI should adapt by consequence. Lists are a common UI element and in fact ListView is a very popular Flutter widget. In the above picture you can see a scrollable list with a series of items. It looks good as it is but if we rotated the screen the situation would change: Flutter Complete Reference 276",
  ". Building UIs in Flutter Now there is a lot of free space on the right and there are only two fully visible items; the user has to scroll a lot more than before. In such cases, a good responsive UI rearranges its contents in order to cover all the available space. \u009f This problem is not only tied to the screen rotation case. If your app runs on both mobile phones and tablets (which is very likely) there are big size di\ufb00erences on the screens and your UI should be \ufb02exible enough to look well in any case. More in general, if you plan to run your Flutter app on mobile devices, desktop and web there will be huge screen size di\ufb00erences. You really need to take this into account and create the UI by consequence. ...1 LayoutBuilder Considering the above example of a simple list with items, the code is pretty simple at the moment. The ListView is always used in the vertical direction without taking into account the orientation of the screen. As we\u2019ve seen, this is not a responsive usage at all: Scaffold( body: ListView.builder( itemCount: , itemBuilder: (context, id) { return ListTile( leading: const Icon(Icons.add_box), title: Text(\"Item $id\"), ); } Flutter Complete Reference 277",
  ". Building UIs in Flutter ) ), The LayoutBuilder widget gives information about the constraints of the parent such as the width and the height. Really consider using this class to make your apps responsive because it can be used to decide how to arrange the UI according to the available space. Scaffold( body: LayoutBuilder( builder: (BuildContext context, BoxConstraints sizes) { if (sizes.maxWidth < ) { return const ListData(); } return const GridData(); } ) ) The BoxConstraints class gives a series of information about the size of the parent widget. In this case, we\u2019re using it to decide the following: if the width is lower than 500 a list is good, otherwise it\u2019s better rearranging in a grid to \ufb01ll the space in a better way. class ListData extends StatelessWidget { const ListData(); @override Widget build(BuildContext context) { return ListView.builder( itemCount: , itemBuilder: (context, id) { return ListTile( leading: const Icon(Icons.add_box), title: Text(\"Item $id\"), ); } ); } } class GridData extends StatelessWidget { Flutter Complete Reference 278",
  ". Building UIs in Flutter const GridData(); @override Widget build(BuildContext context) { return GridView.count( crossAxisCount: , children: List.generate(, (index) { return Center( child: ListTile( leading: const Icon(Icons.add_box), title: Text(\"Item $index\"), ); ); } ); } } The Grid widget automatically places elements in a grid and the number of columns is determined by the value passed to crossAxisCount. This code is said to be responsive because when the width of the screen changes, thanks to LayoutBuilder, the UI is rearranged accordingly. If you opened your app in a tablet, which has a very wide screen, you\u2019ll already see the grid instead of the list. LayoutBuilder is good for screen rotations and much more; you can (and should) use it to adapt the UI to the dimensions of many devices such as mobile phones, tablets Flutter Complete Reference 279",
  ". Building UIs in Flutter and desktop. ...2 MediaQuery The MediaQuery class is a sort of more powerful version of LayoutBuilder because it\u2019s always available and it gives you more control over various settings of the screen. It just requires a context: @override Widget build(BuildContext context) { // We're using 'double.nan' but it could have been any other value final width = MediaQuery.of(context)?.size.width ?? double.nan; return Text(\"$width\"); } With size you also have access to height, padding, distances and much more. You can handle the nullable value returned by of() with a default value (like we did) of with an null check (an if statement). For example, you might want to know which is the current orientation of the device: final orientation = MediaQuery.of(context)?.orientation; // Using a null check rather than providing a default value if ((orientation != null) && (orientation == Orientation.portrait)) {...} ...3 Good practices High quality applications are responsive and so we strongly encourage you to not test your app only on a mobile device locked in portrait mode. Do a lot of tests with di\ufb00erent screen sizes in both portrait and landscape mode. Other than this, here are a few tips you can try: \u2022 If you have to make your app responsive, avoid using MediaQuery.of(context) to calculate the spaces and the dimensions. It holds a lot of metadata about the physical screen but it knows nothing about the widget itself. \u2022 Use LayoutBuilder to make responsive layouts as it provides dimensions about the con- taining widget and NOT about the screen itself, like MediaQuery does. This example might give a better idea of the di\ufb00erence between the two approaches. // . Widget build(BuildContext context) { final width = MediaQuery.of(context)?.size.width ?? ; Flutter Complete Reference 280",
  ". Building UIs in Flutter return Text(\"$width\"); } // . Widget build(BuildContext context) { return LayoutBuilder( builder: (context, constraints) { return Text(\"${constraints.maxWidth}\"); } ); } To get the most out of this example, put this build method in the root widget of your tree. You\u2019ll see that both cases 1 and 2 will print the same size because: \u2013 MediaQuery returns the width of the screen \u2013 LayoutBuilder returns the width of the parent widget but, being it the root, it takes the entire size of the screen. Now try to run this example which is a little di\ufb00erent: // . Widget build(BuildContext context) { final width = MediaQuery.of(context)?.size.width ?? ; return Padding( padding: EdgeInsets.all(), child: Text(\"$width\"), ); } // . Widget build(BuildContext context) { return Padding( padding: EdgeInsets.all(), child: LayoutBuilder( builder: (context, constraints) { return Text(\"${constraints.maxWidth}\"); } ) Flutter Complete Reference 281",
  ". Building UIs in Flutter ); } Here there\u2019s the important di\ufb00erence between the two widgets. MediaQuery still returns the same value, because the width of the screen hasn\u2019t changed, but LayoutBuilder returns a di\ufb00erent size which is 30 units smaller than before. \u2013 LayoutBuilder takes into account the fact that there is a padding and the returned dimension is screenSize - paddingAmount, which is the available space. \u2013 MediaQuery will always return the same value because the device\u2019s screen width didn\u2019t change. It doesn\u2019t consider the padding. You really should not use MediaQuery as it\u2019s just the \"measures\" of the device; use LayoutBuilder instead which calculates the actual remaining space by considering the dimensions of other widgets that contain it. As we\u2019ve already seen, use MediaQuery.orientation if you only need to know whether the device is in landscape mode or not . Be aware that there is also the OrientationBuilder widget: OrientationBuilder( builder: (context, orientation) { if (orientation == Orientation.portrait) { //work in portrait mode } else { //work in landscape mode } } ); Pay attention to the fact that OrientationBuilder depends on the parent widget\u2019s orientation, which is not the device orientation. For example, if your device were in portrait mode and you opened the keyboard to \ufb01ll a form, the height might become smaller than the width and thus OrientationBuilder would return landscape. . Use MediaQuery to get the current orientation of the device. In practice it\u2019s the physical position (horizontal or vertical) of the mobile phone or tablet, . Use OrientationBuilder to get the current orientation according to the parent widget\u2019s orientation. It\u2019s not based on the orientation of your physical device but it relies on the dimensions of the containing widget (whether the height is smaller or greater than the height). Flutter Complete Reference 282",
  ". Building UIs in Flutter ..3 Scrolling and constraints Both ListViews and Columns are very popular but you have to pay attention to how they treat the contents in the vertical axis. This code seems to work as intended but it will throw a runtime exception because the height of the column is in\ufb01nite. Column( children: [ const Text(\"My name\"), const Text(\"My surname\"), ListView( children: const [ Text(\"Skill \"), Text(\"Skill \"), ] ) ] ); You want your name and surname to stay always at the top but the list of your endless skills must scroll. The above solution is not doable because a Column expands to \ufb01ll the entire available space and a ListView does the same. They both don\u2019t have a de\ufb01ned height. Here\u2019s how the boundaries look like: They are two widgets without a speci\ufb01c value for the height because they always try to \ufb01ll the entire available space and so determining a value in advance is not possible. If you nested them Flutter Complete Reference 283",
  ". Building UIs in Flutter like this... ... you would get an error because both try to expand to cover the entire space but there are no parent widgets with a \ufb01xed height. The solution is to always be sure they\u2019re inside a widget which sets a \ufb01nite height and there are a few ways to do this: . You can use the Expanded widget which expands to \ufb01ll the remaining available space in a Column or in a Row by giving a full set of dimensions. Column( children: [ const Text(\"My name\"), const Text(\"My surname\"), Expanded( child: ListView( children: const [ Text(\"Skill \"), Text(\"Skill \"), ] ), Flutter Complete Reference 284",
  ". Building UIs in Flutter ), ] ); In this way ListView works properly because Expanded doesn\u2019t return an in\ufb01nite height: it expands to \ufb01ll exactly the remaining space and calculates a \ufb01nite height. This widget can also be used with Columns and Rows. \u009f A Row has the same \"problem\" but in the other direction (the horizontal axis). Every consideration made for columns is also valid for rows with the only di\ufb00erence that the orientation is on the x-axis rather than the y-axis. . There\u2019s an interesting attribute of ListView that changes the behavior of the widget so that it has a \ufb01xed height and the problem of the lower bound disappears. Column( children: [ Text(\"My name\"), Text(\"My surname\"), ListView( shrinkWrap: true, children: [ Text(\"Skill \"), Text(\"Skill \"), ] ) ] ); By setting shrinkWrap: true the list occupies only the space it needs and it does not expand to \ufb01ll all the available space. In this way it has a well-de\ufb01ned height because it\u2019s calculated according to the dimensions of the children. Flutter Complete Reference 285",
  ". Building UIs in Flutter However, since Column doesn\u2019t handle over\ufb02ows with scroll bars, if the list is too long and the screen cannot contain it entirely you\u2019ll see anyway the runtime over\ufb02ow exception. This isn\u2019t really a \"safe\" solution. . The Expanded widget is generally the most convenient to use but you can put the list inside any kind of widget with a well-de\ufb01ned height such as a Container or a SizedBox. SizedBox.fromSize( size: const Size(, ), child: ListView(...), ); You could also make it so that the container automatically \ufb01lls the entire width and force its height to be a \ufb01xed value. It\u2019s like an Expanded on which you can control the height and/or the width. Container( Flutter Complete Reference 286",
  ". Building UIs in Flutter constraints: const BoxConstraints.expand( height:  ), child: ListView(...), ); There are lots of possibilities, including the combined usage of a LayoutBuilder with a Container but it might get too complicated. Try to keep it simple by using Expanded or another single wid- get that automatically handles the sizes. \u009f In general, you get this kind of \"in\ufb01nite constraint\" issues with rows, columns and lists as they\u2019re very frequently used. Very often, the simple solution is called Expanded but if you\u2019re looking for a more sophisticated approach, consider using SizedBoxes or Containers. ..4 Using themes If you want to share font styles, colors and other UI appearance settings throughout an app, use the ThemeData class, in case of a MaterialApp, or a CupertinoThemeData, for the CupertinoApp widget. For example, if you used this kind of setup... MaterialApp( theme: ThemeData( fontFamily: \"Times New Roman\", ), ) ... the default fontFamily property of your app\u2019s widget will be \"Times New Roman\". This is very convenient because, for example, any Text widget will inherit that speci\ufb01c font family and you wouldn\u2019t have to this all the time: const Text(\"Something\", style: TextStyle( // Useless because \"Times New Roman\" is already inherited thanks // to 'ThemeData' fontFamily: \"Times New Roman\", ) ) With the usage of ThemeData changes are automatically re\ufb02ected on any children so the mainte- Flutter Complete Reference 287",
  ". Building UIs in Flutter nance is a lot easier. Do you want to use a di\ufb00erent font family such as \"Georgia\"? Just setup the new value in ThemeData and automatically the changes will be re\ufb02ected anywhere else. It\u2019s a centralized place in which you can style widgets: MaterialApp( theme: ThemeData( buttonColor: Colors.red, // Color of a RaisedButton focusColor: Colors.white, // Color when a widget is focused selectedRowColor: Colors.orange, primaryColor: Colors.green, accentColor: Colors.red, ), ) Generally a ThemeData should always declare a primaryColor, which de\ufb01nes the color of the most common UI widgets (sca\ufb00olds, tab bars, text\ufb01elds focuses...), and a primaryAccent, which de\ufb01nes the color for foreground widgets (FABs, list overscroll glow...). If you want to implement a dark or light theme for your app, consider using the following named constructors: // Predefined set of colors to implement dark and light themes theme: ThemeData.dark() theme: ThemeData.light(), You can get a reference to the theme properties by calling Theme.of(context) anywhere on the widget tree. There is also the possibility to override only a speci\ufb01c set of properties for a given theme in order to preserve the other settings: MaterialApp( theme: ThemeData.dark().copyWith( primaryColor: Colors.grey ) ) This is a dark() theme with the only di\ufb00erence that primaryColor has been changed to be grey (all the other parameters are still the same). You could also decide to override theme settings for certain parts of the tree rather than applying a global theme like we\u2019ve done in the above example. This is possible thanks to the Theme widget: // main.dart MaterialApp( Flutter Complete Reference 288",
  ". Building UIs in Flutter theme: ThemeData.dark(); ) // light_footer.dart Widget build(BuildContext context) { return Theme( data: ThemeData.light(), child: const MyFooter(), ); } In this example, the entire app has a dark() theme but the MyFooter widget and all of its children will use the light() theme instead. In other words Theme is used to override the current theme with a new one for the entire subtree. In fact: \u2022 calling Theme.of(context) inside MyFooter returns a reference to the light theme; \u2022 calling Theme.of(context) outside MyFooter returns a reference to the dark theme. Note that Theme.of() doesn\u2019t return a nullable value. In the next chapter we will show you how to change your app\u2019s theme from dark to light (and vice versa) with ease using the HydratedBloc from the \ufb02utter_bloc package. Flutter Complete Reference   | State management Up to this point, you know what is the state in a Flutter app because we\u2019ve exhaustively treated this topic in chapter ..2 Stateless and Stateful widgets. What you don\u2019t know yet is how to properly handle the changes of the state. \u009f We\u2019re going to analyze in detail provider and \ufb02utter_bloc but there are many other state-management libraries out there such as Redux, MobX or Scoped model. You can \ufb01nd more details in the o\ufb03cial documentation . Knowing how to properly handle the state of a Flutter app is fundamental: a well-structured code is easy to read and maintain. In addition, you\u2019ll almost always create production apps with interaction from the user (or external sources) and thus the state is going to change a lot of times. In this chapter we\u2019re going to create this simple app: Very easily, it does nothing more than incrementing and decrementing the counter in the middle when you press respectively +1 or -, which are FlatButton. We\u2019re going to implement the app using 3 di\ufb00erent state management strategies: 1https://\ufb02utter.dev/docs/development/data-and-backend/state-mgmt/options Flutter Complete Reference 290",
  ". State management . Updating the UI using setState, . Passing the state around the widget tree, with the help of the Provider widget, . Alternatives to setState(), implemented with the help of the BlocBuilder widget. You\u2019ll end up having seen the same app built in 3 di\ufb00erent ways, one for each strategy, so that you can analyze their mechanisms and see the di\ufb00erences in how they work. .1 Updating the UI It\u2019s the simplest way of handling the state of a widget but you should really avoid this approach because it mixes UI logic with business logic. You\u2019re also going to see very soon that a proper usage of setState(...) requires too much boilerplate code. \u009f Please note that we haven\u2019t said you should avoid using StatefulWidgets but you should avoid the usage of setState: you\u2019ll see soon why. As you already know, a stateful widget is fundamental when a stateless one can\u2019t be created due to the lack of immutability of the class itself. Before explaining the reasons why directly using setState is bad, let\u2019s see again how it works in a traditional counter app. // . class DemoPage extends StatefulWidget { // . const DemoPage(); // . @override _DemoPageState createState() => _DemoPageState(); } class _DemoPageState extends State<DemoPage> { // . int _counter = ; // . Flutter Complete Reference 291",
  ". State management void _increment() { setState(() => _counter++); } void _decrement() { setState(() => _counter--); } @override Widget build(BuildContext context) {...} } This is the typical setup of a widget whose state is managed with setState. . You have to follow this pattern: there\u2019s the need for a class that extends StatefulWidget as it\u2019s going to be put in the widget tree. The other class is private as it represents and handles the state of the widget. MaterialApp( // don't forget the const constructor! home: const DemoPage(), ); . There\u2019s the possibility to de\ufb01ne a const constructor for DemoPage because it\u2019s not going to change over the time. What is going to change is the state of the widget, represented by _DemoPageState (hence the class _DemoPageState can\u2019t have a constant constructor). . The creation of the widget\u2019s persisting state which will \"survive\" to rebuilds. You\u2019re going to work a lot with this class as it exposes the setState(...) method. . The counter which will be displayed in a Text widget. . Two functions that increment and decrement the counter; they both call setState so that the widget and its children get rebuilt in order to refresh the UI. The build method is very easy to understand because the UI is minimal, you\u2019ll get immediately what\u2019s going on. Note the usage of const in front of Text, when possible, which \"caches\" both Text and TextStyle. Row( mainAxisAlignment: MainAxisAlignment.spaceAround, Flutter Complete Reference 292",
  ". State management children: [ FlatButton( child: const Text(\"+\", style: TextStyle( color: Colors.green, fontSize:  ), ), onPressed: _increment, ), Text(\"$_counter\", style: const TextStyle( fontSize: , ), ), FlatButton( child: const Text(\"-\", style: TextStyle( color: Colors.red, fontSize:  ), ), onPressed: _decrement, ), ], ) As you already know, when setState is called its callback is executed and then the widget is rebuilt. Since the state persists, the increment of the variable is \"remembered\" and so the Text widget will display the new updated value. ..1 Considerations First of all there are ABSOLUTELY NO reasons to say that this approach causes performance issues because we\u2019ve used a StatefulWidget instead of a StatelessWidget. The problem is that setState has to be used together with InheritedWidget otherwise there will be uncontrolled rebuilds. Flutter Complete Reference 293",
  ". State management In the case of a widget with no children like A, when setState is called a rebuild happens only for A. In the above image, the black box represents a rebuilt widget. Performance issues start to get real when the widget being rebuilt has one or more children. Look at this example: class _WidgetAState extends State<WidgetA> { int _value = ; @override Widget build(BuildContext context) { return Column( children: [ const WidgetB(\"$_value\"), const WidgetC(), RaisedButton( child: const Text(\"Update\"), onPressed: () => setState(() { _value += ; }), ), ] ); } } When tapping on the button, setState will always trigger a rebuild for the current widget and all of its children. In the above example, both WidgetB and WidgetC are rebuilt even if only WidgetB should, as it\u2019s the only which has a dependency from WidgetA. Flutter Complete Reference 294",
  ". State management As you can see from the image, children of A are always rebuilt even if they don\u2019t have variables in common or any other kind of dependency. Calls to setState() rebuild the entire subtree, even if it\u2019s not really needed. It would be better if Flutter rebuilt only the widgets that really need to be updated, like this: If you used setState in combination with a particular class, called InheritedWidget, you would be able to make optimized rebuilds that doesn\u2019t waste resources. When used together, you get the possibility to rebuild only those widgets that really need to be updated leaving others untouched. \u009f The big problem is the usage of a stateless widget combined with an InheritedWidget: it produces a lot of boilerplate which is very hard to understand and maintain. You NEVER want to deal with it as it\u2019s not needed; there are many libraries (such as provider) that do all this tedious work for you! Flutter Complete Reference 295",
  ". State management If you are curious to understand the details of InheritedWidget, as always we recommend you to visit the o\ufb03cial documentation 2 which also has a video about it. We\u2019re not covering it in the book because there\u2019s no point in doing it since nowadays provider is the default choice, which actually is just syntactic sugar for InheritedWidget. . Stateless and stateful widgets are both e\ufb03cient and good, you don\u2019t have to think that one is less performant than the other. If you want to manage the state using a StatefulWidget you should really use setState and InheritedWidget together. . Passing data down the tree and controlling the rebuilds with InheritedWidget is compli- cated and produces a lot of boilerplate code; don\u2019t do it. Prefer the usage of a library such as provider which does everything for you with less code (and it\u2019s also way more readable). . With setState you\u2019re mixing UI logic and business logic. For example, _DemoPageState is like a huge hammer dropping from the sky and totally destroying the single responsibility principle glass. It does too many things: \u2022 it handles the UI logic, which is responsible of drawing widgets; \u2022 it handles the business logic, which takes care of _counter; \u2022 it handles the state of the app, which is managed by setState Production-ready applications contain thousands of lines of code that are written across hundreds of \ufb01les. The situation might already be quite complicated and for sure adding even more complexity by breaking the SRP is not convenient at all. . The usage of setState is too \"basic\" as it just tells Flutter to rebuild the widget and all its children; for a more subtle control there would be the need to also use InheritedWidget. Inheriting from State<T> gives access to the initState method; it\u2019s called only once in the moment in which the state is created. Since the state persists until the widget is disposed, you\u2019re guaranteed that void initState() will run only once during the lifecycle of the class. class _DemoPageState extends State<DemoPage> { @override void initState() { 2https://api.\ufb02utter.dev/\ufb02utter/widgets/InheritedWidget-class.html Flutter Complete Reference 296",
  ". State management super.initState(); // put the code here... } @override Widget build(BuildContext context) {...} } You should override initState when the widget has to be con\ufb01gured before being built or if there\u2019s the need to call methods that must be executed only once at the creation of the state. Actually initState() can be seen as if it were the constructor of a widget and dispose() the destructor. class _DemoPageState extends State<DemoPage> { @override void dispose() { // your code here... super.dispose(); } @override Widget build(BuildContext context) {} } It\u2019s executed only once when the state is destroyed and it should be used when there\u2019s the need for a clean up of resources used by the widget. If you had the need to declare a variable that cannot be immediately initialized, and you don\u2019t want it to be nullable, you\u2019d use late. late String value; @override void initState() { super.initState(); value = \"Init me\"; } If that value is going to be assigned only once inside initState, consider making it late final. Flutter Complete Reference 297",
  ". State management With the arrival of NNBD, variables could also be directly initialized in this way: late String value = \"Init me\"; No need to use initState() at all but that\u2019s just because you\u2019re doing an assignment: you can\u2019t do this when it comes to calling functions, for example. ..2 Good practices We want to point out again the fact that using stateful widgets is absolutely \ufb01ne: the problem lies in the usage of setState with no InheritedWidget associated. Other than giving too many responsibilities to the widget, it doesn\u2019t give you control on rebuilds of the children widgets and this can be a big performance issue. Other than this: \u2022 Do the initialization of the widget inside the initState method so that you\u2019re guaran- teed that the phase will be executed only once. In case of assignments, consider using late final and initialize variables directly to reduce the amount of boilerplate code. \u2022 The o\ufb03cial documentation 3 says that setState should only update values, like assigning new values to variables, it shouldn\u2019t compute anything. For example you should do this... void _increment(int value) async { setState(() { _counter += value; }); await writeToFile(_counter); } ... rather than calling the function inside the state updater: void _increment(int value) { setState(() async { _counter += value; await writeToFile(_counter); }); } Furthermore if the callback function is an instance of a Future you\u2019ll get a runtime excep- tion. Regardless, this is bad anyway because writing data to a \ufb01le should not happen in a class that deals with the UI! 3https://api.\ufb02utter.dev/\ufb02utter/widgets/State/setState.html Flutter Complete Reference 298",
  ". State management \u2022 Do not call initState after dispose since it leads to unde\ufb01ned behavior. StatelessWidget has the bool get mounted property which tells you whether the widget is created or dis- posed. Use stateful widgets with no worries but avoid using setState for state management; prefer using a library like provider or \ufb02utter_bloc. Avoid the \"raw\" usage of setState, because it rebuilds the entire subtree, and the setState() + InheritedWidget combination as well, as it produces a huge amount of boilerplate code. .2 Passing the state with Provider The provider 4 package has been created by R\u00e9mi Rousselet and it\u2019s available in the o\ufb03cial package repository. Be sure to properly install it by opening the pubspec and adding the depen- dency. dependencies: provider: ^..2 The Flutter SDK includes a simple class called ChangeNotifier which provides change noti\ufb01ca- tion to its listeners. In practical terms, if you use this class as a mixin you get the possibility to send an \"alert\" that something has changed to the subscribed widgets \u009f Provider uses Flutter\u2019s ChangeNotifier to create a class that encapsulates the state and, when something changes, the interested widgets are noti\ufb01ed and rebuilt. As the name suggests, it\u2019s a noti\ufb01er that alerts listeners about changes. We\u2019re still going to create the same app which increases and decreases the counter but in the \"provider-way\". First of all there\u2019s the need to create a class that takes care of the business logic and makes the state to persist; we\u2019re creating a \ufb01le named counter_model.dart with this content: // The mixin is needed because it contains 'notifyListeners()' class CounterModel with ChangeNotifier { int _counter = ; void increment() { 4https://pub.dev/packages/provider Flutter Complete Reference 299",
  ". State management _counter++; notifyListeners(); } void decrement() { _counter--; notifyListeners(); } int get currentCount => _counter; } If you go back to the previous section, you\u2019ll see that this code is almost identical to what\u2019s inside _DemoPageState with the di\ufb00erence that we\u2019re calling notifyListeners() instead of setState(...). \u2022 The void notifyListeners() method, contained in the ChangeNotifier mixin, is used to send a \"signal\" to the interested widgets that something has changed and a rebuild is needed to update the data. // Stateful widget setState(() => _counter++); // ChangeNotifier mixin _counter++; notifyListeners(); Logically they do the same things: \ufb01rst the variable is increased and then the UI is rebuilt because there\u2019s a signal that something has changed. \u2022 With this approach we\u2019ve moved the logic of the app from the UI widget to a separated class (CounterModel) and it\u2019s a big step forward. We\u2019re now respecting the Single Responsibility Principle. At this point all the logic lies inside a class called CounterModel and the next move is \"linking\" the model with the UI part. There are two steps to do: . Use the ChangeNotifierProvider widget to create an instance of the class (which is mixed with ChangeNotifier) so that the entire subtree will be able to use it. void main() { runApp(const MyApp()); Flutter Complete Reference 300",
  ". State management } class MyApp extends StatelessWidget { const MyApp(); @override Widget build(BuildContext context) { return ChangeNotifierProvider( create: (context) => CounterModel(), child: const DemoPage(), ); } } Thanks to ChangeNotifierProvider, the DemoPage widget and every children of it will be able to get the instance of CounterModel. The provider package has the goal to expose an object to the subtree of a given widget. . Obtain the value from the above widgets using Provider.of<T>(context) and use it to read and/or update the state of the widget. class DemoPage extends StatelessWidget { const DemoPage(); @override Widget build(BuildContext context) { // The type of 'counter' is CounterModel final counter = Provider.of<CounterModel>(context); return Scaffold( body: Center( child: Row( mainAxisAlignment: ..., children: [ // FlatButtons and Text widget ] ) ); } Flutter Complete Reference 301",
  ". State management } The method of<CounterModel>(context) returns the instance of the given type that\u2019s been created and exposed from above the tree. ChangeNotifierProvider can be seen like a \"cache\" that stores a class and serves it to the children when they ask for it. This is the new body of the Row: FlatButton( child: const Text( \"+\", style: TextStyle( color: Colors.green, fontSize:  ), ), onPressed: () => counter.increment(), ), Text( \"${counter.currentCount}\", style: const TextStyle( fontSize: , ), ), FlatButton( child: const Text( \"-\", style: TextStyle( color: Colors.red, fontSize:  ), ), onPressed: () => counter.decrement(), ), If you pressed on +, the increment() method would increase by 1 the counter and then it\u2019d call notifyListeners() which triggers a rebuild of the widget. A rebuild takes place because DemoPage is a listener (it\u2019s a child of ChangeNotifierProvider) and thus it\u2019s listening to changes. The Text widget shows the newly updated count thanks to currentCount, which is simply a getter Flutter Complete Reference 302",
  ". State management that returns the current value of the counter. To sum up, with this approach you have to: . create a model class which uses ChangeNotifier as a mixin and then call notifyListeners whenever the UI has to be updated; . use ChangeNotifierProvider to create an instance of the model that can be exposed and watched by the children; . in the build method use Provider.of<T>(context), where T is the type that you\u2019re look- ing for, to get the instance. ..1 Considerations You\u2019ve just seen how the state can be handled without having to use setState. Thanks to provider there\u2019s the possibility to use a combination of stateless widgets and noti\ufb01er classes to achieve the same result. Nevertheless ChangeNotifierProvider isn\u2019t the only important feature of the package. ...1 Provider class In the examples we\u2019ve shown that class Provider<T> has the static method of<T>() which obtains, from above the tree, the instance of the given type T. Other than notifying children about UI updates, it\u2019s also a very useful way to cache classes and expose them. class Something { final description = \"something is better than nothing\"; final descriptionCache = {...} } class ExamplePage extends StatelessWidget { @override Widget build(BuildContext context) { return Provider<Something>( create: (context) => Something(), child: ChildWidget(), ); } } class ChildWidget extends StatelessWidget { Flutter Complete Reference 303",
  ". State management @override Widget build(BuildContext context) { final value = Provider.of<Something>(context); return Text(\"${value.description}\"); } } Notice that we\u2019ve used Provider<T> rather than ChangeNotifierProvider<T> and thus children won\u2019t be able to listen to updates. How can this be useful? \u2022 You might want to put a provider at a certain point of the widget tree and use it as a \"cache\" which holds data in memory. For example, you\u2019ll see in chapter 12 that provider is very convenient when it comes to share data between multiple pages. return Provider<DataCache>( create: (context) => DataCache(), child: PageWithTabs(), ); The cache is served to the children pages with provider and it won\u2019t be destroyed because it\u2019s one level above in the tree. You can make a simple call to Provider.of<DataCache>() instead of creating complicated ways to pass data between widgets. \u2022 The usage of provider is like an automatic usage of initState and dispose so you have less code to write and less lifecycle logic to implement. \u2022 Your app\u2019s UI logic is separated from the business logic. ...2 Consumer class This widget does nothing more than automatically calling Provider.of<T>(context) in a new widget to give you the instance of the class. It also solves a problematic situation in which you cannot use Provider<T> inside build: Flutter Complete Reference 304",
  ". State management . The static method of<T>(...) looks for the instance T starting from one level above the current leaf. No problems here. . When of<T>(...) is being called in the same widget that exposes a class via Provider<T>, an exception occurs because there\u2019s no matching provider above. class ExamplePage extends StatelessWidget { @override Widget build(BuildContext context) { return Provider<Something>( create: (context) => Something(), child: Text( \"${Provider.of<Something>(context).description}\" ), ); } } Both Provider<T> and of<T>(...) are in the same widget and thus there will be a runtime failure. In certain cases however there might be the need to call of<T>(...) at the same level of the provider but the classic approach doesn\u2019t work, as you\u2019ve just seen. There are two solutions: Flutter Complete Reference 305",
  ". State management \u2022 Wrap the code requiring to access the provider in a child widget so that it gets a descendant context from its parent. This is not bad because you can also de\ufb01ne a const constructor. // Widget with provider Provider<Something>( create: (context) => Something(), child: const ChildWidget(), ); // Another wiget class ChildWidget extends StatelessWidget { const ChildWidget(); @override Widget build(BuildContext context) { final description = Provider .of<Something>(context) .description; return Text(description); } } \u2022 Use the Consumer<T> class which automatically obtains the value for you. In this case there\u2019s no need to create additional widgets, it will automatically take care of taking the instance for you. class ExamplePage extends StatelessWidget { @override Widget build(BuildContext context) { return Provider<Something>( create: (context) => Something(), child: Consumer<Something>( builder: (_, value, __) { return Text(\"${value.description}\"); } ) ); } Flutter Complete Reference 306",
  ". State management } You\u2019re allowed to use Consumer<T> as a direct child of a Provider<T> as it will automati- cally take care of properly returning the object. Both ways are absolutely \ufb01ne but probably the \ufb01rst one would be better because of the possibility to de\ufb01ne a const constructor. ..2 Good practices Whenever you call Provider.of<T>(context) the associated widget is rebuilt unless you pass listen: false to the method. For example, if you\u2019re using Provider as a cache just to hold data, you probably don\u2019t need to always trigger a rebuild. // Equivalent to of<DataCache>(context) because the // 'listen' parameter is set to true by default Provider.of<DataCache>(context, listen: true) // A later value change won't trigger a rebuild Provider.of<DataCache>(context, listen: false); Remember to set listen: false when you\u2019re just working with the data and UI should not listen to changes. It may also be useful in such cases where a provider is called from outside the widget tree: void _action(BuildContext context) { final p = Provider.of<MyObject>(context, listen: false); ... } @override Widget build(BuildContext context) { return RaisedButton( child: const Text(\"Tap me\"), onPressed: () => _action(context); ); } The method _action is not inside build and thus Provider.of<T>() is called outside of the wid- get tree. You\u2019ll get a runtime exception if listen is true. Nevertheless, in general Consumer<T> should be preferred because it could optimize your code. Consider this example: Flutter Complete Reference 307",
  ". State management class Test extends StatelessWidget { @override Widget build(BuildContext context) { final value = Provider.of<Info>(context); return Center( child: Padding( padding: EdgeInsets.all(), child: Text(\"${value.text}\"); ), ); } } As usual, Provider.of<T>() is used to get an instance of the object from above the tree. Note that only the Text widget depends on provider because Center and Padding don\u2019t care about value. However, with this code, not only Text will be updated but also Center and Padding. \u009f Being in a stateful or stateless widget doesn\u2019t make any di\ufb00erence, the concept is the same. What\u2019s important for performance is trying to rebuild only what really needs to be updated. In this case we want that, when Info changes, only the Text widget gets rebuilt while Center and Padding don\u2019t. In other words, we want to optimize the noti\ufb01er so that only a few widgets will be rebuilt and not everything. Here\u2019s the solution: Widget build(BuildContext context) { return Center( child: Padding( padding: EdgeInsets.all(), child: Consumer<Info>( builder: (_, value, __) => Text(\"$value\"); ) ), ); } This is much better because only Text will be rebuilt while Center and Padding will stay Flutter Complete Reference 308",
  ". State management untouched. With this example we want to suggest you to avoid using of<T>() and prefer Consumer<T> for a more granular rebuild. MultiProvider( providers: [ Provider<HttpCache>(create: (_) => HttpCache()), Provider<LocalCache>(create: (_) => LocalCache()), ChangeNotifierProvider<Charts>(create: (_) => Charts()), ], child: const AwesomeApp(), ) Very likely you\u2019ll have to use more providers at once and, if they\u2019re at the same level, consider using MultiProvider. It is a nice way to group multiple providers without having to nest them one by one. \u009f Don\u2019t put any kind of provider \"too high\" in the tree if it\u2019s not needed because it pollutes the scope. Place in at a reasonable position, ideally immediately before the \ufb01rst widget that needs it. With provider there\u2019s also the possibility to expose values returned by a Future<T> or explicitly write the rebuild constraints for listeners. \u2022 So far we\u2019ve only told you how to expose non-future values but provider has a very rich collection of classes. FutureProvider<T>( create: (_) async => _makingHttpRequest(), catchError: (context, error) => _inCaseOfError(), child: const MyWidgets(), ), This class listens to a Future<T> and exposes its result to the children, as it happens with any other type of provider. Passing a Future<T> that could emit errors without providing the catchError callback is considered an error. FutureProvider<T>( create: (_) async => _makingHttpRequest(), catchError: (_, __) => _inCaseOfError(), Flutter Complete Reference 309",
  ". State management lazy: false, child: const MyWidgets(), ), The default behavior is lazy: true so that create is called only the \ufb01rst time the value is read. If you set lazy: false the future is fetched immediately and not lazily. \u2022 A Selector<T> is the equivalent of a Consumer<T> which can explicitly set the rebuild constraints. If your widget rebuilds too often even with a Consumer<T>, consider using a Selector which is an even \ufb01ner optimization system: Selector<PersonData, String>( selector: (context, person) => person.name, builder: (context, name, _) { return Text(name); } ), By default a Selector<T> does a deep comparison of the value obtained by the Provider<T> and the one returned by the selector callback. If they are di\ufb00erent, a rebuild happens. In the above example, person.name is compared with the value obtained by the provider to decide whether a rebuild has to take place or not. Selector<PersonData, String>( selector: (context, person) => person.name, shouldRebuild: (previous, next) { return (previous != next) && (person.age > ); } builder: (context, name, _) { return Text(name); } ), Using the shouldRebuild callback you can implement a custom logic to decide when the children should rebuild; it overrides the default deep comparison behavior. De\ufb01ne this behavior when simple object comparison is not enough. When using Selector<T> be sure to use classes that override operator== or collections. Using mutable classes, the comparison of the values might not work as you\u2019d expect. Another thing to mention is the usage of listen: false when you try to get an instance of an object. R\u00e9mi Flutter Complete Reference 310",
  ". State management Rousselet suggests: . Don\u2019t think that listen: false always boosts your app\u2019s performances by default: yes, it could, but it\u2019s an implementation detail which depends on your architecture. . When inside the widget tree, in general leaving the default value (listen: true) is good. You might decide to use listen: false in a second moment but it might be a maintenance problem in the future if you don\u2019t document this behavior properly. Watch out to not introduce breaking changes in your codebase. In general, avoid using listen: false when you\u2019re inside the build method. . Use listen: false when a provider is called anywhere outside the build method of a widget. It\u2019s actually fact and rather than a good practice because not doing so causes a runtime exception! Starting from version ..0 there are some shortcuts you can use to reduce the boilerplate code required for common actions. The library introduced two new extension methods you should prefer over the classic verbose way: // Default provider (with listen: true) final before = Provider.of<T>(context); final after = context.watch<T>(); // Non-listening provider (with listen: false) final before = Provider.of<T>(context, listen: false); final after = context.read<T>(); They all work in the same way, no di\ufb00erences, but the new version is shorter and more readable. Note that calling read<T>() from outside the widget tree is \ufb01ne but if it\u2019s used inside the build method an exception is thrown (see the point 2 of the above Remi\u2019s suggestions). If you\u2019re looking for a recap: . When inside the build method (also when using a ChangeNotifier): \u2022 use Provider.of<T>(context) or \u2022 use context.watch<T>() (identical to above) or \u2022 use Consumer<T> (for optimization). You should prefer using watch<T> over of<T> as it\u2019s less code to write and more modern. Consumer<T> can do performance optimizations so consider using it. Flutter Complete Reference 311",
  ". State management . When inside the build method and you don\u2019t want to listen for changes or you need to listen only for certain values: \u2022 use Selector<A, S> or \u2022 use context.select((A a) => S) (identical to above) With Selector you can optimize even more than Consumer<T> as it allows you to select the exact values to listen or specify rebuild conditions. . When you are outside of the build method: \u2022 use Provider.of<T>(context, listen: false) or \u2022 use context.read<T>() (identical to above) Avoid using of<T>, prefer instead the usage of context.read<T> which is shorter and more modern as it uses Dart\u2019s extension methods. Note that you can access data via provider inside initState() even if there isn\u2019t a visible BuildContext variable being passed as parameter. As such, you could do this: void initState() { super.initState(); myValue = context.read<Something>().value; // Or also, using the 'old' syntax: // myValue = Provider.of<Something>(context, listen: false).value; } Using watch<T>() (which is the equivalent of calling of<T>() without listen: false) will cause an exception. .3 Alternative to setState: BLoC pattern The Flutter Bloc 5 package has been created by Felix Angelov and it\u2019s of course available in the o\ufb03cial package repository. It\u2019s an implementation of the BLoC state management patter that was presented at the Google I/O event back in . dependencies: flutter_bloc: ^.. 5https://pub.dev/packages/\ufb02utter_bloc Flutter Complete Reference 312",
  ". State management We\u2019re going to create the same app which increases and decreases the counter but in the \"bloc- way\". The term \"BLoC\" is an acronym which stands for Business Logic Components and it relies on asynchronous streams. The gist of a bloc is the conversion of an event into a state. There are a series of steps in- volved: . A widget sends an event to the bloc, which is a class implementing a certain logic; . The bloc is noti\ufb01ed because a new event has arrived on the stream. It processes the requests and then produces an output: the new state for the widget; . The listening widget receives the new state given by the bloc and rebuilds. Let\u2019s map these theoretical steps to our concrete example. When the user presses on +1 or -, the \ufb02at button sends an increment or decrement event to the stream. The bloc does the calculation and then it produces a new state for the Text widget (a new int, the updated counter), which is rebuilt. Flutter Complete Reference 313",
  ". State management The \ufb01rst thing to do is the creation of the bloc, the class taking care of the logic we\u2019re going to implement. This is very good because we\u2019re separating the UI logic from the business logic in favor of the Single Responsibility Principle. // . enum CounterEvent { increment, decrement } // . class CounterBloc extends Bloc<CounterEvent, int> { // . CounterBloc() : super(); // . @override Stream<int> mapEventToState(CounterEvent event) async* { switch (event) { // 'state' is a getter defined inside Bloc<E,S> which // represents the current state of the bloc case CounterEvent.increment: yield ++state; break; case CounterEvent.decrement: yield --state; break; } Flutter Complete Reference 314",
  ". State management } } This is the content of a \ufb01le named counter_bloc.dart. . Events are represented by an enum and the two items represent, very intuitively, the in- crement or decrement of the counter. In Part III we will see that for more complex cases, using classes is better than enums. . The CounterBloc class is the bloc itself which takes a stream of events and produces new updates for the state. The int is produced by the bloc and it represents the new state of the Text widget, which will be rebuilt. . This is the initial value of the bloc, which is required. From version ..0 onward, you have to pass the value via super as we\u2019ve done above. Versions ..1 and earlier had to override initialState instead: // v4..1 and lower class CounterBloc extends Bloc<CounterEvent, int> { // No calls to 'super' @override int get initialState => ; @override Stream<int> mapEventToState(CounterEvent event) async* {...} } Basically from version 5 there\u2019s been a breaking change that replaced the initialState getter with a call to super. There\u2019s no logical di\ufb00erence since the purpose of both is giving the bloc an initial state (it\u2019s just a syntactic di\ufb00erence). . This method is the heart of the bloc as it listens for incoming events and produces new states. The syntax is very nice and self-explanatory because you can immediately guess what comes in and what goes out. // Something of type 'CounterEvent' comes in from the stream and // it's going to be converted by the bloc into an integer class CounterBloc extends Bloc<CounterEvent, int> {} The variable state is given by the bloc, it\u2019s initialized by overriding initialState and in this case it\u2019s an integer. If the incoming event were of type increase a new state (containing Flutter Complete Reference 315",
  ". State management the old value increased by ) would be emitted. The business logic has been properly isolated inside a single class, which is CounterBloc, and now it\u2019s time to link the UI with the bloc. We have to make it so that widgets can send events and receive new states. void main() => runApp(const MyApp()); class MyApp extends StatelessWidget { const MyApp(); @override Widget build(BuildContext context) { // Yes, provider is used internally by the bloc library // to expose instance of blocs to the children widgets return BlocProvider<CounterBloc>( create: (context) => CounterBloc(), child: const DemoPage(); ); } } The \ufb02utter_bloc package uses provider internally so you might \ufb01nd this familiar. You may have guessed that class BlocProvider<T> exposes a particular instance of a bloc to the children so that they can send events and listen to updates. class DemoPage extends StatelessWidget { const DemoPage(); @override Widget build(BuildContext context) { // For older versions of Dart that don't use extension // methods, simply go for: // final counterBloc = BlocProvider.of<CounterBloc>(context); final counterBloc = context.bloc<CounterBloc>(); return Scaffold( body: Center( child: Row( mainAxisAlignment: MainAxisAlignment.spaceAround, Flutter Complete Reference 316",
  ". State management children: [ // FlatButtons and Text widget ] ) ); } } The content of counter is simply a reference of the CounterBloc instance that has been passed from above the widget tree. This variable will be used by widgets to dispatch new events and receive state updates. FlatButton( child: const Text( \"+\", style: TextStyle( color: Colors.green, fontSize:  ), ), onPressed: () => counterBloc.add(CounterEvent.increment), ), BlocBuilder<CounterEvent, int>( builder: (context, count) => Text( \"$count\", style: const TextStyle( fontSize: , ), ), ), FlatButton( child: const Text( \"-\", style: TextStyle( color: Colors.red, fontSize:  ), ), Flutter Complete Reference 317",
  ". State management onPressed: () => counterBloc.add(CounterEvent.decrement), ), The BlocBuilder<T, K> widget is the one that rebuilds the UI in response to state changes sent by the bloc. Thanks to final counterBloc we\u2019re able to dispatch events very easily: // +1 onPressed: () => counterBloc.add(CounterEvent.increment), // -1 onPressed: () => counterBloc.add(CounterEvent.decrement), The new state emitted by the bloc is captured by BlocBuilder<CounterBloc, int> which re- builds only what\u2019s inside the builder callback. The variable int count contains the new counter value (the new state) which has been processed by the bloc. \u009f Widgets just send rebuild requests (events) and wait for the arrival of a new state from the bloc. The UI knows nothing about the logic behind it as it\u2019s entirely de- ferred to the bloc itself; this is a complete separation of business logic from design logic. Awesome! ..1 Considerations In this simple example we had to deal with increasing and decreasing a counter; nothing complex to represent in both ways (events and states) enum and int were enough. However things can be more complicated than this and there could be the need for a better representation of the input and outputs of the bloc. \u009f Enumerations are good when the type of events are very simple to represent and they have no data to carry. Consider using classes when events need to have some info since they can be easily stored and accessed via setters and getters. In most of the cases, both input events and output states are represented by classes following a particular structure (it\u2019s a convention, not a strict rule). Taking again our counter app ex- ample, if we decided to use classes rather than enumerations for events the code would be the following: Flutter Complete Reference 318",
  ". State management abstract class CounterEvent extends Equatable { const CounterEvent(); @override List<Object> get props => []; } class Increment extends CounterEvent { const Increment(); } class Decrement extends CounterEvent { const Decrement(); } An important note is that classes must be immutable because the new altered state is going to be changed exclusively by the bloc. In the same way, if the output state were represented by a class rather than an enum the structure would be identical. The advantage here is that classes can carry extra-data (as instance variables), if needed. class CounterState extends Equatable { final int count; const CounterState(this.count); @override List<Object> get props => [count]; } Logically this is nothing di\ufb00erent from what you\u2019ve seen in the original example; the di\ufb00erence is that we\u2019re using classes instead of an enumerations. In this cases a hierarchy is useless because a simple enum su\ufb03ces but if we had data or a logic to carry with the event, classes would be useful. \u009f Using Equatable is not required but it\u2019s very convenient as it reduces the amount of boilerplate code required for proper object comparisons. If you don\u2019t want to use it, simply go for a classic overriding of operator== and hashCode. The management of the bloc itself would be a bit di\ufb00erent too. There\u2019s the need to recognize the Flutter Complete Reference 319",
  ". State management type of incoming events (with a series of ifs) and dispatch a proper response. class CounterBloc extends Bloc<CounterEvent, CounterState> { CounterBloc() : super(const CounterState()); @override Stream<CounterState> mapEventToState(CounterEvent event) async* { if (event is Increment) { final newCount = state.count + ; yield CounterState(newCount); } else if (event is Decrement) { final newCount = state.count - ; yield CounterState(newCount); } } } Finally, BlocBuilder<CounterBloc, CounterState> widget will simply require to reference newCount to get the newly updated counter. You\u2019ll \ufb01nd most of the online examples and docu- mentation relying on classes rather then enumerations so we recommend you to get familiar with them. The o\ufb03cial \ufb02utter_bloc documentation 6 contains a lot of step-by-step examples with images and many side note explainations to make sure that you won\u2019t get lost. 6https://bloclibrary.dev Flutter Complete Reference 320",
  ". State management ...1 BlocListener class This widget is useful in such cases where a callback has to be triggered whenever the bloc outputs a new state. For example, we could make it so that when the user presses on +1 or -, a snackbar with a message appears in the UI notifying the alteration of the counter. \u009f There\u2019s an awesome package called Flushbar 7 which allows you to fully customize snackbars in your apps. It doesn\u2019t require a Scaffold or any other particular setup: we\u2019re using it in this example. We\u2019re referring to the original example where the bloc takes a CounterEvent enumeration as input and emits an int. class DemoPage extends StatelessWidget { const DemoPage(); @override Widget build(BuildContext context) { return BlocListener<CounterBloc, int>( listener: (context, state) { Flushbar( message: \"The counter has been altered!\", duration: Duration(seconds: ), )..show(context); } child: const ButtonsAndText(), ); } } // Clickable buttons and the Text widget with the counter // have been moved here. class ButtonsAndText extends StatelessWidget { const ButtonsAndText(); @override 7https://pub.dev/packages/\ufb02ushbar Flutter Complete Reference 321",
  ". State management Widget build(BuildContext context) { final counterBloc = context.bloc<CounterBloc>(); return Scaffold( body: Center( child: Row( mainAxisAlignment: MainAxisAlignment.spaceAround, children: [...] ) ) ); } } Thanks to class BlocListener<B,S>() we\u2019re able to listen to the stream and \"catch\" the responses (the states) that have been emitted by the bloc. In other words, this widget is a listener that listens for new states and lets you do something in response. return BlocListener<CounterBloc, int>( condition: (previous, current) { // return true/false to decide if listening or not }, listener: (context, state) { // code... }, child: const ButtonsAndText(), ); The listenWhen callback is not required because true is the default value. condition returns a boolean value which decides whether the listener callback will be called or not. It exposes the current and the previous values of the state so that they can be compared, if needed. return BlocListener<CounterBloc, int>( listenWhen: (previous, current) { return (previous != current) && (current > ); }, listener: (context, state) { _showBar(context); }, Flutter Complete Reference 322",
  ". State management child: const ButtonsAndText(), ); In this example, the listener callback will be triggered only if the newly emitted value of the counter is greater than \ufb01ve. ..2 BlocObserver class If you\u2019re developing an app with multiple blocs and thus a lot of events \ufb02owing on the streams, it might be useful being able to log the activities to the console. This can be very helpful while debugging and it\u2019s not hard to do at all because the BlocObserver class comes to the rescue. An observer is an object that observes what\u2019s going on in the bloc and gives you the possibility to log various things. It\u2019s very useful while debugging your app; you can log the data \ufb02ow in the console for example or make some kind of analytics. An observer does NOT interact with the logic of the bloc because it\u2019s just a passive observer. class MyObserver extends BlocObserver { @override // . void onEvent(Bloc bloc, Object event) { super.onEvent(bloc, event); print(event); } @override // . Flutter Complete Reference 323",
  ". State management void onTransition(Bloc bloc, Transition transition) { super.onTransition(bloc, transition); print(transition); } @override // . void onError(Bloc bloc, Object error, StackTrace stacktrace) { super.onError(bloc, error, stacktrace); print('$error | $stacktrace'); } } A bloc observer is nothing more than a subtype of class BlocObserver which overrides a series of methods. There\u2019s no need to implement them all, only de\ufb01ne the ones that you need: \u2022 override onEvent if you want to log information about incoming events; \u2022 override onTransition if you want to log information about a transition. A transition is made of the current state, the next state and the input event; \u2022 override onError if you want to log errors. The only other thing that you have to do is initialize the observer and you\u2019re done. In the case of a Flutter app, the best place is before the initialization. void main() { Bloc.observer = MyObserver(); runApp(const MyApp()); } You don\u2019t need to pass any list of blocs in use or whatever else because Bloc does everything automatically. Every bloc of your app will be observed by the observer which will trigger the events that you\u2019ve overridden. ..3 Persisting the state with HydratedBloc The hydrated_bloc package is an extension of the \ufb02utter_bloc library which automatically stores states so that they can be restored even if the app is closed and opened again later. We\u2019re going to create a bloc that switches the theme of the app between light and dark automatically storing the state. In this way, the user\u2019s preferred theme is remembered and used the next time the app is opened. Flutter Complete Reference 324",
  ". State management \u2022 Events. The events being \ufb01red are only two, indicating whether the current theme should be light or dark. We haven\u2019t used an enum because in the future you could want to add more themes, maybe created by you, which might require a complex setup. abstract class ThemeEvent extends Equatable { const ThemeEvent(); @override List<Object> get props => []; } class DarkTheme extends ThemeEvent { const DarkTheme(); } class LightTheme extends ThemeEvent { const LightTheme(); } \u2022 States. The states can simply be of type ThemeData since it\u2019s exactly what we need. There are no extra data to return, so no need for a class hierarchy. So far it\u2019s the same usual setup for a bloc where both events and states have been de\ufb01ned. The bloc itself is also very similar to the usual one but this time we\u2019re extending HydratedBloc. It\u2019s basically a Bloc with two more methods to override: class ThemeBloc extends HydratedBloc<ThemeEvent, ThemeData> { static final _lightTheme = ThemeData.light(); static final _darkTheme = ThemeData.dark(); @override Stream<ThemeData> mapEventToState(ThemeEvent event) async* { if (event is DarkTheme) { yield _lightTheme; } if (event is LightTheme) { yield _darkTheme; } } Flutter Complete Reference 325",
  ". State management // other overrides coming soon... } We\u2019ve decided to cache the states just to avoid copy/pasting the named constructor many times as you\u2019ll see in a moment. That\u2019s absolutely not required, you could have gone for a classic yield ThemeData.dark() for example. Here\u2019s the other interesting part of the bloc: class ThemeBloc extends HydratedBloc<ThemeEvent, ThemeData> { ThemeBloc() : super(ThemeData.light()); @override Stream<ThemeData> mapEventToState(ThemeEvent event) async* {...} @override ThemeData? fromJson(Map<String, dynamic> source) { try { if (source['light'] as bool) { return ThemeData.light(); } return ThemeData.dark(); } catch (_) { return null; } } @override Map<String, bool>? toJson(ThemeData themeData) { try { return { 'light': state != ThemeData.light() }; } catch (_) { return null; } } } Flutter Complete Reference 326",
  ". State management Exactly as it happens with \ufb02utter_bloc, the constructor makes a call to super to pass the initial state of the bloc. However, there\u2019s an internal check on the base class constructor that loads the persisted state in case it existed. In other words, the above example works like this: \u2022 If there isn\u2019t a state stored on the disk, ThemeData.light() is picked as initial state thanks to super(ThemeData.light());. \u2022 If there is a state stored on the disk, the value passed to super() is ignored and the stored state is picked as initial. Version ..1 and earlier of hydrated_bloc had to override the initialState getter in order to set an initial state. If we made this example using any version prior to ..0 we\u2019d have to initialize the bloc in this way: // hydrated_bloc ..1 and earlier versions ThemeData get initialState => super.initialState ?? ThemeData.light(); It checks whether there\u2019s or not a state stored on the disk: if not, the default ThemeData.light() value is passed. In version ..0 this check is automatically performed when calling super(). The other two important methods you\u2019re asked to override are: \u2022 fromJson: it\u2019s called when trying to read the state from the internal storage. Be sure to return null in case of exceptions or if there are no cached states. \u2022 toJson: it\u2019s called on each state change to store on the device, in this case, the user\u2019s preferred theme. If null is returned, no caching happens. Last but not least, in order to properly initialize the bloc storage you need to make these two calls before the runApp() method. This is also the perfect place to change the directory in which HydratedBloc should store the data (by default it picks the device\u2019s temporary directory): void main() { WidgetsFlutterBinding.ensureInitialized(); HydratedBloc.storage = await HydratedStorage.build( storageDirectory: await getApplicationDocumentsDirectory() ); runApp(const App()); } The convenient path_provider package gives you a cross-platform access to various locations of the \ufb01lesystem in which the app is running. In the end, an HydratedBloc is a bloc (they work in Flutter Complete Reference 327",
  ". State management the same way) with the addition of automatic state storage management. ..4 Undo and redo with ReplayBloc Undo and redo operations are quite common actions to \ufb01nd in a program. To keep consistency with the examples we made, imagine this \ufb02ow in a classic counter app: . At startup, the counter is . . Tap on +: the counter is now . . Tap on +: the counter is now . . Tap the \"undo\" button: the counter is now 1 because the last action has been canceled. Basically, \"undo\" means canceling the latest operation performed on the bloc. On the other side, \"redo\" means repeating the latest action performed on the bloc. Thanks to ReplayBloc you can very easily add automatic undo and redo support with almost no e\ufb00orts. // states.dart class CounterEvent extends ReplayEvent { const CounterEvent(); } class Increment extends CounterEvent { const Increment(); } class Decrement extends CounterEvent { const Decrement(); } Rather than extending Equatable, this time we need to subclass ReplayEvent in order to enable undo and redo operations on a bloc. Other than this, nothing new to do: we\u2019re already ready to create the Bloc for our counter: class CounterBloc extends ReplayBloc<CounterEvent, int> { CounterBloc() : super(); @override Stream<int> mapEventToState(CounterEvent event) async* { if (event is Increment) { Flutter Complete Reference 328",
  ". State management yield state + ; } if (event is Decrement) { yield state - ; } } } The state, for sake of simplicity, is just an int. There\u2019s really nothing new: it\u2019s a \"regular\" bloc which overrides mapEventToState as usual. The di\ufb00erence lies in the usage because, other than being able to send new events on the bloc with add(), there are also the two additional methods: undo() and redo(). // Get a reference to the bloc final counterBloc = context.bloc<CounterBloc>(); // Then in the 'build' function, add events or call undo()/redo() FlatButton( child: const Text(\"+\"), onPressed: () => counterBloc.add(const Increment()), ), FlatButton( child: const Text(\"-\"), onPressed: () => counterBloc.add(const Decrement()), ), FlatButton( child: const Text(\"Undo\"), onPressed: () => counterBloc.undo(), ), FlatButton( child: const Text(\"Redo\"), onPressed: () => counterBloc.redo(), ), If you want to add undo/redo support to a bloc, just remember to extend ReplayEvent in your classes representing the event. All the other setup is just a regular bloc. You can even add undo/redo support for existing kinds of blocs, such as an HydratedBloc for example: class HydratedCounterBloc extends HydratedBloc<CounterEvent, int> Flutter Complete Reference 329",
  ". State management with ReplayBlocMixin { CounterBloc() : super(); @override Stream<int> mapEventToState(CounterEvent event) async* { ... } @override int fromJson(Map<String, dynamic> json) { ... } @override Map<String, int> toJson(int state) { ... } } With ReplayBlocMixin any bloc gains access to undo/redo operations, even \"regular\" blocs you\u2019ve created extending Bloc<E,S>. You just need to add the mixin; there\u2019s nothing to add in the de\ufb01nition of the class. // Get a reference to the bloc final hydratedCounterBloc = context.bloc<HydratedCounterBloc>(); // Then in the 'build' function, add events or call undo()/redo() hydratedCounterBloc.add(const Increment()); hydratedCounterBloc.add(const Decrement()); hydratedCounterBloc.undo(); hydratedCounterBloc.redo(); This example shows how powerful mixins can be: they add functionalities to a class without changing its internal de\ufb01nition. ..5 The internals of Bloc: Cubit Starting from version ..0 of \ufb02utter_bloc the internals of the library got reworked and this is the reason why initialState has been removed and replaced with super(). There\u2019s a new class called Cubit which is the new core of Bloc: \u2022 Cubit is absolutely NOT a replacement of Bloc. Bloc uses Cubit internally! \u2022 There\u2019s no point in asking which one is better. If you\u2019re using Bloc, then you\u2019re also using Cubit because it\u2019s the \"engine\" that runs your blocs. \u2022 A Cubit is a \"lightweight\" version of a Bloc. Flutter Complete Reference 330",
  ". State management Keep in mind that Cubit has a simple and concise API which is great for managing simple states. However, if you plan to completely replace cubit with Bloc for complex state management cases, you might get in trouble. Here\u2019s a comparison that might help you making a mental map: \u2022 Bloc is a very powerful solution which is great for both simple and complex state manage- ment. It can really be used in any Flutter project with no restrictions. \u2022 Cubit has a very simple and concise API and it should be used when the state to be managed is simple. It\u2019s a \"subset\" of the Bloc library. We\u2019re going to show you how a Cubit<T> can be used to easily increment and decrement a counter. Here\u2019s a comparison on how the traditional \"Counter app\" would look like if you used Cubit or Bloc to manage the state. Let\u2019s start with the state management code: \u2022 Cubit. // counter_cubit.dart class CounterCubit extends Cubit<int> { CounterCubit() : super(); void increment() => emit(state + ); void decrement() => emit(state - ); } \u2022 Bloc. // event.dart abstract class CounterEvent extends Equatable {...} // state.dart class CounterState extends Equatable {...} // count_bloc.dart class CounterBloc extends Bloc<CounterEvent, CounterState> { CounterBloc() : super(const CounterState()); @override Stream<CounterState> mapEventToState(CounterEvent e) async* {...} } As you can see, the CounterCubit version is simpler and with much less code to write. Note that cubits don\u2019t have states and events: they simply emit new states using methods. The usage of a Flutter Complete Reference 331",
  ". State management cubit in the widget tree should be very familiar to you: \u2022 Cubit BlocProvider<CounterCubit>( create: (_) => CounterCubit(), child: CounterPage(), ), \u2022 Bloc BlocProvider<CounterBloc>( create: (_) => CounterBloc(), child: CounterPage(), ), Once the provider has been placed right above the widgets you need, you can easily use a \"builder widget\" to listen for updates. It\u2019s no di\ufb00erent from the structure you\u2019ve been used to see up to now and all \ufb02utter_bloc widgets are compatible with both Bloc and Cubit instances. \u2022 Cubit // Cubits are used inside 'BlocBuilder's BlocBuilder<CounterCubit, int>( builder: (_, counter) { return Text(\"$counter\"); }, ), \u2022 Bloc BlocBuilder<CounterBloc, CounterState>( builder: (context, state) { return Text(\"${state.count}\"); }, ), If we compared the amount of code, it\u2019s clear that blocs require more boilerplate than cubits. In this simple counter app, going for Cubit is \ufb01ne since the state to manage is very easy (but still, Bloc would be \ufb01ne anyway). We want to point out again that cubit shouldn\u2019t be the default choice for any project: for advanced state management you\u2019d better use Bloc. Flutter Complete Reference 332",
  ". State management \u009f In certain cases, you might not be sure that the state will always be simple to manage. For example, it might happen that your project manager could tell you to add more features and things might get complicated. If you\u2019re stuck in this situation, go for Bloc which has you covered in any situation. There are also HydratedCubit<T> and ReplayCubit<T> which do the same thing as the \"bloc counterpart\" with the same name. In the following example, we show how to persist and restore the state of a Cubit<T> of a traditional \"counter app\". class CounterCubit extends HydratedCubit<int> { CounterCubit() : super(); void increment() => emit(state + ); void decrement() => emit(state - ); @override int fromJson(Map<String, dynamic> json) => json['value'] as int; @override Map<String, int> toJson(int state) => {'value': state}; } It works exactly like a HydratedBloc<T> with the only di\ufb00erence that only cubits are allowed. Of course, you need to initialize the storage before starting the application. void main() async { WidgetsFlutterBinding.ensureInitialized(); HydratedBloc.storage = await HydratedStorage.build(); runApp(MyApp()); } ..6 Good practices If you decide to use \ufb02utter_bloc for your projects you\u2019ll probably \ufb01nd yourself in the situation where it\u2019s required to have a BlocBuilder<B,S> is inside a BlocListener<B,S>. It\u2019s perfectly \ufb01ne: Flutter Complete Reference 333",
  ". State management BlocListener<BlocA, StateA>( listener: (context, state) { // listen to state changes and do something, // like showing a snackbar or a dialog } child: Column( children: [ const Text(\"Something\"), BlocBuilder<BlocA, StateA>( builder: (context, state) { return UseTheState(state); } ) ] ) ) No performance problems here but there\u2019s quite a lot of code to write and many types to de\ufb01ne. There are two main ways to improve the readability of this code: \u2022 Use the BlocConsumer<B,S> widget which allows you to use a listener and a builder all together. It\u2019s like nesting a BlocBuilder<B,S> inside a BlocListener<B,S> but with less boilerplate code. BlocConsumer<BlocA, StateA> // This is the 'BlocListener' part listener: (context, state) { // listen to state changes and do something, // like showing a snackbar or a dialog } // This is the 'BlocBuilder' part builder: (context, state) { return Column( children: [ const Text(\"Something\"), UseTheState(state), ] ) } Flutter Complete Reference 334",
  ". State management ) It\u2019s much easier to read and for sure you have less code to write because both listener and builder expose the main parameters of the respective widgets. You should use consumer only when you need to rebuild the UI and listen to state changes; if this is not the case, use BlocBuilder and BlocListener alone. \u2022 Move the content of the child in a separated widget so that you can also try to make, if possible, a const constructor. It\u2019s what we\u2019ve done earlier while showing how to implement a snackbar for the counter app: BlocListener<BlocA, StateA>( listener: (context, state) { // listen to state changes and do something, // like showing a snackbar or a dialog } child: const SubWidget(), ) And then move the Column with its contents inside a dedicated widget: class SubWidget extends StatelessWidget { const SubWidget(); @override Widget build(BuildContext context) { // Column with text and BlocBuilder } } Always remember to make constant constructors whenever possible! If your app has a complex logic which requires more than a single bloc in the same widget, consider using a MultiBlocProvider. The name should sound familiar because in practice it\u2019s just a MultiProvider which exposes a series of blocs to the children: MultiBlocProvider( providers: [ BlocProvider<Bloc1>( create: (context) => Bloc1(), ), BlocProvider<Bloc2>( Flutter Complete Reference 335",
  ". State management create: (context) => Bloc2(), ), BlocProvider<Bloc3>( create: (context) => Bloc3(), ), ] ); Be aware that \ufb02utter_bloc uses provider under the hood but you cannot mix the two libraries together, simply because your code won\u2019t compile. Prefer using the above approach rather than nesting a series of BlocProviders because the code might become very hard to read. .4 Good practices for state management We want to repeat (for the last time!) that using StatefulWidgets is perfectly \ufb01ne and sometimes fundamental, for example when the class has non-\ufb01nal instance variables like int counter = ;. A stateful widget isn\u2019t more e\ufb03cient than a stateless one and vice versa. What is bad is the usage of setState without InheritedWidget: \u2022 It breaks the SRP because a widget has to take care of the UI and the logic together, which can also become messy very quickly in large apps. \u2022 In a complex architecture the usage of setState alone can be problematic because it doesn\u2019t give the possibility to optimize children rebuilds. It should be integrated with InheritedWidget but there would be a lot of work to do in terms of development, testing and maintenance. \u2022 If you really have to use it because you\u2019re doing maintenance of an app made by someone else, be sure that it doesn\u2019t compute anything. Don\u2019t call functions that calculate/compute something; just do simple assignments. The o\ufb03cial Flutter documentation 8 maintains a list of active state management libraries; among them you can \ufb01nd provider and \ufb02utter_bloc that we\u2019ve covered in the previous sections. \u009f You can decide to manage the state of your app with whatever package you want, whether it be a provider, bloc, Redux or MobX. The decision is up to you because they all do their job very well. 8https://\ufb02utter.dev/docs/development/data-and-backend/state-mgmt/options Flutter Complete Reference 336",
  ". State management It\u2019s not possible to say which one is the best or if one works better than the other. For sure they solve the same problem but they use di\ufb00erent approaches and di\ufb00erent logics so it\u2019s di\ufb03cult to make a fair comparison. If you want to have another complete example about the provider package, check the o\ufb03cial documentation 9 which uses ChangeNotifier and ChangeNotifierProvider. In the end, here\u2019s a quick recap of the best practices about state management: \u2022 provider \u2013 Prefer the usage Consumer<T> which rebuilds only the widgets that you want. If you want to have even more control for better optimization, use Selector which is able to speci\ufb01cally tell when a rebuild should happen. \u2013 Avoid the usage of Provider.of<T>(context) inside build as it will rebuild any children, even the ones that don\u2019t need to be updated. \u2013 Consider using a MultiProvider() when you have more than a single provider at the same level; it makes the code more readable. \u2013 Prefer using context.watch<T>() and the other extension methods on BuildContext since it\u2019s more concise and modern. There\u2019s no performance di\ufb00erence if compared to Provider.of<T>() but it\u2019s just a shorter syntax. \u2013 In general, prefer using extension methods since they\u2019re shorter and more modern. \u2022 \ufb02utter_bloc 9https://\ufb02utter.dev/docs/development/data-and-backend/state-mgmt/simple Flutter Complete Reference 337",
  ". State management \u2013 Prefer using context.bloc<T>() which is less verbose than using the non-extension version BlocProvider.of<T>(context) \u2013 Put inside BlocBuilder<T>() only the widgets that actually need a rebuild in response to a state change. Don\u2019t place into it widgets that don\u2019t need to listen to changes, even if they are const because they \"pollute\" the scope of the bloc. \u2013 If you have the need to both listen and build for a bloc, use BlocConsumer<B,S> instead of nesting widgets; it reduces the amount of boilerplate code. \u2013 Consider using ReplayBloc or ReplayBlocMixin to add undo/redo actions to your blocs. Flutter Complete Reference   | Routes and navigation .1 Basics of navigation and routing Organizing information across several screens is one of the most important building blocks of any architecture. A very common example is the one in which your app\u2019s \ufb01rst page is a login form and, if the user provides a correct combination of username and password, a welcome page appears. \u009f In the Flutter world, your app\u2019s pages are called routes, or screens, and they are the equivalent of Activities in Android or ViewControllers in iOS. The most common way to create a page involves the usage of a stateless or stateful widget with a Scaffold (or a CupertinoPageScaffold). This chapter is going to show how to properly structure and manage the pages of your app. Before getting started, we want to suggest you a possible folder structure for your app: - lib/ - routes/ - widgets/ - main.dart - routes.dart Very intuitively, routes/ is going to contain all those UI widgets representing a route of the app. Inside widgets/ we recommend putting all those reusable widgets that support the creation of your app\u2019s pages. Look at this simple widget: class FooterName extends StatelessWidget { const FooterName(); Flutter Complete Reference 339",
  ". Routes and navigation @override Widget build(BuildContext context) { return Text(\"Your name\", style: const TextStyle(...) ); } } Placing this code in widgets/footer_name.dart is very convenient because you know it\u2019s an \"utility\" piece of UI that will be reused across multiple pages as a footer. It can be integrated with const FooterName() and a simple change on footer_name.dart is automatically re\ufb02ected everywhere. ..1 Creation of routes We\u2019re going to create a simple application with two screens: HomePage, the \ufb01rst route which appears when the app starts, and RandomPage, a route that displays a random number at the center of the screen. The layout of the pages will be created with a convenient Scaffold from the material library. // Located in routes/home_page.dart class HomePage extends StatelessWidget { const HomePage(); @override Widget build(BuildContext context) { return Scaffold( body: Center( child: RaisedButton( onPressed: () {} child: const Text(\"Random\"), ), ), ); } } // Located in routes/random_page.dart Flutter Complete Reference 340",
  ". Routes and navigation class RandomPage extends StatelessWidget { const RandomPage(); @override Widget build(BuildContext context) { return Scaffold( body: Center( child: Text(\"${Random().nextInt()}\"), ), ); } } Any other page of the app will go in the routes/ folder which might contain other folders to better organize the \ufb01les. When there are many \ufb01les, creating a good hierarchy of directories and sub-directories is fundamental in order to not get lost in your own architecture. ..2 The main.dart \ufb01le The general structure of a main.dart \ufb01le might look like the following. The usage of mate- rial instead of cupertino is not relevant, it just means we\u2019re using MaterialApp() in place of CupertinoApp(). import 'package:flutter/material.dart'; void main() => runApp(const RandomApp()); // . class RandomApp extends StatelessWidget { const RandomApp(); @override Widget build(BuildContext context) { return MaterialApp( onGenerateTitle: (context) => \"Random App\", initialRoute: RouteGenerator.homePage, // . onGenerateRoute: RouteGenerator.generateRoute, // . Flutter Complete Reference 341",
  ". Routes and navigation // Hides the debug stripe on the top-right corner // which might be annoying to see! debugShowCheckedModeBanner: false, ); } } This is how you should structure your main.dart \ufb01le. Of course you can rearrange it as you prefer but generally it should only contain the code that initializes the app and nothing more. . This is the widget located at the root of the tree which has the task to setup the various routes and redirect the user to the \ufb01rst page. . This is a string. We\u2019re going to explain what is RouteGenerator in a moment; it basically tells Flutter which is the \ufb01rst route that has to be loaded. . This is a method reference. The navigation between pages in Flutter works like if you were using a browser. Each page has a name, which is like an \"url\" and you show a page by \"navigating\" to that address. If your pages need to share a cache or you have the need for one (or more) noti\ufb01ers, it\u2019s good practice wrapping the MaterialApp inside a MultiProvider which nicely gathers a series of providers. @override Widget build(BuildContext context) { return MultiProvider( providers: [ Provider<DataCache>(create: (_) => DataCache()), ChangeNotifierProvider<Something>( create: (_) => Something() ), ], child: MaterialApp(...) ); } ..3 The routes.dart \ufb01le Having a single class that handles the entire routing of your app is very nice as it fully embraces the single responsibility principle. By consequence, when you\u2019ll have to deal with routes you\u2019ll Flutter Complete Reference 342",
  ". Routes and navigation always open routes.dart because every route-related logic is only there. \u009f This is a \"centralized\" control of your routes which keeps the code clean. Give this \ufb01le whichever name you want but we suggest it should contain the word \"route\" so that you\u2019ll recognize its contents immediately. The following snippet shows the contents of routes.dart. The example is using the material library, so we\u2019re using return MaterialPageRoute(), but if you were in the cupertino world you\u2019d go for return CupertinoPageRoute(). // . class RouteGenerator { // . static const String homePage = '/'; static const String randomPage = '/random'; // . RouteGenerator._() {} // . static Route<dynamic> generateRoute(RouteSettings settings) { //. switch (settings.name) { case homePage: // .5 return MaterialPageRoute( builder: (_) => const HomePage(), ); case randomPage: return MaterialPageRoute( builder: (_) => const RandomPage(), ); default: throw FormatException(\"Route not found\"); } Flutter Complete Reference 343",
  ". Routes and navigation } } // . class RouteException implements Exception { final String message; const RouteException( this.message); } There must be a route named '/' which has to map to the \ufb01rst page that\u2019s being shown when your app starts. It\u2019s a requirement, not a just a good practice. . Actually this class is just a \"wrapper\" for a single static function because declaring global functions is possible, but it\u2019s not a good idea.generateRoute() is the main actor. . Each page of the app is uniquely identi\ufb01ed by a string; it\u2019s the same thing you\u2019re used to see on the internet where web pages are identi\ufb01ed by URLs. In this case: \u2022 The DemoPage route is associated with the '/' path \u2022 The RandomPage route is associated with the '/random' path Do you want to press on a button and show the RandomPage widget? It\u2019s very easy, you just need to write... Navigator.of(context)?.pushNamed(RouteGenerator.randomPage); ... and the new screen appears. The pushNamed() method takes a path, which is linked to a page, and navigates to it; in this case it looks for '/random' and shows the widget that\u2019s been assigned to it. . The settings parameter carries some info gathered by the Navigator.of method such as the name of the route. This part is very important because it\u2019s were you map an URI (the path) to the route/screen. . The MaterialPageRoute<T> class replaces one screen with another by using an Android slide transition. The equivalent class for the cupertino package is CupertinoPageRoute<T> which does the same job but with an iOS slide transition. You\u2019ve just seen how to create a series of \"named routes\" (routes at which you assign a name). For example, the route '/random' is said to be the named route of the RandomPage widget. // Inside 'MaterialApp()' of main.dart initialRoute: RouteGenerator.homePage, Flutter Complete Reference 344",
  ". Routes and navigation onGenerateRoute: RouteGenerator.generateRoute, initialRoute takes the path of the \ufb01rst page that Flutter has to load when the app is opened. onGenerateRoute maps an URI (a string like '/random') to a widget (a route like RandomPage) so that the Navigator class is able to show the pages. ..4 Navigating between pages At this point, we have our routes properly set up inside routes.dart and we\u2019re ready to move from one page to the other. A quick recap of the job we\u2019ve done so far: \u2022 creation of two routes called DemoPage and RandomPage; \u2022 setup of the routes in the MaterialApp() of main.dart; \u2022 The creation of the RouteGenerator class which maps an URI to a widget so that the Navigator class can open routes. The \ufb01rst page of our example app is HomePage which has to open another route when the button is pressed. All we need to do is calling pushNamed() with the name of the target route that has to appear. // The 'HomePage' widget's build method return Scaffold( body: Center( child: RaisedButton( onPressed: () => Navigator.of(context)?.pushNamed( RouteGenerator.randomPage ) child: const Text(\"Random\"), ), ), ); This code makes the RandomPage route appear with a sliding animation from the bottom to the top of the screen. If you want to come back to the HomePage route just press the back button or make a simple call to Navigator.of(context)?.pop(). // The 'RandomPage' widget's build method final rand = Random().nextInt(); Flutter Complete Reference 345",
  ". Routes and navigation return Scaffold( body: Center( child: Text(\"$rand\"), ), ); ..5 Good practices Both MaterialApp and CupertinoApp are needed to con\ufb01gure the routes that will be used by the Navigator, you\u2019ve just seen it. Actually, we\u2019ve only described the good way to implement routes management but in reality there are more ways to achieve the same result: \u2022 Good. Encapsulate the routing management in a single class of a dedicated \ufb01le. Other than respecting the SRP, you\u2019ll be able to easily handle a lot of routes with ease in a single, centralized place. MaterialApp( initialRoute: RouteGenerator.homePage, onGenerateRoute: RouteGenerator.generateRoute, ); Nothing new, this is what we\u2019ve implemented in the previous section. The route manage- ment is completely separated from the rest of the app thanks to class RouteGenerator. \u2022 Bad. Do the routing management directly inside the MaterialApp widget with no logic separation between various areas. This example may look good, but if there were many routes there would probably be maintenance problems. MaterialApp( initialRoute: '/', routes: <String, WidgetBuilder>{ '/': (BuildContext context) => const HomePage(), '/random': (BuildContext context) => const RandomPage(), }, ); You can use the routes parameter and assign it a Map<String, WidgetBuilder> which maps a path to a route. This is what we did inside generateRoute with the exception Flutter Complete Reference 346",
  ". Routes and navigation that here the routing logic is being injected directly in the widget. In this case, there\u2019s no separation between UI logic and routing logic. MaterialApp( initialRoute: '/', routes: <String, WidgetBuilder>{ '/': (BuildContext context) => MaterialPageRoute( builder: (context) => const HomePage(), ), '/random': (BuildContext context) => MaterialPageRoute( builder: (context) => const HomePage(), ), }, ); Wrapping screens inside MaterialPageRoute() automatically adds the transition anima- tion while navigating and a BuildContext to use if needed. The biggest problem is that builder methods can be complicated or require more logic; if you had many routes your code would become messy and hard to maintain. \u2022 Bad. Do the same thing but use home instead of initialRoute. MaterialApp( home: const HomePage(), routes: <String, WidgetBuilder>{ // define routes... }, ); Do NOT de\ufb01ne home and initialRoute together because it\u2019d be a con\ufb02ict that might end up in an unexpected behavior. While the RouteGenerator class approach is harder to understand and involves multiple steps, it\u2019s the best to use as it also scales well. Do not mix di\ufb00erent routing management approaches together, you might get lost in your own code! MaterialApp( // This is very error-prone! initialRoute: RouteGenerator.homePage, onGenerateRoute: RouteGenerator.generateRoute, Flutter Complete Reference 347",
  ". Routes and navigation routes: <String, WidgetBuilder>{ '/': (BuildContext context) => MaterialPageRoute( builder: (context) => const HomePage(), ), '/random': (BuildContext context) => MaterialPageRoute( builder: (context) => const HomePage(), ), }, ); Can you guess what\u2019s going on? How can you know which parameter will be chosen by the framework to handle the routing? There is an order actually : . Flutter looks \ufb01rst if the home parameter is set; . if home is null, then the routes parameter is chosen; . if routes is null, then the onGenerateRoute callback is chosen; . if none of the above resolved to a valid call, the onUnknownRoute callback is called. You don\u2019t need to remember this sequence at all. In order to not make confusion avoid the setup of the routes inside MaterialApp or CupertinoApp and walk in the SRP-way by creating a separated class, like RouteGenerator. ..6 Navigator .0 The Navigator class existed since the early days of Flutter and we\u2019re describing how to use it in this chapter. The Flutter team will deliver an update on the routing system with the following changes (some of them are breaking): \u2022 pop() doesn\u2019t return a value anymore; \u2022 the isInitialRoute property of RouteSetting is deprecated; \u2022 the presence of a new widget called Router. Router is a new widget you can use to open and close pages of an app. It wraps a Navigator and con\ufb01gures its current list of pages based on the current app state. Let\u2019s see what you\u2019ll have to do in order to migrate the code to the new navigation system. 1https://api.\ufb02utter.dev/\ufb02utter/material/MaterialApp-class.html Flutter Complete Reference 348",
  ". Routes and navigation \u2022 If you rely on RouteSettings.isInitialRoute, replace it with the new callback introduced in both MaterialApp and CupertinoApp. Of course, the RouteGenerator class has to be changed accordingly as well: // Before RouteGenerator { static Route<dynamic> generateRoute(RouteSettings settings) { if (settings.isInitialRoute) { return A(); } return B(); } } MaterialApp( onGenerateRoute: RouteGenerator.generateRoute, ) // Migration RouteGenerator { static Route<dynamic> generateRoute(RouteSettings settings) { return B(); } static List<Route> generateInitialRoutes(String name) { return <Route>[ A() ]; } } MaterialApp( onGenerateInitialRoutes: RouteGenerator.generateInitialRoutes, onGenerateRoute: RouteGenerator.generateRoute, ) ) Basically, you don\u2019t have to perform a check inside generateRoute anymore because it\u2019s done internally by the framework when you assing values to onGenerateInitialRoutes. \u2022 In the next section, we will see that pop() can return a value. You\u2019ll learn that working Flutter Complete Reference 349",
  ". Routes and navigation with pop() to exchange data is not good and should be avoided. Furthermore, with the new update you\u2019ll be forced to use use canPop() and then call pop() separately. // Before if (Navigator.pop(context)) { print(\"Can pop\"); } else { print(\"Cannot pop\"); } // Migration if (Navigator.canPop(context)) { print(\"Can pop\"); } else { print(\"Cannot pop\"); } Navigator.pop(context); The navigator pops the route anyway, so in the new version we call pop() at the end. Keep in mind that Navigator won\u2019t be removed in favor of Router. Be sure to have a look at the documentation when the navigator .0 upgrade will come out. .2 Passing data between pages and widgets Sharing data between two or more pages is a very common need: di\ufb00erent widgets located in various parts of the tree might require some data sharing. Common use cases can be: . in a layout with many tabs, you need to pass data from a tab to another; . you have a route (a page) which has to send a primitive type or a complex object to another route when navigating to it; . in the same page, two widgets need to exchange data. All of these tasks can be easily accomplished with the provider package as it\u2019s a perfect option for data sharing among widgets. There would also be the possibility to pass data using Navigator but we will see why it\u2019s discouraged. Flutter Complete Reference 350",
  ". Routes and navigation ..1 The Navigator class The Navigator class allows you to move from a route to another going back and forth. The pages you navigate to are \"overlapped\" and the framework keeps track of them using a stack. This picture gives you an idea of how it works: When you navigate to a new screen with pushNamed(\"/route_name\"), the Navigator adds a new route to its internal stack. By consequence, the route at the top of the stack is the one you\u2019re seeing on the screen. If you want to go back to the previous page, call pop(): This method removes the route at the top of the stack so that the widget below becomes the Flutter Complete Reference 351",
  ". Routes and navigation new visible screen. Going forth and back between pages is just a matter of pushing and popping routes in a stack data structure managed by the Navigator. \u2022 Navigator.of(context)?.pushNamed(\"/route_name\") \u2022 Navigator.of(context)?.pop() But there\u2019s also another equivalent way to use them: \u2022 Navigator.pushNamed(context, \"/route_name\") \u2022 Navigator.pop(context) Maybe it\u2019d be better using the of(context) version as it\u2019s a more common pattern also used by other widgets, but it returns a nullable type. If you don\u2019t want to use named routes, you can use \"plain routes\" that work without strings: \u2022 Named route. Navigator.of(context)?.pushNamed(\"/route_name\"); \u2022 Plain route Navigator.of(context)?.push( MaterialPageRoute( builder: (context) => YourScreen() ) ); If you aren\u2019t using named routes, you have to manually specify the destination every time (= code duplication) and mix UI logic with navigation logic. Again, the RouteGenerator approach we\u2019ve covered at the beginning of the chapter is what we recommend! ..2 Passing data with Navigator We\u2019re creating a simple to-do app; when an item of the list is tapped, a new route appears with a description of the selected to-do. The \ufb01rst thing to do is the creation of a Todo type which represents an entry of the list. class Todo { final String title; final String description; Flutter Complete Reference 352",
  ". Routes and navigation const Todo(this.title, this.description); } In the \ufb01rst page, called TodosPage, we\u2019re creating a list of Todos that are displayed using a ListView. When a to-do is tapped, a new route called InfoPage is opened to show the description of the selected item. class TodosPage extends StatelessWidget { // Some todos to show on the screen. final List<Todo> todos = [ Todo(\"Item \", \"First to-do of the list\"), Todo(\"Item \", \"Second to-do of the list\"), Todo(\"Item \", \"Third to-do of the list\"), ]; const TodosPage(); void _itemPressed(BuildContext context, Todo item) => Navigator.of(context)?.push( MaterialPageRoute( builder: (context) => InfoPage(todo: item), ), ); @override Widget build(BuildContext context) {...} } The to-do list is directly given by the widget just to keep the example simple and focus on the problem, which lies in _itemPressed. As you can see named routes aren\u2019t being used and we\u2019ll explain why in a moment. // build method of 'TodosPage' return Scaffold( body: ListView.builder( itemCount: todos.length, itemBuilder: (context, index) { return ListTile( title: Text(todos[index].title), Flutter Complete Reference 353",
  ". Routes and navigation onTap: () => _itemPressed(context, todos[index].description ), ); }, ), ); Finally, we need a route that displays the description of the selected widget such as InfoPage. class InfoPage extends StatelessWidget { final Todo item; const InfoPage(this.item); @override Widget build(BuildContext context) { return Scaffold( body: Center( child: Text(\"${item.description}\") ), ); } } The biggest problem of this approach is that Navigator cannot take a named route with the RouteGenerator strategy we\u2019re used to adopt. You have to inject MaterialPageRoute directly inside the method of the navigator and this can be a problem: \u2022 First of all, the single responsibility principle is not respected because the navigation logic is spread across multiple \ufb01les. Widgets now have to take care about navigation management and, if any, custom transitions between pages. \u2022 With this approach you can send data to InfoPage by writing some boilerplate code. What if you had the need to return data back from InfoPage to TodosPage? There is a solution: // In the 'TodosPage' widget, send data to 'InfoPage' void _itemPressed(BuildContext context, Todo item) async { // Result contains the data returned by 'pop' in InfoPage final result = await Navigator.of(context)?.push( MaterialPageRoute( builder: (context) => InfoPage(todo: item), Flutter Complete Reference 354",
  ". Routes and navigation ), ); } // In the 'InfoPage' widget, send data back to 'InfoPage' void _returnSomething() { Navigator.pop(context, \"Pasta pizza maccheroni\"); } We\u2019ve changed the body of the method because the push function returns a Future<T> which completes only when pop has been called somewhere. In practice the push method returns a value when pop is called somewhere in the tree; in this case the string is stored inside final result. To sum up, passing data with Navigator is complicated and badly mixes many logics inside your widgets. Keeping track of the data \ufb02ow across various push and pop calls can quickly get confusing. ..3 Passing data with provider Sharing data among routes with Navigator can be troublesome and you\u2019ve just seen why. Using provider you can get rid of all those problems and easily pass objects between widgets without caring about the navigation. . The \ufb01rst thing to do is the creation of a model class, which is a class representing a to-do item, like we\u2019ve done earlier. // Still the same todo.dart file class Todo { final String title; final String description; const Todo(this.title, this.description); } . Rather than having the to-do list in a widget, we move it to a dedicated class that\u2019s going to be used as a cache. Thanks to provider the various pages will be able to access the list whenever they want without having to move data back and forth. // todo_cache.dart class TodoCache { Flutter Complete Reference 355",
  ". Routes and navigation var _index = -; final List<Todo> _todos = [ Todo(\"Item \", \"First to-do of the list\"), Todo(\"Item \", \"Second to-do of the list\"), Todo(\"Item \", \"Third to-do of the list\"), ]; void addItem(String title, String descr) { _todos.add(Todo(title, descr)); } int get index => _index; set index(int value) { if ((value >= ) && (value < _todos.length)) { _index = value; } else { _index = -; } } UnmodifiableListView<Todo> get list => UnmodifiableListView<Todo>(_todos); } We know this is a very simple logic: you could also implement the deletion of an item, the lookup on the list and much more. For the scope of our example that\u2019s enough. . Using a Provider<TodoCache> we can expose the list to the children (the routes) so that they\u2019re able to share the data. We\u2019ve decided to place a provider right above the widget containing our pages and not inside runApp() just to not pollute the scope. It actually wouldn\u2019t make any di\ufb00erence but MyApp doesn\u2019t require data sharing so including it in the provider would be useless. // todo_cache.dart void main() => runApp(const MyApp()); class MyApp extends StatelessWidget { @override Flutter Complete Reference 356",
  ". Routes and navigation Widget build(BuildContext context) { return Provider<TodoCache>( create: (_) => TodoCache(), child: const TodosPage(), ); } } Nothing new up to here because that\u2019s the typical setup for a provider. The TodosPage doesn\u2019t change much; the only di\ufb00erence from before is on how the Navigator is called. We\u2019re about to do dependency injection thanks to provider and thus a huge step forward to respect the SRP. class TodosPage extends StatelessWidget { const TodosPage(); void _open(BuildContext context) => Navigator.of(context)?.pushNamed(RouteGenerator.infoPage); @override Widget build(BuildContext context) { return Scaffold( body: Consumer<TodoCache>( builder: (context, cache, _) { return ListView.builder( itemCount: cache.list.length; itemBuilder: (context, index) {...} ); } ), ); } } We can now use named routes with the RouteGenerator approach because data are not coupled to the navigation logic anymore. In this way we have separated data sharing from navigation logic and thus there\u2019s no need to work with push and pop to send/receive objects. // 'itemBuilder' of ListView.builder in TodosPage itemBuilder: (context, index) { return ListTile( Flutter Complete Reference 357",
  ". Routes and navigation title: Text(\"${cache[index].title}\"), onTap: () { cache.index = index; _open(context); } ); } Tapping an item of the list calls _open which pushes a new route to the screen. Thanks to cache.index = index; we can remember which item has been selected so that other widgets will be able to get a reference to the to-do just by calling: final selectedTodo = cache.list[cache.index]; For example, if you tapped on the second item of the list cache.index would be 1 because the selected item is the second to-do of the list. Our InfoPage route doesn\u2019t need to get the index via constructor anymore because the provider has anything we need: class InfoPage extends StatelessWidget { const InfoPage(); @override Widget build(BuildContext context) { return Scaffold( body: Center( child: Consumer<TodoCache>( builder: (context, cache, _) { final item = cache.list[cache.index]; return Text(\"${item.description}\"); } ), ), ); } } If you wanted to improve this code even more, you could remove the index variable and use another strategy to select the correct to-do item in the list. Apart from this, what you should learn from this chapter is that dependency injection (with provider) is the way to go for data sharing among routes. Flutter Complete Reference 358",
  ". Routes and navigation \u2022 the routing logic can be isolated in a RouteGenerator class or whatever you want to name it; \u2022 the business logic can be isolated in a dedicated class (TodoCache for example): \u2022 the UI is not mixed with the logic; thanks to provider you inject the dependencies in the widgets but there\u2019s a very loose coupling between components. Passing data using push and pop directly is bad: you cannot use named routes, routing logic mixes with business logic and keeping track of the data \ufb02ow quickly becomes cumbersome. .3 Other routing techniques As you\u2019ve seen throughout this chapter, a BuildContext is essential to navigate among routes. In some cases, you could have the need to move to a new page without having a context available: in this case, you can use keys. class RouteGenerator { RouteGenerator._(); // Expose a key to use a navigator without a context static final key = GlobalKey<NavigatorState>(); static Route<dynamic> generateRoute(RouteSettings settings) {...} } We\u2019ve added a new static \ufb01eld to our famous RouteGenerator class which will be used to call pushNamed without a context. It needs to be linked to the material or cupertino root widget in order to work as expected: MaterialApp( navigatorKey: RouteGenerator.key, ) CupertinoApp( navigatorKey: RouteGenerator.key, ) Now you can use RouteGenerator.key.currentState?.pushNamed() to navigate among routes as usual. The di\ufb00erence is that no BuildContext is required but keep in mind the following: Flutter Complete Reference 359",
  ". Routes and navigation \u2022 Try to use Navigator.of(context)?.pushNamed() as much as possible. It should be your default choice. \u2022 Remember that global keys are relatively expensive to use. \u2022 Use a GlobalKey<NavigatorState>() only if really needed. In chapter 22 we will see a case in which a navigation key is essential, but still it\u2019s a single case. Flutter\u2019s navigation tools are easy to use but they aren\u2019t perfect; data sharing between routes can become quite cumbersome and thus relying on provider is essential. Here\u2019s a list of the most relevant packages for an alternative routes management (with a link to their repository): . Flutter modular. https://pub.dev/packages/\ufb02utter_modular class AppModule extends MainModule { // Injectable classes such as \"provider\" or \"flutter_bloc\" @override List<Bind> get binds => []; // Your app's routes @override List<Router> get routers => [ Router(\"/\", child: (_, __) => HomePage()), Router(\"/info\", child: (_, __) => InfoPage()), ]; // The widget that contains MaterialApp or CupertinoApp @override Widget get bootstrap => MyRootWidget(); } . . Fluro. https://pub.dev/packages/\ufb02uro final router = Router(); // Define a route var loginRoute = Handler( Flutter Complete Reference 360",
  ". Routes and navigation handlerFunc: (context, params) { return LoginScreen(); } ); // Assign it to the router void defineRoutes(Router router) { router.define(\"/login\", handler: loginRoute); } // Navigate router.navigateTo(context, \"/login\", transition: TransitionType.fadeIn ); . . Sailor. https://pub.dev/packages/sailor // Routing class class Routes { static final sailor = Sailor(); static void createRoutes() { sailor.addRoute(SailorRoute( name: \"/loginPage\", builder: (context, args, params) { return LoginPage(); }, )); } } // Routes initialization void main() async { Routes.createRoutes(); runApp(const MyApp()); } Flutter Complete Reference 361",
  ". Routes and navigation // Registration of Sailor Widget build(BuildContext context) { return MaterialApp( navigatorKey: Routes.sailor.navigatorKey, onGenerateRoute: Routes.sailor.generator(), ); } // No context needed for navigation Routes.sailor.navigate(\"/loginPage\"); They\u2019re not necessarily better or worse than Flutter\u2019s Navigator approach; it\u2019s just a series of alternatives you might \ufb01nd interesting. Flutter Complete Reference   | Localization and internationalization .1 Introduction Other than being responsive, high quality apps are also well localized: it means that they auto- matically adapt the contents in order to appeal to a geographically speci\ufb01c target device. While this might sound quite complicated to understand, this example will get you to the point: The above picture shows how the same application behaves in two di\ufb00erent mobile phones of Flutter Complete Reference 363",
  ". Localization and internationalization people coming from di\ufb00erent parts of the world. The app is said to be \"localized\" because, according with the locale in which it\u2019s run, it adopts to the user\u2019s culture and geographical area. \u2022 On the left, the app is loaded in a mobile device whose locale is set to \"Italy\". For this reason it shows the price in euro, the italian \ufb02ag and the text is translated in the native language. \u2022 On the right, the app is loaded in a mobile device whose locale is set to America. For this reason it shows the price in dollars, the american \ufb02ag and the text is translated in the native language. In other words, your app is localized when certain graphical elements of the UI automatically change according with the culture and the geographical area of the device. In general, the most relevant aspects to take into account are: \u2022 translating sentences in the proper language; \u2022 showing prices in the proper currency (euro, dollar, Sterling and so on); \u2022 choosing between 24h or 12h time format (.30 or .30pm) \u2022 time-based implementations should take into account time zones. Making a fully localized app is not so easy because there are many aspects to consider; the bigger your app is, the more you\u2019ll have to localize. However, Flutter comes to the rescue with the intl 1 package which includes many localization facilities. import 'package:intl/intl.dart'; void main() => runApp( const DemoApp() ); class DemoApp extends StatelessWidget { const DemoApp(); @override Widget build(BuildContext context) { // Same exact thing with 'CupertinoApp' return MaterialApp( 1https://pub.dev/packages/intl Flutter Complete Reference 364",
  ". Localization and internationalization localizationsDelegates: [ GlobalMaterialLocalizations.delegate, GlobalCupertinoLocalizations.delegate, GlobalWidgetsLocalizations.delegate, ], ); } } The minimal setup required for intl to work is the declaration of a few localization delegates in MaterialApp() or CupertinoApp() at the root of your widget tree; they are used by intl to automatically gather information about the device\u2019s locale. The package provides a series of facilities: \u2022 The simpleCurrency method gets currency information according with the device\u2019s locale: // The device in which this example is run is italian and thus the // locale resolves to \"it\". Since 'localeOf()' is nullable, we // provide a default value so that \"en\" becomes the fallback. var localeFormat = NumberFormat.simpleCurrency( locale: Localizations.localeOf(context)?.toLanguageTag() ?? \"en\", ); debugPrint(\"${localeFormat.currencySymbol}\"); // \u20ac (the 'euro' symbol) debugPrint(\"${localeFormat.currencyName}\"); // EUR If you want to get data about a speci\ufb01c currency just hard-code the language tag with, for example, simpleCurrency(\"en_US\") which will return \"$\" or \"USD\". \u2022 Thanks to DateFormat there are many ways to format a DateTime object according with the current locale. Visit the o\ufb03cial documentation 2 to get a detailed explaination of the various possible combinations var today = DateTime.now(); // Using the default locale obtained by intl (\"en\") final d1 = DateFormat(\"yyyy-MM-dd - kk:mm\").format(today); // d1 = \"-- - :\" final d2 = DateFormat(\"EEE, M/d/yyyy\").format(today); 2https://pub.dev/documentation/intl/latest/index.html Flutter Complete Reference 365",
  ". Localization and internationalization // d2 = \"Sun, //\" // Using a given locale which overrides the default one final d2 = DateFormat(\"EEE, M/d/yyyy\", \"it\").format(today); // d2 = \"dom, //\" While \"Sun\" stands for \"Sunday\", in the second example \"dom\" stands for \"domenica\" which is the italian translation of sunday. \u2022 A very useful feature of this package is the automatic string translation for material and cupertino widgets. For example if you had a search button in your app, rather than hard coding the textual value... RaisedButton( child: const Text(\"Search\"), // <-- hard coded string onPressed: () {} ) ... you can use intl which automatically translates the strings according with the device\u2019s locale: RaisedButton( // \"Search\" for the English/American locale // \"Cerca\" for the Italian locale // \"Rechercher\" for the French locale // and so on... child: Text(MaterialLocalizations.of(context).searchFieldLabel), onPressed: () {} ) The CupertinoLocalizations class works in the same exact way but it\u2019s meant to be used with cupertino components. When localizing an app, it\u2019s also fundamental approaching to internationalization which is the process of translating strings into di\ufb00erent languages according with the current locale. You can do it by using MaterialLocalizations and CupertinoLocalizations but they\u2019re limited to translate a series or pre-built widgets. \u009f Localization (L10n) and internationalization (i18n) are not the same thing, even if sometimes they\u2019re erroneously used as if they were synonyms. Internationalization, date time formatting, currency formatting and much more more are all localization Flutter Complete Reference 366",
  ". Localization and internationalization techniques. What you should do is being able to completely translate each string of your app, including those that don\u2019t belong to Flutter\u2019s UI libraries. In the following two sections we\u2019re going to show how to completely internationalize Flutter applications so that they automatically translate according with the devices\u2019s locale. When the app is opened, the user doesn\u2019t have to choose the preferred language because the device automatically recognizes it (thanks to class Locale). Before starting, keep in mind that: \u2022 Both techniques you\u2019re going to see are good: don\u2019t think that, in terms of performance, one is better than the other. If you\u2019re not sure which one you should use, try both approaches to determine which is the one that suits more to your needs. \u2022 Manual internationalization is faster to implement and probably easier to use but it just translates strings. Basic approach. \u2022 Internationalization with intl requires various con\ufb01gurations to setup but it\u2019s more than plain string translation (subtle control for plurals, nouns, \ufb01rst/third person and so on). Advanced approach. Flutter Complete Reference 367",
  ". Localization and internationalization .2 Manual internationalization This kind of internationalization is manual because it doesn\u2019t rely on automated tools or external \ufb01les; you have to manage the various translations by yourself. In terms of e\ufb03ciency there are no problems at all but probably, in larger apps, maintenance might be tedious if there are a lot of languages to support. lib/ localization/ routes/ main.dart routes.dart We recommend the creation of a folder called localization which is going to contain localization- speci\ufb01c \ufb01les, such as the ones we\u2019re going to create now to internationalize the app. ..1 AppLocalization Create a new \ufb01le called app_localization.dart which is going to host the AppLocalization class. It contains a database with the translations of each string for all locales that the app is going to support. We have decided to use English (\"en\") as default language. // app_localization.dart class AppLocalization { final Locale locale; const AppLocalization(this.locale); static AppLocalization? of(BuildContext ctx) => Localizations.of<AppLocalization>(ctx, AppLocalization); static Map<String, Map<String, String>> _db = { \"en\": { \"hello\": \"Hello!\", \"hello_world\": \"Hello world\", }, \"it\": { \"hello\": \"Ciao!\", \"hello_world\": \"Ciao mondo\", }, Flutter Complete Reference 368",
  ". Localization and internationalization \"es\": { \"hello\": \"Hola!\", \"hello_world\": \"Hola Mundo\", } }; } The database is implemented with maps because when it comes to data retrieval they are very fast (O() time complexity); making it static is a good idea because data has to be initialized only once. In this example, our app is going to translate strings for the following locales: \u2022 en - English; \u2022 it - Italian; \u2022 es - Spanish The static method of() takes care of extracting the proper locale according with the context. In fact, thanks to it you\u2019re able to do the following... final locale = AppLocalization.of(context)?.locale.languageCode ?? \"en\"; ... where final locale is a string containing the language code of the device\u2019s locale such as \"en\", \"it\" or \"es\". Having a final Locale instance variable is not required but it might be good to have if you wanted to implement some locale-speci\ufb01c features. Feel free to remove it if you won\u2019t need it. \u009f In the translations database (_db), the various locale keys must all match other- wise the lookup strategy won\u2019t work. You cannot use di\ufb00erent keys like this: \"en\": { \"hello\": \"Hello!\", }, \"it\": { // NO, should be 'hello' \"ciao\": \"Ciao!\", }, To keep the example simple we\u2019ve decided to use strings. However, a better approach would be the usage of an enum for keys in order to avoid working with strings, which might introduce typing errors. Flutter Complete Reference 369",
  ". Localization and internationalization enum _LocKeys { hello, hello_world } class AppLocalization { static Map<String, Map<_LocKeys, String>> _db = { \"en\": { _LocKeys.hello: \"Hello!\", }, \"it\": { _LocKeys.hello: \"Ciao!\", }, \"es\": { _LocKeys.hello: \"Hola!\", }, } } Less strings to maintain! Make sure to make _LocKeys private to hide access to it from the outside (hiding implementation details is always a good practice). Still in the same \ufb01le, create an extension method which allows calling a localize method di- rectly on a BuildContext object, which is very convenient. The extension method can access AppLocalization\u2019s private members because they live in the same \ufb01le. extension LocalizationExt on BuildContext { String localize(String value) { // Getting the device's locale, which can be for example // \"en\", \"it\", \"es\" or anything else final code = AppLocalization.of(this)?.locale.languageCode ?? \"en\"; final database = AppLocalization._localizedValues; // Checks whether the current app locale is supported if (database.containsKey(code)) { return database[code]?[value] ?? \"-\"; } else { // Default to English if the locale is not supported Flutter Complete Reference 370",
  ". Localization and internationalization return database[\"en\"]?[value] ?? \"-\"; } } } class AppLocalization {...} In our example, if the locale were \"en\", \"it\" or \"es\" the condition would evaluate to true because the database contains translation strings for those locales. If the device\u2019s locale were \"fr\" (French) for example, which is not supported... return database[\"en\"]?[value] ?? \"-\"; ... the if statement would go to the second branch which is a fallback to the English locale. In other words, if your app doesn\u2019t support the device\u2019s locale, English is chosen as default. At this point you\u2019re able to retrieve internationalized strings like this: Text(context.localize(\"hello\")); Very short and concise! ..2 Localization delegate Create another \ufb01le called localization/localization_delegate.dart which is going to con- tain the localization delegate for our class AppLocalization. A delegate is a class that produces collections of localized values according with the current locale (which is the device\u2019s locale). class AppLocalizationDelegate extends LocalizationsDelegate<AppLocalization> { const AppLocalizationDelegate(); @override bool isSupported(Locale locale) => [\"en\", \"it\", \"es\"].contains(locale.languageCode); @override Future<AppLocalization> load(Locale locale) => SynchronousFuture<AppLocalization>( AppLocalization(locale) ); Flutter Complete Reference 371",
  ". Localization and internationalization @override bool shouldReload(LocalizationsDelegate<AppLocalization> d) => false; } This is the standard pattern when creating localization delegates; the only part you should take care of is the \ufb01rst overridden method as it tells which locales your app supports. . isSupported: the returned boolean indicates whether the device\u2019s locale is supported by the application or not. Since our database has support for English, Italian and Spanish, the array contains respectively [\"en\", \"it\", \"es\"]. . load: loads resources for the given locale and the object generated with this method can be referenced later by using Localizations.of<T>(). You have noticed the usage of a weird class here: class SynchronousFuture<T> implements Future<T> { ... } This is a Future<T> in which the callback de\ufb01ned inside then runs immediately (so it doesn\u2019t wait for something at all). This case is probably the only one in which it can be used; in general avoid working with a SynchronousFuture<T>. . shouldReload: returns true or false whether the resources for this delegate should be loaded again with load or not. It\u2019s almost never required so returning false by default is \ufb01ne. The last setup takes place in the MaterialApp or CupertinoApp at the root of your widget tree. There\u2019s the need to \"install\" the localization delegate we\u2019ve just created. void main() => runApp(const MyApp()); class MyApp extends StatelessWidget { const MyApp(); @override Widget build(BuildContext context) { return MaterialApp( initialRoute: RouteGenerator.homePage, onGenerateRoute: RouteGenerator.generateRoute, localizationsDelegates: [ const AppLocalizationDelegate(), // Global localization delegates provice localized Flutter Complete Reference 372",
  ". Localization and internationalization // strings and other values for the Material and // Cupertino libraries. They support + locales! GlobalMaterialLocalizations.delegate, GlobalCupertinoLocalizations.delegate, GlobalWidgetsLocalizations.delegate, ], supportedLocales: const [ Locale.fromSubtags(languageCode: \"en\"), Locale.fromSubtags(languageCode: \"it\"), Locale.fromSubtags(languageCode: \"es\"), ], ); } } You have to include AppLocalizationDelegate in the localizationsDelegates list along with the other common delegates so that the correct locale can be automatically inferred. Also be sure that the same type of locales are supported in both the delegate and the widget: // Inside 'AppLocalizationDelegate' bool isSupported(Locale locale) => [\"en\", \"it\", \"es\"].contains(locale.languageCode); // Inside 'MaterialApp' supportedLocales: const [ Locale.fromSubtags(languageCode: \"en\"), Locale.fromSubtags(languageCode: \"it\"), Locale.fromSubtags(languageCode: \"es\"), ] In both cases \"en\" (English), \"it\" (Italian) and \"es\" (Spanish) are supported locales and thus there\u2019s consistency (which is correct). Be sure to keep these two properties \"in sync\" to get a proper behavior. ..3 Backward compatibility Dart .6 and earlier version don\u2019t support extension method and thus you have to change your strategy. It\u2019s nothing di\ufb03cult at all as there\u2019s only the need to move the logic inside Flutter Complete Reference 373",
  ". Localization and internationalization AppLocalization. class AppLocalization { final Locale locale; const AppLocalization(this.locale); // Rather than being in the extension method, 'localize()' is directly // inside the AppLocalization class. String localize(String value) { final code = locale.languageCode; if (_db.containsKey(code)) { return _db[code][value] ?? \"-\"; } else { return _db[\"en\"][value] ?? \"-\"; } } } It\u2019s basically the same thing we did in the extension method but now the code is a bit more verbose than earlier: // Dart . - It also works up to Dart .9 because nnbd isn't supported yet Text(AppLocalization.of(context).localize(\"hello\")) Of course, if you want, you can also use this approach in Dart .10 or higher versions. However, you\u2019d have to deal with nullable types (and thus every time you\u2019d have to perform null-checks or provide default values). // Dart . - Null checks or default values are required because the // returned value is of type 'String?' Text(AppLocalization.of(context)?.localize(\"hello\") ?? \"-\") // Dart . - No checks to do because they're done inside the extension Text(context.localize(\"hello\")) Flutter Complete Reference 374",
  ". Localization and internationalization .3 Internationalizing using intl The internationalization process with intl is similar to the one we\u2019ve just seen since they share the same identical setup but the translations database is managed by dedicated \ufb01les rather than a simple Map<K, V>. dependencies: flutter: sdk: flutter flutter_localizations: sdk: flutter intl: ^..1 intl_translation: ^..10 Add the required dependencies and consider using the following template for the creation of a folder structure. It\u2019s very similar to the one in the previous section; the only additions are in localization/ since we\u2019re going to deal with potentially a lot of \ufb01les. lib/ localization/ arb_files/ dart_files/ routes/ main.dart routes.dart ..1 AppLocalization Create the usual app_localization.dart \ufb01le which is going to host AppLocalization. It\u2019s the translation database but di\ufb00erently from the manual approach, rather than using a Map we\u2019re interacting with command line tools. class AppLocalization { final Locale locale; const AppLocalization(this.locale); static AppLocalization? of(BuildContext context) => Localizations.of<AppLocalization>(context, AppLocalization); Flutter Complete Reference 375",
  ". Localization and internationalization static Future<AppLocalization> load(Locale locale) async { final String localeName = Intl.canonicalizedLocale( locale.languageCode ); // It produces an error now but it's fine; it will // disappear as soon as we use code generation to // create internationalization utilities await initializeMessages(localeName); // Setup intl to work with the device's locale Intl.defaultLocale = localeName; return AppLocalization(locale); } String get helloWorld => Intl.message( \"Hello world!\", name: \"helloWorld\", ); String get hello => Intl.message( \"Hello\", name: \"hello\", ); } Strings that need to be internationalized and/or localized are de\ufb01ned as getters returning the result of Intl.message, which is made up of two basic (required) parameters: . the string itself, such as \"Hello world!\"; . the exact name of the getter which returns the string to be localized. To be clear, this is \ufb01ne: String get helloWorld => Intl.message( \"Hello world!\", name: \"helloWorld\", ); Flutter Complete Reference 376",
  ". Localization and internationalization But this is not \ufb01ne because the name parameter doesn\u2019t exactly match the getter name: String get helloWorld => Intl.message( \"Hello world!\", name: \"hello_world\", // NO, must be \"helloWorld\" ); Getters de\ufb01ned inside AppLocalization contain the \"default\" value of the string and in order to internationalize them, we need to use a code generator. flutter pub run intl_translation:extract_to_arb --output-dir=lib/localization/arb_files lib/localization/app_localization.dart Open the command line from your environment or, in Android Studio, just click the Terminal label at the bottom and type the above command. It will generate, in localization/arb_files, an .arb \ufb01le which is used to manage translations of strings in various languages. \u009f ARB \ufb01les are nothing more than JSON \ufb01les whose keys start with \"@\". They can be edited manually by you with a simple text editor but the more languages and strings you\u2019re going to support, the harder they become to handle. \u2022 Localizely \u2022 BabelEdit \u2022 Crowdin The above list is a series of localization services that help you (or your team) with the management of ARB \ufb01les. We recommend you to look at them because manual management gets exponentially harder for each new language you decide to support. The tool generates intl_messages.arb: it\u2019s a JSON format map with one entry for each Intl.message() function de\ufb01ned in AppLocalization. It\u2019s a template you can use to create one ARB \ufb01le per locale: localization/ arb_files/ intl_messages.arb intl_en.arb intl_it.arb Flutter Complete Reference 377",
  ". Localization and internationalization intl_es.arb dart_files/ Each \ufb01le contains the various translations of the strings you de\ufb01ned in AppLocalization. You should not touch the keys of the JSON map otherwise the automated tool will fail; just change the string values. Here\u2019s an example: // A piece of 'intl_en.arb' \"hello\": \"Hello\", \"@hello\": { ... } // A piece of 'intl_it.arb' \"hello\": \"Ciao\", \"@hello\": { ... } // A piece of 'intl_es.arb' \"hello\": \"Hola\", \"@hello\": { ... } As you can see, the \"translations database\" is made up of the various ARB \ufb01les. In order to use them in your Flutter app, run this command which converts those JSON maps into .dart \ufb01les. flutter pub run intl_translation:generate_from_arb --output-dir=lib/localization/dart_files --no-use-deferred-loading lib/localization/app_localization.dart lib/localization/arb_files/intl_en.arb lib/localization/arb_files/intl_it.arb lib/localization/arb_files/intl_es.arb The tool has generated a series of \ufb01les inside your dart_files/ which are the ones Flutter is going to look for when it comes to internationalizing strings. Notice that code generation created the initializeMessages method inside AppLocalization so that you can now successfully compile. static Future<AppLocalization> load(Locale locale) async { ... // No errors anymore await initializeMessages(localeName); ... Flutter Complete Reference 378",
  ". Localization and internationalization } ..2 Localization delegate The creation and setup of the delegate \"links\" your custom localization logic (AppLocalization) to the app itself (MaterialApp or CupertinoApp). It\u2019s very similar to the manual approach: class AppLocalizationDelegate extends LocalizationsDelegate<AppLocalization> { const AppLocalizationDelegate(); @override bool isSupported(Locale locale) => [\"en\", \"it\", \"es\"].contains(locale.languageCode); @override Future<AppLocalization> load(Locale locale) => AppLocalization.load(locale) @override bool shouldReload(LocalizationsDelegate<AppLocalization> d) => false; } And again, remember to setup the delegate and the supported locales list in your app\u2019s root widget: return MaterialApp( localizationsDelegates: [ const AppLocalizationDelegate(), GlobalMaterialLocalizations.delegate, GlobalCupertinoLocalizations.delegate, GlobalWidgetsLocalizations.delegate, ], supportedLocales: const [ Locale.fromSubtags(languageCode: \"en\"), Locale.fromSubtags(languageCode: \"it\"), Locale.fromSubtags(languageCode: \"es\"), ], ); Flutter Complete Reference 379",
  ". Localization and internationalization Strings can be obtained in the same way we have seen in the previous section. The di\ufb00erence is that, instead of passing a String or an enum, you\u2019re using a getter. // Good but there are null-checks to do Text(AppLocalization.of(context)?.helloWorld ?? \"-\"); As we had already suggested in the previous section, you should prefer the usage of extension methods. You\u2019d have to use context.localize.helloWorld which is shorter, more readable and doesn\u2019t involve nullable types. ..3 Plurals and data interpolations The intl internationalization strategy is pretty handy when it comes to advanced strings localiza- tion. For example consider having an application that, according with today\u2019s date, has to show a countdown label: final days = getDaysLeft(); final value = \"$days days remaining.\"; It\u2019s \ufb01ne but there\u2019s a problem with the plural when the days left counter is 1 or . The output might be one of the following: \u2022 \"2 days remaining.\" \u2022 \"1 days remaining.\" (the noun should be singular) \u2022 \"0 days remaining.\" (doesn\u2019t make much sense) We should \ufb01x the code in order to get proper singular/plural nouns and, in case of the counter being zero, show a di\ufb00erent message. It\u2019s doable with a bit of boilerplate code but strings are still not internationalized: final days = getDaysLeft(); var value = \"$days days remaining.\"; if (days == ) { value = \"$days day remaining.\"; } if (days == ) { value = \"No days left.\"; } Flutter Complete Reference 380",
  ". Localization and internationalization Now it\u2019s better but strings are not internationalized and thus we should work on localization, which is even more boilerplate code to add. intl o\ufb00ers a very elegant solution to deal with plurals and arguments: class AppLocalization { final Locale locale; const AppLocalization(this.locale); // other code... String remainingDays(int days) => Intl.plural(days, zero: \"No days remaining\", one: \"One day left\", other: \"$days days remaining\", name: \"remainingDays\", args: [days], ); } According with the number of days left, intl shows a di\ufb00erent string and it can also interpolate values. We\u2019ve used a function because getters cannot declare input parameters: \u2022 zero: string returned when days is ; \u2022 one: string returned when days is ; \u2022 other: string returned when days is >= ; As usual, launch the command line tools and translate the strings into the generated ARB \ufb01les. Once you\u2019ve got the dart \ufb01les with the localization, you\u2019ll be able to call this from your widgets: final days = getDaysLeft(); final value = AppLocalization.of(context)?.remainingDays(days) ?? ; /* * days =  | \"No days remaining\" * days =  | \"One day left\" * days =  | \"2 days remaining\" * days =  | \"3 days remaining\" ... */ Flutter Complete Reference 381",
  ". Localization and internationalization With a single line of code you\u2019re able to not only localize a string, but also interpolate data (a number in this case), handling purals (days or day) and showing variants for the same string. Note that args parameter must contain, in order, the arguments that are being interpolated in the strings. .4 Considerations Both internationalization ways are \ufb01ne but one might be better than the other under certain circumstances. They can also be implemented with similar steps; the di\ufb00erence lies on the data source from which they extract the various strings translations: Manual Using intl . Create class AppLocalization and also an extension method, which is very convenient. . Fill the database (it\u2019s a Map<K, V>). . Create the localization delegate. . Create class AppLocalization and also an extension method, which is very convenient. . Create .arb \ufb01les by copy/pasting the generated template. . Translate strings and convert from .arb to .dart. . Create the localization delegate. a When the application starts, the device\u2019s locale is recognized and automatically passed to the delegate so that the user isn\u2019t asked to select its language. Only for iOS, there\u2019s an extra step to do in order to get localization working properly: \u2022 open with XCode the project under the ios/ folder; \u2022 under the Runner folder, open the Info.plist \ufb01le; \u2022 select Information Property List, click Add item and then choose Localization \u2022 add one entry per locale, such as English, Italian, Spanish etc. Keep consistency with the list you\u2019ve declare in supportedLocale While both localization approaches are perfectly \ufb01ne, there are cases in which one suits better than the other. Take the following considerations just as general guidelines: Flutter Complete Reference 382",
  ". Localization and internationalization \u2022 Manual \u2013 Good when there are a few languages to support, like two or three, and a relatively small amount of terms/sentences to localize. To be more precise, this approach is good as long as you\u2019re able to manually maintain the strings database in a reasonable amount of time. \u2013 Very easy setup. \u2013 No generation tools or external \ufb01les involved. \u2022 intl \u2013 Good when there is a wide range of languages to support, like four or more. It supports plurals management, strings interpolation and also other localization utilities such as date format and currencies. \u2013 Easy setup but an e\ufb03cient ARB \ufb01les management requires an external tool. \u2013 Relies on code generation tools and external ARB \ufb01les. We can say that intl is very powerful and scalable but such strength isn\u2019t always required for smaller applications. If you\u2019re working on a team, using ARB \ufb01les is essential as they can be shared and managed by a GitHub repository or external tools. Localizely is a service that allows you to easily work with strings localization using ARB \ufb01les. It\u2019s especially powerful when you\u2019re working on a team and/or your apps have to support many languages. They o\ufb00er a free plan for open source projects publicly hosted on GitHub; take a look at their website 3 for more info. 3https://localizely.com Flutter Complete Reference 383",
  ". Localization and internationalization By installing the Flutter Intl plugin for Android Studio or VS Code you get the possibility to integrate your ARB \ufb01les with Localizely. They can be uploaded to the website and later downloaded with the newly localized strings so that you only need to compile them into .dart \ufb01les. Flutter Complete Reference   | Animations When using Flutter, the developer is able to control each single pixel of the UI so that he can fully customize the design of the app. Animations are no exception as the framework gives you the possibility to create something from scratch or using the built-in widgets. There are three types of \"implementation di\ufb03culty\" when it comes to making animations: . Implicit animations: it\u2019s a series of pre-built widgets integrated in the Flutter SDK and ready for you to use. They are very convenient: sometimes they don\u2019t even need a setup because default settings are just \ufb01ne. . Animation library: inheritable classes or utility widgets that help you building custom animations. They give you more control on the animation itself and the possibility to manually improve performances. . Custom animations: animations made from scratch by using speci\ufb01c classes such as Matrix4 (4D matrix) or Transform. You\u2019re creating \"low level\" animations using trigonom- etry by directly controlling the 3D space. We are covering all of those animation techniques, which have been sorted from the easiest to the hardest. Flutter helps the developer even in the most complicated scenarios; nevertheless, building complex animations is not so straightforward as it requires some maths and experience. .1 Implicit animations Thanks to the animation facilities shipped with the SDK you can add animated widgets and create visual e\ufb00ects in your UI with a minimal e\ufb00ort. Flutter o\ufb00ers a set of pre-built widgets, called implicitly animated widgets, that manage animations automatically: in most of the cases, you\u2019ve almost nothing to do. Flutter Complete Reference 385",
  ". Animations \u009f Not every widgets have their animated counterpart but the Flutter team might im- plement them in the future. Generally, the animated version of a widget is called An- imatedFoo where Foo is the name of a \"standard\" UI component such as a Container. The developer has almost nothing to do in order to animate a widget: it\u2019s just a matter of assigning one or two parameters. Look at this simple container whose dimensions are determined by the counter variable held by a provider: // \"CounterModel\" is exposed by a ChangeNotifierProvider // so the dimensions vary at any change of the variable. Consumer<CounterModel>( builder: (_, counter, __) { return Container( height: counter, width: counter, color: Colors.lightBlue, alignment: Alignment.center, ); } ) When the value of counter changes the container resizes as well but with no animation (you see an \"immediate\" change). For a better user experience, you can animate the size change by simply renaming the widget and setting the duration. Consumer<CounterModel>( builder: (_, counter, __) { return AnimatedContainer( height: counter, width: counter, color: Colors.lightBlue, alignment: Alignment.center, duration: const Duration(seconds: ), ); } ) That\u2019s it, changes are automatically animated for you. We\u2019ve just renamed a widget and the ani- mation is ready. With a bit more of e\ufb00ort it\u2019s also possible, for example, changing the background Flutter Complete Reference 386",
  ". Animations color or the Container and setting a di\ufb00erent animation type. color: counter %  ==  ? Colors.lightBlue : Colors.lime, alignment: counter <  ? Alignment.center : Alignment.topCenter, curve: Curves.easeInOut, The default curve is Curves.linear but thanks to the curve parameter you can change the animation type. Check the o\ufb03cial documentation 1 to see a complete list of curves that Flutter currently supports. \u009f A curve is a mathematical function that expresses how values change over the time. For example, a linear curve is a type of animation which executes at constant speed for all of its duration. As time goes by (horizontal axis) the values changed by the animation (vertical axis) follow a linear trend. That\u2019s why in the \ufb01rst animated example the size \"linearly\" changes. 1https://api.\ufb02utter.dev/\ufb02utter/animation/Curves-class.html Flutter Complete Reference 387",
  ". Animations The animation described by a easeInOut starts slowly, speeds up and then \ufb01nishes slowly again. The documentation has a very nice page with a detailed description for each curve and short video that shows how the animation looks like. We\u2019re now going to showcase the entire list of implicitly-animated widgets at the time of writing this book. In any case, you\u2019ll always have the possibility to set the duration and the type of curve. \u2022 AnimatedAlign. Animated version of the Align widget that transitions the position of a child widget from one area of the screen to another. Here\u2019s an example: // Somewhere 'value' has been declared as 'int' AnimatedAlign( alignment: value %  ==  ? Alignment.center : Alignment.topCenter, duration: const Duration(seconds: ), ) \u2022 AnimatedOpacity. Animated version of the Opacity widget that transitions the opacity of a child widget from one value to another. The opacity parameter can range from 0 to 1 where 0 makes the widget invisible. // Somewhere 'value' has been declared as 'int' AnimatedOpacity ( opacity: value, duration: const Duration(seconds: ), curve: Curves.easeInOut, Flutter Complete Reference 388",
  ". Animations ) In terms of performances, this widget is relatively expensive (as it requires an intermediate bu\ufb00er) so use it carefully (or avoid using it at all). \u2022 AnimatedDefaultTextStyle. Animated version of the DefaultTextStyle widget that transitions the style of a Text widget from the current setup to a di\ufb00erent one. // Somewhere 'color' and 'fontSize' have been declared and they // can change over the time AnimatedDefaultTextStyle( duration: const Duration(milliseconds: ), curve: Curves.elasticInOut, style: TextStyle( fontSize: fontSize, color: color, fontWeight: FontWeight.bold, ), child: const Text(\"Pasta\"), ) The animation is applied to any children whose type is Text so the same e\ufb00ect works on di\ufb00erent instances. For example, you could display multiple lines of text in a Column and every children will be equally animated: AnimatedDefaultTextStyle( duration: const Duration(seconds: ), style: TextStyle(...), child: Column( children: [ const Text(\"I'm animated\"), const Text(\"I'm animated as well\"), ] ), ) The unchanged properties such as textAlign, softWrap, textOverflow, and maxLines are not animated. \u2022 AnimatedPadding. Animated version of the Padding widget that transitions the padding between widgets from one value to another. Flutter Complete Reference 389",
  ". Animations AnimatedPadding( // 'value' has been declared somewhere and it may change duration: const Duration(minutes: ), padding: EdgeInsets.only(top: value), child: const Text(\"Padding!\"), ) \u2022 AnimatedPhysicalModel. Animated version of the PhysicalModel widget that transitions the elevation, the color and the border radius of the widget. The shape is not animated. // Somewhere 'value' has been declared as 'int' AnimatedPhysicalModel ( duration: const Duration(seconds: ), borderRadius: BorderRadius.circular(value), elevation: value, shape: BoxShape.rectangle, color: Colors.lightBlue, shadowColor: Colors.black45, child: const Text(\"Hello\"), ), This widget requires you to de\ufb01ne, at least, all those parameters. If you want to also add a transition e\ufb00ect for the background color of the shape, you have to set animateColor: true. // Somewhere 'canChange' has been declared as 'boolean' AnimatedPhysicalModel ( // code... animateColor: true, color: canChange ? Colors.lime : Colors.black, child: const Something(), ), \u2022 AnimatedPositioned. Animated version of the Positioned widget that transitions the position from a point of the screen to another. It works only when inside a Stack. // Somewhere 'value' has been declared as 'int' Stack( children: [ AnimatedPositioned( duration: const Duration(seconds: ), top: value, Flutter Complete Reference 390",
  ". Animations right: , child: const Text(\"Hello\"), ), ] ), Pay attention: with this widget, the size of the child would change at the end of the animation. If the child must not change its dimensions, consider using a SlideTransition we\u2019re going to cover later. \u2022 AnimatedCrossFade. This widget cross-fades between two children and animates while the transition (with the eventual resize) is happening. For example, when an item goes out of stock you want to replace the purchase button with some text saying \"SOLD OUT!\". // Somewhere 'canBuy' has been declared as 'bool' AnimatedCrossFade ( duration: const Duration(seconds: ), crossFadeState: canBuy ? CrossFadeState.showFirst : CrossFadeState.showSecond, firstChild: RaisedButton( child: const Text(\"Buy item\"), onPressed: () {...} ), secondChild: const Text(\"SOLD OUT!\"), ), firstChild appears if CrossFadeState is showFirst otherwise secondChild is shown. Changing this value animates the transition between the two widgets. \u2022 AnimatedSize. Animated version of the Size widget that transitions the size whenever its child\u2019s size changes. In other words, this widget automatically animates the resizing when its child changes dimensions. // Somewhere 'value' has been declared as 'int' AnimatedSize( duration: const Duration(seconds: ), curve: Curves.easeIn, child: Container( width: , height: value ) Flutter Complete Reference 391",
  ". Animations ), Whenever the Container changes the height, the AnimatedSize widget will automatically change its height as well. \u2022 AnimatedIcon. Animated version of the IconData widget which animates the transition of an icon from a shape to another. AnimatedIcon( icon: AnimatedIcons.menu_arrow, progress: controller, ) In the next section you\u2019ll understand how AnimatedController controller works. The menu_arrow constant is basically an hamburger icon which can change into a back arrow with a nice rotation: Visit the o\ufb03cial documentation for the AnimatedIcon class 2 to see a complete list of all the available animated icons. .2 The animation library When you\u2019re looking for a more advanced type of animation, very likely implicit animations won\u2019t be enough anymore. They\u2019re customizable... but not so much. In this case you need to create the animation by yourself working with controllers and values. From now on, you should be familiar with some basic trigonometry. ..1 AnimatedWidget The creation of an animation involves generally two steps. We\u2019re going to show them by creating a simple app which has a rotating Flutter logo at the center of the screen. Here\u2019s some captures of the running animation to get the idea: 2https://api.\ufb02utter.dev/\ufb02utter/material/AnimatedIcons-class.html Flutter Complete Reference 392",
  ". Animations We\u2019re going to use a widget called FlutterLogo() which simply shows a high quality Flutter logo. It\u2019s like a vectorial image and thus it can be resized without losing quality. Let\u2019s create the rotating animation: . Our goal is taking a class FlutterLogo() and animating it with an endless rotation. An AnimatedWidget has the purpose of taking any widget and providing facilities to animate it so we\u2019re going to use it: import 'dart:math' as math; // 'AnimatedWidget' can animate any widget class RotatingLogo extends AnimatedWidget { final AnimationController _controller; const RotatingLogo({ required AnimationController controller }) : _controller = controller, super(listenable: controller); // (a). static const _fullRotation =  * math.pi; @override Widget build(BuildContext context) { // (b). return Transform.rotate( // (c). angle: _controller.value * _fullRotation, child: const FlutterLogo( Flutter Complete Reference 393",
  ". Animations size: , ), ); } } When working with animations, const constructors are even more important because they tell Flutter to not rebuild certain widgets every frame. The framework has a very high refresh rate (up to 120 fps) so unneeded rebuilds might waste resources. (a) In order to achieve a full rotation, values for angle must range from 0 to 360 degrees. Since Flutter works with radians, there\u2019s the need to make a conversion. (b) The Transform.rotate() named constructor returns a rotated widget with an angle of given radians. That\u2019s why we had to use the math.pi constant. (c) The listenable object is passed via constructor following the good dependency injec- tion practices. You\u2019ll see soon that _controller.value is constantly updated every frame and it\u2019s what gives \"life\" to the widget making it rotate. Transform.rotate() itself doesn\u2019t give motion to the widget, it just sets a speci\ufb01c inclina- tion and nothing more. The rotation animation is obtained because _controller.value constantly changes and the widget is rebuilt so that, at each frame, you see the widget with a di\ufb00erent angle. . Now it\u2019s time to put the animation on the widget tree and give it the data source for motion. The AnimationController class generates data with a speci\ufb01c frequency and a given duration. By default, a controller emits values from 0 to 1 with a linear interval. Our animated widget receives them and gets rebuilt. The _controller variable holds a reference to the animation controller and value represents values that periodically arrive. Flutter Complete Reference 394",
  ". Animations angle: _controller.value * _fullRotation, The product between the emitted values and the angle (in radians) represents the rotation of the logo at a certain frame. Here\u2019s how to link a controller to the widget: class FLSpinner extends StatefulWidget { const FLSpinner(); @override _FLSpinnerState createState() => _FLSpinnerState(); } class _FLSpinnerState extends State<FLSpinner> with TickerProviderStateMixin { // (a). late final AnimationController _controller; @override void initState() { super.initState(); _controller = AnimationController( duration: const Duration(seconds: ), // (b). vsync: this, )..repeat(); // (c). } @override void dispose() { _controller.dispose(); super.dispose(); } @override Widget build(BuildContext context) { return RotatingLogo(controller: _controller); } } Flutter Complete Reference 395",
  ". Animations A StatefulWidget is essential here because there\u2019s the need to dispose the controller when the widget is \"destroyed\"; in this way the animation won\u2019t waste resources. Always remem- ber to initialize and clean the animation instances via initState and dispose. (a) The AnimationController class 3 continuously generates a series of values, for a given duration, whenever the hardware is ready for a new frame. By default it produces values from .0 to .0 for the entire duration. (b) The AnimationController class generally generates 60 new values per second but it may vary according with the refresh rate of the device. Having multiple animations running even if they aren\u2019t visible might cause a performance drop. (c) The repeat() method executes the animation forever. In our example, it means that there will be an in\ufb01nite chain of animations lasting for the given duration (3 seconds). The class gives you the \ufb02exibility to choose between di\ufb00erent behaviors: \u2022 forward: starts the animation forward, in the sense that values vary from start to the end. ( > ) \u2022 reverse: starts the animation reverse, in the sense that values vary from the end to the start. ( > ) \u2022 repeat: starts the animation in forward direction and then restarts it (in the same direction). ( > ,  > ,  > ...) If you used forward() instead of repeat() you\u2019d have seen the logo spinning around only once and not forever. AnimationController( vsync: this, ) The vsync parameter of the controller prevents o\ufb00screen animations from consum- ing unnecessary resources . Initializing it with this gives the stateful widget the possibility of handling the animation resources automatically. ... with TickerProviderStateMixin {} There\u2019s the need to add this mixin to your class because it allows a StatefulWidget to be assignable to a vsync, which is an instance of a TickerProvider (a class internally used by animations). 3https://api.\ufb02utter.dev/\ufb02utter/animation/AnimationController-class.html 4https://\ufb02utter.dev/docs/development/ui/animations/tutorial Flutter Complete Reference 396",
  ". Animations The setup for the animation is now ready. We\u2019ve worked on two parts: the widget being animated, RotatingLogo, and the surrounding widget, FLSpinner, which is responsible for periodically generating new values with a controller. MaterialApp( home: Scaffold( appBar: AppBar( title: const Text(\"Animations\"), ), body: const Center( child: FLSpinner(), ), ), ); The FLSpinner widget internally has a controller which generates, for the given duration, a series of values very frequently (generally 60 per second). These values are passed each time to the Transform object which is being repainted and thus the animation runs smoothly on the UI. ..2 AnimationBuilder The AnimationBuilder class is simply an AnimatedWidget which automatically optimizes the animations to avoid unnecessary rebuilds. Understanding how animations work is very important because you don\u2019t want them to slow down your app due to the lack of optimization in your Dart code. class RotatingLogo extends AnimatedWidget { // Constructor, getter and other code omitted for brevity @override Widget build(BuildContext context) { return Transform.rotate( angle: _controller.value * _fullRotation, child: const FlutterLogo( size: , ), ); } } Flutter Complete Reference 397",
  ". Animations As you already know, thanks to a constant constructor the FlutterLogo widget is built only once. What gets rebuilt every /60 of second (potentially /) is only the Transform widget because it has to actually make the animation. // 'Container' has no constant constructor so it's not cached Transform.rotate( angle: _controller.value * _fullRotation, child: Container(...) ), Pretend you had the same situation but rather than having a simple FlutterLogo to rotate there would be a Container with many non-constant children. It happens quite often when working with rows and columns as well because they have no const constructor. \u009f If children of Container were not constant as well the situation might be even worse. The framework could potentially rebuild every /60 second a big part of a subtree: it might not be e\ufb03cient at all. In such cases, where you cannot have a const constructor, there are two possible solutions that should really be taken into account: . Manually cache the portion of the tree that doesn\u2019t depend on the animation so that the framework won\u2019t rebuild it every time. late final Widget _cachedTree = _cachedTree(); @override Widget build(BuildContext context) { return Transform.rotate( angle: _controller.value * _fullRotation, child: _cachedTree, ); } Widget _cachedTree() { return Container( child: Row( children: [ Flutter Complete Reference 398",
  ". Animations WidgetNonConst1(), WidgetNonConst2(), ] ) ); } This is the equivalent of using a constant constructor; the initialization of the final variable is executed only once so subsequent rebuilds will take e\ufb00ect only on Transform. . Make the code more readable with less boilerplate using AnimatedBuilder, which internally uses an AnimatedWidget and does the caching for you. @override Widget build(BuildContext context) { return AnimatedBuilder( animation: someController, builder: (context, child) { return Transform.rotate( angle: _controller.value * _fullRotation, child: child, ); } child: Container(... ), ); } The child parameter holds the part of the tree being cached (so that it gets built only once). The builder part instead contains the animation logic and the child parameter is a reference to the cached subtree. Which widget should you use between AnimatedBuilder and AnimatedWidget? The one that you like more because they both do the same thing! Look at how Flutter internally implements class AnimatedBuilder: class AnimatedBuilder extends AnimatedWidget { final TransitionBuilder builder; final Widget child; const AnimatedBuilder({ Key? key, Flutter Complete Reference 399",
  ". Animations required Listenable animation, required this.builder, this.child, }) : super(key: key, listenable: animation); @override Widget build(BuildContext context) { return builder(context, child); } } This is the exact same thing we\u2019ve done in the \ufb01rst option of the above list: the child param- eter is stored in a final instance so that it doesn\u2019t get rebuilt every frame. It\u2019s doing \"manual caching\". This is a very important optimization you have to keep in mind when creating custom animations. \u009f Don\u2019t ask yourself which widget is the best because they really do the same thing, use the one that you like more. Maybe AnimatedBuilder could the a bit better because it leads to less boilerplate and increases the readability of the code. ...1 Curves Any animation is linear by default, meaning that values are emitted at a constant speed like it happens with the rotating logo that we\u2019ve created. It\u2019s of course possible to alter this behavior and make something more interesting, such as a \"bouncing\" e\ufb00ect: late final AnimationController _controller; late final CurvedAnimation _curved; @override void initState() { super.initState(); _controller = AnimationController( duration: const Duration(seconds: ), vsync: this, )..repeat(); _curved = CurvedAnimation( parent: _controller, Flutter Complete Reference 400",
  ". Animations curve: Curves.bounceIn, ); } Widget build(BuildContext context) { return RotatingLogo(controller: _curved); } Instead of rotating at a constant speed, the logo will have a bouncing animation executing at di\ufb00erent speeds. Instances of CurvedAnimations don\u2019t need to be disposed; you can choose between a myriad of e\ufb00ects (* is a placeholder): \u2022 Curves.bounce*: bouncing e\ufb00ects such as bounceIn or bounceOut; \u2022 Curves.easeIn*: ease in e\ufb00ects such as easeInCubic or easeInSine; \u2022 Curves.easeOut*: ease out e\ufb00ects such as easeOutQuartic or easeOutExpo; \u2022 Curves.elastic*: elastic e\ufb00ects such as elasticIn or elasticOut; If you want to have a quick video preview of how an animation type looks like visit the o\ufb03cial documentation 5 about the Curve class. Do you want to have a bouncing animation executed in the opposite direction? late final AnimationController _controller; late final CurvedAnimation _curved; late final ReverseAnimation _reverse; @override void initState() { super.initState(); _controller = AnimationController( // code... )..repeat(); _curved = CurvedAnimation( // code... ); _reverse = ReverseAnimation(_curved); } 5https://api.\ufb02utter.dev/\ufb02utter/animation/Curves-class.html Flutter Complete Reference 401",
  ". Animations RotatingLogo(controller: _reverse) will now run the same bouncing animation but in the opposite direction. If you wanted the original spinning logo animation to rotate backwards, you\u2019d simply have to do this: @override void initState() { super.initState(); _controller = AnimationController( // code... )..repeat(); _reverse = ReverseAnimation(_controller); } It repeats the animation forever but running backwards. You could have used reverse() instead of repeat() but then the animation would have ran only once and not forever. _controller = AnimationController( // code... )..reverse(); It does the same thing as ReverseAnimation but you cannot loop forever. ...2 Tweens By default an AnimationController produces a series of double values ranging from 0 to . Thanks to Tween<T> you can alter this behavior for the cases where something di\ufb00erent from numbers in [..] is required. late final AnimationController _controller; late final Animation<double> _tween; @override void initState() { super.initState(); _controller = AnimationController( duration: const Duration(seconds: ), vsync: this, )..repeat(); _tween = Tween<double>( begin: , end:  * math.pi, Flutter Complete Reference 402",
  ". Animations ).animate(_controller); } This tween alters the behavior of the controller which now ranges from 0 to .... and not anymore from 0 to . With this change, going back to the original spinning logo example, we could have changed the code to make it look like this: // This isn't needed anymore because the controller already // produces values from 0 to 2pi, so no conversions at all! // // static const _fullRotation =  * math.pi; @override Widget build(BuildContext context) { return Transform.rotate( // Earlier it was '_controller.value * _fullRotation' angle: _controller.value, child: const FlutterLogo( size: , ), ); } The values produced by the controller are already in the range [, 2pi] so we can directly pass _controller.value. We had to make a conversion in the previous example because values were emitted in the default [, ] range. With Tween<T> you can create a wide range of animations that aren\u2019t strictly tied to numbers. You could for example animate the color transition of a button: late final AnimationController _controller; late final Animation<Color> _colorTween; @override void initState() { _controller = AnimationController(...); _colorTween = ColorTween( begin: Colors.white, end: Colors.green ).animate(_controller); super.initState(); Flutter Complete Reference 403",
  ". Animations } @override void dispose() { _controller.dispose(); super.dispose(); } void _buttonTapped() { if (_controller.status == AnimationStatus.completed) { _controller.forward(); } else { _controller.reverse(); } } Thanks to ColorTween the color property of any widget is animated from the starting value to the ending value. As you can see it\u2019s not di\ufb03cult at all. AnimatedBuilder( animation: _colorTween, builder: (context, child) { return RaisedButton( child: child, color: _colorTween.value, onPressed: _buttonTapped, ); }, child: const Text(\"Animate me!\"), ), Notice how we\u2019ve e\ufb03ciently cached the Text widget which doesn\u2019t require rebuilds as it\u2019s not part of the animation. When the button is tapped, the animation runs forward or backwards according to the completion status. There are many kinds of tweens: \u2022 BorderRadiusTween, \u2022 IntTween, \u2022 DecorationTween, Flutter Complete Reference 404",
  ". Animations \u2022 ShapeBorderTween, \u2022 SizeTween, And much more! Visit the o\ufb03cial documentation 6 to see them all. .3 Custom animations If you\u2019re looking for speci\ufb01c kinds of animations, such as 3D ones or simply motions that aren\u2019t directly supported by Flutter with a particular widget, it\u2019s time to do some maths. \u009f While we will try to be as clear as possible, you\u2019ll need some skills on matrices and trigonometry to get the most out of this section. Here we\u2019re working in the 3D space so math is really required. Marcin Sza\u0142ek made a great talk at Flutter Europe about this topic, which is available on YouTube . Creating complex animations in Flutter is really a matter of being able to master the combi- nation of three classes only: \u2022 AnimationController: emits a certain range of values with a given frequency in order to animate a widget; \u2022 Transform: scales, rotates, skews or alters the aspect of a widget using matrices; \u2022 Stack: overlaps a series of children and allows custom positioning using the Positioned widget. Let\u2019s try to create a container with a little skew that rotates on the Y-axis periodically. It looks like a 3D animation where the container rotates around its left side. Here are some frames of the animation: 6https://api.\ufb02utter.dev/\ufb02utter/animation/Tween-class.html 7Implementing complex UI with Flutter - Marcin Sza\u0142ek Flutter Complete Reference 405",
  ". Animations While it might seem quite hard to achieve, it\u2019s just a matter of calling two Transform methods and wrapping them in the usual AnimatedBuilder (which does the actual animation by emitting new values). class _DemoAppState extends State<DemoApp> with SingleTickerProviderStateMixin { late final AnimationController _controller; @override void initState() { super.initState(); _controller = AnimationController( vsync: this, duration: const Duration(seconds: ), )..repeat(); } @override void dispose() { _controller.dispose(); super.dispose(); } @override Widget build(BuildContext context) {...} } Nothing new up to here, it\u2019s just the \"traditional\" setup for animations where you declare a Flutter Complete Reference 406",
  ". Animations controller which is properly disposed inside void dispose();. The interesting part is the build method: @override Widget build(BuildContext context) { return AnimatedBuilder( animation: _controller, builder: (context, child) { return Transform( transform: Matrix4.skewY(.) ..rotateY(_controller.value *  * math.pi), child: child, ); }, child: Container( decoration: const BoxDecoration(...), // 'child' is simply a 'Text' widget with // some styling declared via 'TextStyle' child: ... ), ); The usage of a AnimatedBuilder caches the container and the text, which are not animated. Let\u2019s analyze the Transform class: \u2022 the skewY(double value) method keeps the widget sides parallel while inclinating the whole children in a certain direction, determined by double value. \u2022 calling rotateY(double radians) rotates the children along the given axis, in our case Y, making it look like if it were a 3D motion. There are three kind of rotations: . rotateX(double radians) . rotateY(double radians) . rotateZ(double radians) Feeding the rotateY method with new values at 60 fps, shows a smooth 3D rotation. On a side note, it\u2019s possible making the animation going on forever but it\u2019d only move forth and back rather than always in the forward direction. // This is like calling 'forward()' forever Flutter Complete Reference 407",
  ". Animations _controller.repeat(); // This is like calling 'forward()' and then 'reverse()' forever _controller.repeat(reverse: true); // . While in the \ufb01rst case the animation always goes in a single direction (forward), in the second one it goes back and forth. We\u2019re now showing another simple example in which a container, once tapped, scales and moves to another position of the screen with a sliding animation. Scaling widgets and moving them is actually very easy because Transform exposes both scale() and translate(). We\u2019re able to decide the direction in which the animation has to run thanks to the AnimationStatus enum. // 'onPressed' callback for the button void _moveMe() { if (_controller.status == AnimationStatus.completed) _controller.reverse(); else _controller.forward(); } On the \ufb01rst tap the animation goes forward while on the second one the widget \"restores\" to its Flutter Complete Reference 408",
  ". Animations original position and size. In order to easily move on the screen without interfering with other widgets, the combination of Stack and Positioned is the perfect choice. AnimatedBuilder( animation: _controller, builder: (context, child) { final scale =  - (_controller.value * .); // scaling logic final newPos =  + (_controller.value * ); // position control return Stack( children: [ Transform( transform: Matrix4.identity() ..scale(scale) ..translate(newPos, newPos), child: child, ), const Text(\"Hello\"), ] ); }, child: RaisedButton( child: Text(\"Move me\"), onPressed: _moveMe ), ); The identity matrix returned by identity() is the \"starting point\" when scaling or translating widgets. Very easily, Matrix4 is a 4x4 matrix which is used to represent the coordinates of a 3D space and apply calculations on them. The screen has two dimensions (width and height) but thanks to matrices we\u2019re able to work in three dimensions (width, height and depth) even if the available plan is \"\ufb02at\". . final scale is used to determine how much the child is going to resize (getting smaller in forward() or bigger in reverse()); . final newPos moves the child from a position on the screen to another. The translate() method can take three parameters indicating the x, y and z coordinates of the widget. By changing them, you\u2019re able to move the child; Flutter Complete Reference 409",
  ". Animations . We recommend using a Stack so that the moving widget doesn\u2019t cause problems to the position of other widgets. Since a Stack is a series of overlapped \"levels\", widgets can move without interfering with others. You could make countless di\ufb00erent animations since the only limit is your creativity. The point is that you really just need a controller, a Stack and the Transform widget along with its matrices and calculations. Don\u2019t be afraid to get lost in the \"animation\" world; just by using those three classes together you possess a great power! .4 Good practices There\u2019s been a lot of information up to here about how you can animate widgets in Flutter and a recap might be very useful. Our suggestions come from both the documentation and the personal experience we\u2019ve acquired: mastering animations is very doable but a lot of practice is required! \u2022 When it comes to implementing an animation, the \ufb01rst thing we recommend is trying to see if Flutter has an implicit animation that might \ufb01t for the use case. They are pre-made animations o\ufb00ered by the framework which can be implemented with a minimal e\ufb00ort (sometimes you don\u2019t even need to setup any parameter): . AnimatedAlign . AnimatedOpacity . AnimatedPadding . ... and in general, many AnimatedFoo widgets. They basically are the animated counterparts of standard Flutter widgets with a few addi- tions required to setup the animation. They are very easy to use but actually not too much customizable if compared to an AnimatedBuilder. Using implicit animations have a some advantages: \u2013 They keep consistency between the animated and non-animated version of the same widget. If you know how the Padding widget works AnimatedPadding is exactly identical (with the addition of motion). \u2013 They\u2019re already in your Flutter installation ready to be used, why should you ignore them and create something from scratch? It would be a waste of time! \u2022 If what you\u2019re looking for is not available as an implicitly animated widget, start creating Flutter Complete Reference 410",
  ". Animations your own using an AnimatedWidget or an AnimatedBuilder. Both are the same thing but a builder requires a bit less code from your part; since developers are lazy, it might be the default choice. \u2022 Flutter tries to run at least at 60 frames per second, or anyway at the highest refresh speed supported by the hardware, so animations can be a problem if you don\u2019t optimize your code. For this reason, remember to: . use const constructors as much as possible in order to avoid unnecessary rebuilds that might impact the performance of the app; . if a constant constructor cannot be used, it\u2019s good practice caching the portion of the sub-tree either by storing it in a final variable or by using the AnimatedBuilder widget. \u2022 The AnimationController class gives \"life\" to your widgets: it produces, by default, values from 0 to 1 which are used to animate certain properties. Of course you\u2019re not tied to numbers alone, in fact controllers can emit di\ufb00erent type of values at di\ufb00erent speed rates: . with class Tween<T> you can change the range of values periodically emitted by a controller; . use widgets like CurvedAnimation or ReverseAnimation to have even more power on animations. \u2022 Very speci\ufb01c animations need to be created from scratch but there isn\u2019t the need to get lost in the vastness of the animation API provided by Flutter. It\u2019s just a matter of combining together three classes: . AnimationController; . Stack . Transform Transform is quite \"low level\" as it works with matrices and trigonometry but at the same time it\u2019s very powerful. It relies on values emitted from a controller so that the UI refreshes quickly and the animation runs smoothly. ..1 Hero animations A hero transition is a kind of animation which keeps the focus on a certain item while navigating from one route to another. If you tapped on an image in a certain route, there would be the Flutter Complete Reference 411",
  ". Animations possibility to open a new route and animating the Image widget so that it always stays in the foreground of screen. The image widget will nicely animate, remaining in the foreground, while the routes on the background are changing with another animation. In this way, the user\u2019s attention is kept on what he\u2019s tapped (the image, in our case). As always, implementing hero transitions in Flutter is quite easy: class RouteA extends StatelessWidget { const RouteA(); @override Widget build(BuildContext context) { ... Hero( tag: 'FlutterLogo' child: SvgPicture.asset(\"assets/flutter_logo.svg\"), ), ... } } Flutter Complete Reference 412",
  ". Animations class RouteB extends StatelessWidget { const RouteB(); @override Widget build(BuildContext context) { ... Hero( tag: 'FlutterLogo' child: SvgPicture.asset(\"assets/flutter_logo.svg\"), ), ... } } On both routes, there must be a Hero widget with the same tag property so that Flutter knows which hero has to be animated. Since Hero doesn\u2019t provide tap callbacks, generally it\u2019s wrapped it in a GestureDetector: GestureDetector( onTap: () => Navigator.of(context)?.pushNamed( RouteGenerator.routeB ), child: Hero( tag: 'FlutterLogo' child: SvgPicture.asset(\"assets/flutter_logo.svg\"), ), ), In this way, when tapping on the image, a hero animation will happen while navigating from a route to another. Be sure to check the o\ufb03cial documentation 8 for more examples and videos about hero animations. ..2 Custom route transitions When moving from a page to another using Navigator.of(context).pushNamed(...), Flutter applies a default material transition. Of course, you can easily change the animation type and it\u2019s even more straightforward with the RouteGenerator technique we\u2019ve explained in chapter 8https://\ufb02utter.dev/docs/development/ui/animations/hero-animations Flutter Complete Reference 413",
  ". Animations . class RouteGenerator { RouteGenerator._(); static Route<dynamic> generateRoute(RouteSettings settings) { switch (settings.name) { case homePage: return MaterialPageRoute( builder: (_) => HomePage(), ); case secondPage: return MaterialPageRoute( builder: (_) => SecondPage(), ); default: throw Exception(\"Route not found\"); } } static const String homePage = '/'; static const String secondPage ='/second'; } As it is, page transitions are handled by MaterialPageRoute which uses the default material animation. Let\u2019s say we want to customize our app by running a sliding transition when moving to the SecondPage route. You just need to create a new type of PageRouteBuilder, preferably inside a new \ufb01le called routes_transitions.dart. class SlidingPageRoute extends PageRouteBuilder { final Widget navigateTo; SlidingPageRoute({ required this.navigateTo }) : super( pageBuilder: (context, _, __) => navigateTo, transitionsBuilder: (context, animation, _, child) => SlideTransition( position: Tween<Offset>( Flutter Complete Reference 414",
  ". Animations begin: const Offset(-, ), end: Offset.zero, ).animate(animation), child: child, ), ); } Subclasses of PageRouteBuilder can de\ufb01ne the transitionBuilder callback which is used to create a custom type of animation to be run while navigating to the route. The callback passed to pageBuilder is used to build the page contents but since it is created in the build method of the page itself, just return the child itself (for \ufb02exibility and reusability purposes, don\u2019t implement route-speci\ufb01c logic here). case homePage: // Default material animation transition return MaterialPageRoute( builder: (_) => const HomePage(), ); case secondPage: // Custom sliding transition return SlidingPageRoute( navigateTo: const SecondPage(), ); Now you can replace MaterialPageRoute with SlidingPageRoute to apply the newly created transition when navigating to '/second'. However, if you \ufb01nd SlideTransition boring, just create another class and use another type of transition: // . ScaleTransition( scale: Tween<double>( begin: , end: , ).animate(animation), child: child, ) // . RotationTransition( Flutter Complete Reference 415",
  ". Animations turns: Tween<double>( begin: , end: , ).animate(animation), child: child, ), // . FadeTransition( opacity: Tween<double>( begin: , end: , ).animate(animation), child: child, ), Place all of these transitions in a dedicated class inside the routes_transitions.dart \ufb01le we created earlier so that any route-related animation is located in a single place. Flutter Complete Reference   | Working with JSON and other for- mats .1 Parsing JSON Nowadays JSON is one of the most popular data-interchange formats. For example, very likely you\u2019ll have to deal with HTTP requests returning a json-encoded string . Flutter has an incredible support for this format as it allows you to convert objects from and to JSON very quickly. { \"id\": , \"name\": \"Alberto\", } What\u2019s inside curly brackets is called json object and it\u2019s always made up of a string, which is the key of the \ufb01eld, and a value which can be a string, a number, a boolean, a list, null or another object. This is another example with a JSON array (or list): [ { \"id\": , \"name\": \"Alberto\", }, { \"id\": , \"name\": \"Patrick\", } ] Lists are simply collections of objects. In Flutter you can decide between manually parsing strings, Flutter Complete Reference 417",
  ". Working with JSON and other formats using facilities from import \"dart:convert\", or using automatic code generation, which does most of the work automatically. Both ways are \ufb01ne but you\u2019ll see that code generation simpli\ufb01es maintenance a lot, especially for large JSON objects. ..1 Manual parsing In all those cases where there\u2019s the need to deal with a list or small objects, parsing and main- taining JSON manually is \ufb01ne. The best approach to handle the received data is the creation of a model class from its JSON representation. In other words, you should convert a json-encoded string into a Dart class. Let\u2019s say we have to parse this string. { \"id\": , \"value\": \"json test\" } First of all there\u2019s the need to use the jsonDecode method, from \"dart:convert\", which trans- lates a json string into a Dart object whose type is Map<String, dynamic>. As we told you back in chapter , this is one of the rare cases in which dynamic has to be used. import \"dart:convert\"; void main () { final jsonString = '{ \"id\": , \"name\": \"Alberto\" }'; Map<String, dynamic> data = jsonDecode(jsonString); } If you think about it, this design choice really makes sense because a json object is nothing more than a map whose keys are strings and values can be integers, strings, objects or lists. There\u2019s the possibility to make a :1 comparison which is very expressive: JSON string Dart object { \"id\": , \"name\": \"Alberto\" } Map<String, dynamic> data = { \"id\": , \"name\": \"Alberto\" } The values of the map are dynamic because we have to take care of converting the content into a proper data type. The next step is the creation of a model class which converts a given object from and to JSON. Flutter Complete Reference 418",
  ". Working with JSON and other formats class Person { final int id; final String value; // . Person._({ required this.id, required this.value }); // . factory Person.fromJson(Map<String, dynamic> json) => Person._( id: json[\"id\"], value: json[\"name\"], ); // . Map<String, dynamic> toJson() => { \"id\": id, \"name\": value }; @override String toString() => \"$id - $value\"; } All the parsing logic lies inside class Person and nowhere else; casts only happen internally so from the outside there\u2019s no need to deal with dynamic. In practice, calling Person.fromJson() is safe because the developer is not asked to make any cast since they\u2019re hidden internally. . The constructor is private because this class can be instantiated only if a well-formed json string is passed via factory. . The factory constructor takes the result of a jsonDecode method and constructs a Person object. This is the only place in which we should pay attention to types. We could also have written this... Flutter Complete Reference 419",
  ". Working with JSON and other formats Person._( id: json[\"id\"] as int, value: json[\"value\"] as String, ); ... but the compiler is smart enough to infer the types and perform automatic casts. Note that this approach is required if you set strict implicit casts rules in analysis_options.yaml. . Converts the object into a data structure that can be passed to jsonEncode, which will convert the Map into a JSON string. It\u2019s very easy to use: final jsonString = jsonEncode(personObject); The jsonEncode method automatically calls Map<String, dynamic> toJson() so be sure to have it de\ufb01ned otherwise an error will occur. As you can see, parsing and converting is all around the creation of a model class which should de\ufb01ne factory MyObj.fromJson and MyObj.toJson. Thanks to these conversion methods, han- dling strings is very easy: void main () { final jsonString = '{ \"id\": , \"name\": \"Alberto\" }'; final decodedMap = jsonDecode(jsonString); final user = Person.fromJson(decodedMap); print(\"${user.id}\"); // prints \"\" print(\"${user.value}\"); // prints \"Alberto\" final json = jsonEncode(user); print(json); // prints \"{'id': , 'name': 'Alberto'}\" } Having a private constructor, a Person object can only be created from a JSON string and nothing more. Any model class is asked to, at least, de\ufb01ne: \u2022 a factory constructor which creates new instances using the returned value of jsonDecode; \u2022 a method called toJson() that will be automatically called by jsonEncode Flutter Complete Reference 420",
  ". Working with JSON and other formats ...1 Parsing lists Very often JSON strings are long lists containing a series of objects and of course Dart has an easy way to deal with them. Suppose you had to work with the following string: [ { \"id\": , \"name\": \"Alberto\" }, { \"id\": , \"name\": \"Felix\" }, { \"id\": , \"name\": \"R\u00e9mi\" }, { \"id\": , \"name\": \"Matt\" } ] In order to parse a list there\u2019s the need to intuitively use a List<T> object and then treating each item as a JSON object. We\u2019re using the same model class we\u2019ve created in the previous section. void main() { final jsonString = '''[ { \"id\": , \"name\": \"Alberto\" }, { \"id\": , \"name\": \"Felix\" }, { \"id\": , \"name\": \"R\u00e9mi\" }, { \"id\": , \"name\": \"Matt\" } ]'''; // It's a list of json objects List<dynamic> jsonList = jsonDecode(jsonString); // Each object is converted by the model class final List<Person> people = jsonList .map((value) => Person.fromJson(value)) .toList(); } The decoder is allowed to return a List<dynamic> when it encounters a list; each json object inside it is nicely converted by the model class. A list is simply a collection of objects which can be handled by a model class. \u009f The usage of a model class is very handy in this case; the code is highly readable Flutter Complete Reference 421",
  ". Working with JSON and other formats and type safe. If we didn\u2019t use Person.fromJson there would have been the need to make manual casts for any list to be parsed. A model class is always required to keep your code readable and easily testable. ...2 Parsing nested objects With the manual approach, things start to get complicated when the JSON string is quite complex because, for example, it\u2019s made up of nested objects or lists. Imagine having to work with this apparently simple string: { \"type\": \"Developers\", \"data\": [ { \"id\": , \"name\": \"Alberto\" }, { \"id\": , \"name\": \"Felix\" }, { \"id\": , \"name\": \"R\u00e9mi\" }, { \"id\": , \"name\": \"Matt\" } ] } If you\u2019re used to work with REST APIs you might have already encountered something like this millions of times. Jumping into the code, parsing logic starts to get more di\ufb03cult to write and thus harder for a developer to read. Now Person is not enough anymore and we need another model class to handle the outer object: // Same as before class Person { ... } // New class for the main object containing 'type' and 'data' class Data { final String type; final List<Person> people; Data._({ required this.type, required this.people }); Flutter Complete Reference 422",
  ". Working with JSON and other formats factory Data.fromJson(Map<String, dynamic> json) { List<dynamic> list = json[\"data\"]; List<Person> peopleList = list .map((personObj) => Person.fromJson(personObj)) .toList(); return Data._( type: json[\"type\"], people: peopleList, ); } } Performance is not an issue; the problem instead is the fact that for a fairly simple JSON string we\u2019ve had to create two di\ufb00erent model classes. You can always use manual parsing but with very complex and nested objects, you might get in trouble. \u009f As time goes by the maintenance can also get harder. What if the REST API from which you depend changed the structure? Potentially, you\u2019d have to refactor most of your code. The solution is the usage of code generation. Every json object requires his dedicated model class. There isn\u2019t a strict rule to determine when you should go for the manual approach but that\u2019s up to you; when you see that parsing starts to get hard and there\u2019s a lot of boilerplate code, consider moving to automatic parsing. ..2 Automatic parsing When JSON strings are very complex, with many nested objects and lists, it would be better using code generation which handles most of the tedious work automatically. First of all, you need to add a few dependencies to the project making sure to use the latest version of any package: dependencies json_annotation: ^..1 json_serializable: ^..0 The automatic way of parsing JSON is nothing new from what you\u2019ve just seen. The process Flutter Complete Reference 423",
  ". Working with JSON and other formats is identical to manual parsing with the only di\ufb00erence that model classes are generated by a command line tool rather than by you, the developer. In order to make an e\ufb03cient comparison between automatic and manual parsing, we\u2019re going to use the same JSON string as exam- ple. { \"id\": , \"value\": \"json test\" } As usual, there\u2019s the need to create the famous model class which takes care of converting from and to JSON. This time the code looks a bit di\ufb00erent from the usual: import 'package:json_annotation/json_annotation.dart'; // . part 'person.g.dart'; // . @JsonSerializable() class Person { final int id; final String name; Person(this.id, this.name); // . factory Person.fromJson(Map<String, dynamic> json) => _$PersonFromJson(json); Map<String, dynamic> toJson() => _$PersonToJson(this); } With this setup the code generator tool will be able to automatically create the bodies of both fromJson and toJson; there\u2019s no need for you to make casts or converting data. For now, ignore the errors underlined by the IDE because we\u2019re removing them soon. . The code generator will automatically create a \ufb01le called 'person.g.dart'. Thanks to the part directive, the Person class is able to access private members in the generated \ufb01le. . The annotation is fundamental as it tells the code generator that Person needs the JSON serialization logic to be created. It\u2019s a \"marker\" to recognize the classes that needs code generation. Flutter Complete Reference 424",
  ". Working with JSON and other formats . The syntax is a bit weird but it\u2019s telling the generator to create for us the code of these methods. You already know what they do from the previous section. The setup is now ready and it\u2019s time to invoke the code generator. Open the terminal from your IDE and run this command, making sure to be at root of the project (which should be already there by default): $ flutter pub run build_runner build Wait until it completes and at the end you will see a new \ufb01le called person.g.dart which has just been created. It contains the same logic you would have implemented by hand as it does casts from dynamic to the correct type according with the structure of the model class. \u009f Any change made to the model class requires the command build_runner to be run again in order to update the generated class. Doing this repeatedly might be tedious or you could simply forget about it: $ flutter pub run build_runner watch Using the command with watch rather than build automatically runs the code gen- erator whenever a change is made to the class. The IDE doesn\u2019t complain anymore about person.g.dart not being declared because it\u2019s now been generated by the tool. You\u2019re going to use Person in the exact same way we had already seen in the manual parsing section. void main () { final jsonString = '{ \"id\": , \"name\": \"Alberto\" }'; final dataMap = jsonDecode(jsonString); final user = Person.fromJson(dataMap); print(\"${user.id}\"); // prints \"\" print(\"${user.name}\"); // prints \"Alberto\" final json = jsonEncode(user); print(json); // prints \"{'id': , 'name': 'Alberto'}\" } In such a simple example it\u2019s hard to see why code generation is useful, in fact you could have Flutter Complete Reference 425",
  ". Working with JSON and other formats done it by hand. The real usefulness of the code generator comes when, for example, complex objects like the following have to be parsed: [ { \"id\": , \"roles\": [ {\"id\": , \"type\": \"Author\"}, {\"id\": , \"type\": \"Reviewer\"} ], \"data\": { \"params\": [, ], \"values\": { \"data\": [] }, \"keys\": [, , ] }, \"extra\": \"none\" } ] Each object needs its dedicated model class plus a series of handlers for the lists. Doing a manual parsing is going to require a lot of boilerplate code and by consequence it will also be quite hard to maintain as time goes by. Thanks to code generation, an automated tool takes care of the most tedious part. @JsonKey(required: true) final int id; @JsonKey(defaultValue: \"no name\") final String name; There are some extra annotations to instruct the behavior of the generator in certain situations. In the \ufb01rst case, the required marker throws an error if the key is not present in the JSON string. In the second case defaultValue puts the given value in the variable if the JSON key doesn\u2019t exist or if it\u2019s null. Flutter Complete Reference 426",
  ". Working with JSON and other formats ...1 Parsing lists Parsing lists doesn\u2019t involve any extra e\ufb00ort because, again, the generator does all the work for you. Unless you\u2019re parsing a primitive type, such as strings or integers, you need a model class for the objects in the array. { \"total\": , \"values\": [\"A\", \"B\", \"C\", \"D\"] } Declaring a List<String> instance variable is enough to tell build_runner to generate the needed code to parse a list of strings. In the next section we will show you what to do in case of lists of objects. @JsonSerializable() class Example { final int total; final List<String> values; Example(this.id, this.name); factory Example.fromJson(Map<String, dynamic> json) => _$ExampleFromJson(json); Map<String, dynamic> toJson() => _$ExampleToJson(this); } You could have put JsonKey(defaultValue: []) above values if you wanted it to be initialized with an empty array. Even if default values are not required, it\u2019s a good practice always de\ufb01ning them just to be sure that a variable is always initialized as expected. ...2 Parsing nested objects As you probably have already guessed, parsing nested object requires no e\ufb00orts from your side because the implementation will be automatically generated. Let\u2019s take as example the same JSON string we have already seen in the previous section: { \"type\": \"Developers\", \"data\": [ Flutter Complete Reference 427",
  ". Working with JSON and other formats { \"id\": , \"name\": \"Alberto\" }, { \"id\": , \"name\": \"Felix\" }, { \"id\": , \"name\": \"R\u00e9mi\" }, { \"id\": , \"name\": \"Matt\" } ] } We had already created a model class for the items in the array (Person, with the manual approach) but you could easily generate one with build_runner. What\u2019s missing is a model for the \"outer\" object, the one made up of \"data\" and \"type\". @JsonSerializable(explicitToJson: true) class Data { final String type; final List<Person> data; Data(this.type, this.data); factory Data.fromJson(Map<String, dynamic> json) => _$DataFromJson(json); Map<String, dynamic> toJson() => _$DataToJson(this); } Use explicitToJson: true when you have a class that contains another class in one of its \ufb01elds. In this case, in order to properly parse each Person object of the JSON array, you have to set explicitToJson: true on Data so that the inner-objects are included in the generation \ufb02ow. @JsonSerializable() class Person { ... } @JsonSerializable(explicitToJson: true) class Data { ... } Only the classes containing other classes need to have the explicitToJson parameter set. In case of primitive types, the annotation is not required. If your classes were big and deeply nested, the generator might take some more seconds but still it\u2019d be faster than a manual approach. \u009f The o\ufb03cial documentation discourages the usage of the part keyword by the Flutter Complete Reference 428",
  ". Working with JSON and other formats developer . The only case in which it\u2019s good is when code generation tools are in- volved, like in this case. For all the other needs, rely on a package-like structure using library and export statements. .2 Parsing XML Another well-known data exchange format is XML which is still widely used even with the arrival of JSON, so you might be interested in knowing how to deal with it. One of the best packages available is called xml , made by Lukas Renggli. <articles> <item> <name>Book</name> <quantity></quantity> </item> <item> <name>Tablet</name> <quantity></quantity> </item> </articles> Reading this string and converting it into a handy xml object is very easy as you just need to call XmlDocument.parse(). Version ..0 and earlier of the package had a top-level method called parse() which is now deprecated. import 'package:xml/xml.dart'; void main() { var xmlString = \"<articles> ... </articles>\"; try { final xmlDoc = XmlDocument.parse(xmlString); } on XmlParserException { // error while parsing the string } 1https://dart.dev/guides/libraries/create-library-packages 2https://pub.dev/packages/xml Flutter Complete Reference 429",
  ". Working with JSON and other formats } If the XML string is malformed, for example due to a syntax error, an exception is thrown. The xmlDoc variable is of type XmlDocument which provides many functionalities. It overrides the toString() so that the object can easily be printed. print(\"$xmlDoc\"); The returned string is \"pretty\" encoded, meaning that it\u2019s properly indented with spaces and tabulations. If you want to have more control on the output formatting, use indent: final output = xmlDoc.toXmlString( pretty: true, indent: '-' ); print(output); Having set pretty: true the XML tree is not printed verbatim because useless leading spaces are removed and indentation is \ufb01xed. With indent: '-' the indentation spaces are replaced with - producing this: <articles> -<item> --<name>Book</name> --<quantity></quantity> -</item> -<item> --<name>Tablet</name> --<quantity></quantity> -</item> </articles> By default the indentation uses a double white space ' ' but you could also use indent: '\\t' or anything else. \u009f When calling XmlDocument.parse() you need to pass a string in a proper UTF encoding. In Dart, String is a sequence of UTF-16 code units so everything works \ufb01ne. // All good because strings in Dart are UTF encoded Flutter Complete Reference 430",
  ". Working with JSON and other formats final xmlDoc = XmlDocument.parse(\"<articles></articles>\"); If you\u2019re retrieving the XML from the internet, for example via GET request, the string encoding might be di\ufb00erent from UTF (it could be Latin1, for example). Since parse() works well only with UTF, you could have the need to use the Latin1Decoder() class. // More info on GET requests and networking on chapter . // This is a GET request which returns a 'Response' object final response = await http.get(\"https://website.com/get/myFile.xml\"); // Convert the response to a proper UTF format, which is how Dart // strings are internally represented final String xmlString = Latin1Decoder().convert(response.bodyBytes); // You're now sure that parsing will execute successfully final xmlDoc = XmlDocument.parse(xmlString); The response body (response.body) is a String but it\u2019s not guaranteed to be in UTF encoding. If the response header speci\ufb01es charset=latin1 for example, then the string encoding will be Latin1. Thanks to Latin1Decoder() you can convert a latin1-encoded string into a Dart string (UTF-). AsciiDecoder().convert(response.bodyBytes); Utf8Decoder().convert(response.bodyBytes); They all work like Latin1Decoder(): use the convert() method to return a well- formed Dart string. This conversion should be taken into account not only when working with the xml package but in general (the same problem might happen when working with JSON as well). ..1 Parsing strings Once an XML-encoded string has been converted into a XmlDocument, there\u2019s the possibility to traverse the elements in many ways. Let\u2019s say we wanted to print the name of any article in the list: final xmlString = \"\"\" <articles> <item> <name>Book</name> Flutter Complete Reference 431",
  ". Working with JSON and other formats <quantity></quantity> </item> <item> <name>Tablet</name> <quantity></quantity> </item> </articles> \"\"\"; final xmlDoc = XmlDocument.parse(xmlString); xmlDoc.findAllElements(\"name\") .map((item) => item.text) .forEach(print); // Prints: // Book // Tablet Very intuitively, findAllElements(String name) returns an iterable object containing every XML element whose tag matches the given string. We could also have iterated on item and extracted the various values of the children by hand: xmlDoc.findAllElements(\"item\") .map((item) { final name = item.findElements(\"name\").single.text; final qty = item.findElements(\"quantity\").single.text; return \"$name (amount = $qty)\"; }) .forEach(print); // Prints: // Book (amount = ) // Tablet (amount = ) The findElements() method looks for any children of the currently selected node, it doesn\u2019t look on the entire tree. In order to obtain a reference to the node you can use: \u2022 single: Checks if there\u2019s only one child node with the given name and returns it. If not, Flutter Complete Reference 432",
  ". Working with JSON and other formats an exception is thrown. \u2022 \ufb01rst: Returns the \ufb01rst child node that matches the given name and returns it. If it\u2019s not present, an exception is thrown. \u2022 last: Returns the last child node that matches the given name and returns it. If it\u2019s not present, an exception is thrown. While findAllElements() \ufb01nds every children in the tree with a given name, findElements() instead looks only for children of the current node. Look at this simple comparison to better understand the di\ufb00erence: \u2022 result is an iterable containing 2 children, more precisely the two <item> tags representing the book and the tablet. With findAllElements() you\u2019re looking for any node across the entire tree. final xmlDoc = XmlDocument.parse(xmlString); final result = xmlDoc.findAllElements(\"item\"); // <articles> is at the root and it contains  <item> nodes; // findAllElements for any element whose tag is 'item' \u2022 result is an iterable containing no children because it looks only for direct children of the current node. The current node is the root which has a single child (<articles>). final xmlDoc = XmlDocument.parse(xmlString); final result = xmlDoc.findElements(\"item\"); // The current node is the root, which only contains // <articles>; the various <item> elements are not direct // children of the root When calling parse() the currently selected node becomes the root of the tree which only has the <articles> node. The root has no <item> children so the method \ufb01nds nothing. \u2022 In this case both methods return an iterable of size 1 which contains <articles> and all of its children. final xmlDoc = XmlDocument.parse(xmlString); final deepChildren = xmlDoc.findAllElements(\"articles\"); final directChildren = xmlDoc.findElements(\"articles\"); <articles> is a direct children of the root, the currently selected node, so findElements Flutter Complete Reference 433",
  ". Working with JSON and other formats is able to get a result. At the same time, <articles> is the only tag in the tree so findAllElements will return an identical result. In general you should use findAllElements when you want to get an entire list of elements and then inside it you call findElements to retrieve the speci\ufb01c values. This is an example of how they can be used together: // Get every <item> node with 'findAllElements' and then // use 'findElements' to find only direct children of the // currently selected element. final tot = xmlDoc.findAllElements(\"item\") .map((item) => int.parse(item.findElements(\"quantity\").single.text) ) .reduce((a, b) => a + b); print(\"$tot\"); // prints '', the sum of all quantities ..2 Building XML strings Let\u2019s say we want to create an XML string representing a series of personal information such as name, surname and age. The \ufb01nal result has to look like this: <people> <person> <name>Alberto</name> <surname>Miola</surname> <age></age> </person> <person> <name>Another</name> <surname>One</surname> <age></age> </person> </people> Thanks to the class XmlBuilder this job is quite easy but the code could get hard to read due to the big amount of nested functions. For this reason, it would be better creating series of methods for each recurring item, in this case the <person> child. Flutter Complete Reference 434",
  ". Working with JSON and other formats void addPerson(XmlDocument.XmlBuilder builder, { required String name, required String surname, required int age }) { builder.element('person', nest: () { builder.element('name', nest: name); builder.element('surname', nest: surname); builder.element('age', nest: age); }); } Each time addPerson(...) is called, a new <person> element is added and the code still remains readable. Using nest you can pass a primitive value, such a string/number, or a function which generally builds new XML items. \u009f Of course there is also the possibility to set attributes to speci\ufb01c elements. For example, if we wanted to add the age attribute we\u2019d have to use attribute(): builder.element('person', nest: () { builder.attribute(\"young\", age <= ); // name, surname and age... }); The result might look like <person young=\"false\"></person> where true or false depends whether the age is lower or higher than . Now you just need to create an instance of XmlBuilder and compose the string; once \ufb01nished, call the build() method. Helper functions such as addPerson make the code more readable because nesting too many functions might be quite pesky. final builder = XmlBuilder(); builder.processing('xml', 'version=\".\"'); builder.element('people', nest: () { addPerson(builder, name: \"Alberto\", surname: \"Miola\", Flutter Complete Reference 435",
  ". Working with JSON and other formats age: ); addPerson(builder, name: \"Another\", surname: \"One\", age: ); }); final peopleXML = builder.build(); Converting the XML object with peopleXML.toXmlString(pretty: true); is probably the best human-readable solution. However, you can also go for a plain toString() which uses no spaces nor indentation. Flutter Complete Reference   | Testing and pro\ufb01ling apps .1 Testing Flutter apps For demo applications consisting of one or two routes and a few lines of code, it\u2019s probably \ufb01ne if you do \"naive\" debugging just by printing values to the console. The more features your program has, the harder it is to manual testing code and execution \ufb02ows. \u009f Nowadays multithreading is a fundamental aspect of computer programming and it increases the logical complexity of the code. As you know, Dart doesn\u2019t have synchronization problems since Isolates doesn\u2019t share memory and thus testing asyn- chronous code is much easier in comparison with Java or C# for example. Multithreading aside, in general having a reliable and robust way of testing your code is essential to guarantee the quality of the product. There are three main testing strategies: \u2022 Unit test. Kind of tests made on small pieces of Dart code such as classes or functions. They check whether the logic of the code works as intended or not. \u2022 Widget test. Kind of tests made on Flutter widgets. They check if a widget is present in the widget tree or how many times does it appear. \u2022 Integration test. Kind of tests in which di\ufb00erent parts of the code are combined and tested together as a group. Imagine you\u2019re working on a Flutter application with some friends of yours using, for example, Android Studio and GitHub. Everything works \ufb01ne but one day you have to do a breaking change which requires a quite important refactoring. \u2022 With tests. Right click on the test/ folder and hit Run. If you\u2019ve broken something, Flutter Complete Reference 437",
  ". Testing and pro\ufb01ling apps one or more tests will fail indicating exactly where\u2019s the issue so that you can immediately investigate and solve it. \u2022 Without tests. You have absolutely no idea if \ufb01xed bugs have been broken again or other working components of your software are still healthy. Nothing will automatically tell you where known issues are! You have to scan the entire code seeking for bugs and hoping to not miss anything. You can only hope that major changes won\u2019t break the code but you understand that this way of working is really a \"no-go\". Writing tests (generally using testing frameworks) is basically making sure that errors won\u2019t be repeated in the future. Once you\u2019ve found a bug, solve it and write a test to make sure that future changes won\u2019t lead again to the same erroneous behaviors. \u009f Of course, passing tests doesn\u2019t assure your program is \ufb02awless because there might be bugs you haven\u2019t spotted yet. However, a perfect result (tests passed with no errors) ensures that known bugs have been \ufb01xed and they\u2019re not present anymore. Having no tests means having no guarantees that known bugs are gone. Any change, be it big or small, is a potential danger. Manually checking the code is tedious, time-consuming and very risky because you might forget to check certain issues (especially if the codebase is large). ..1 Unit Test Unit tests are used to test small blocks of code (such as classes or methods) by verifying their logical correctness using some conditions de\ufb01ned by the developer. We\u2019re going to test this simple class: // created inside 'lib/fraction.dart' class Fraction { int _num; int _den; Fraction({int numerator = , int denominator = }) : _num = numerator, _den = denominator; void negate() => _num *= -; double get toDouble => _num / _den; Flutter Complete Reference 438",
  ". Testing and pro\ufb01ling apps @override String toString() => \"$_num / $_den\"; } The test package 1 from the Dart team is a very powerful testing framework which also integrates with flutter_test. In our example, class Fraction is said to be the unit and here\u2019s how to test it: . We\u2019re going to test \"pure\" Dart code, in the sense that no Flutter widgets are involved. Let\u2019s start by adding a dependency to the testing framework: dev_dependencies: test: ^..3 Check https://pub.dev/packages/test to get the latest version. . Create a \ufb01le called fraction_test.dart inside the test library of your project, which is already added by Android Studio or VS Code by default. You should end up with this structure: Name it whatever you want but by convention test \ufb01les should always end with *_test.dart to be easily recognizable. The must always be a void main() {} function. . Inside fraction_test.dart start implementing the logic of your tests using the API pro- vided by test test package. There are mainly two functions to use: \u2022 void test(). It accepts a string, which brie\ufb02y describes what is being checked, and a callback, the actual logic of the test. \u2022 void expect(a, b). The second value is compared to the \ufb01rst one and, if they don\u2019t 1https://pub.dev/packages/test Flutter Complete Reference 439",
  ". Testing and pro\ufb01ling apps match, the test fails by throwing an exception. It doesn\u2019t matter in which order you pass parameters to expect but by convention the value produced by your code goes on the left. void main() { test('10 divided by 2 should be ', () { final fraction = Fraction( numerator: , denominator:  ); expect(fraction.toDouble, .); }); } . Generally, a class has more than a single method to be tested. Using the group() function multiple tests can be logically grouped under the same \"container\". void main() { group(\"Fraction class testing\", () { test(\"10 divided by 2 should be \", () { final fraction = Fraction( numerator: , denominator:  ); expect(fraction.toDouble, .); }); test(\"'negate' should produce opposed signs\", () { final fraction = Fraction( numerator: , denominator:  ); fraction.negate(); expect(fraction.toDouble, -.); }); }); } Flutter Complete Reference 440",
  ". Testing and pro\ufb01ling apps . Tests are now ready to be run either via command line or using the facilities provided by the IDE. For old school developers, just type this in the terminal: $ flutter test test/fraction_test.dart Otherwise, the o\ufb03cial Flutter plugin for both Android Studio and VSCode supports unit testing so that you can run tests in a more friendly way. In Android Studio (as of version ..): \u2022 Open the fraction\\_test.dart \ufb01le; \u2022 Go on Run > Edit Con\ufb01gurations; \u2022 Click on the + button on the left and select \"Dart Test\" (or \"Flutter Test\"); \u2022 Give it a meaningful description and be sure that in Test scope the All in \ufb01le option is selected; \u2022 Select the test \ufb01le we\u2019ve just created. Click OK; Now in the drop-down next to the Run button select the test you\u2019ve just created and run it; results will appear in the console underneath. In VSCode: \u2022 Open the fraction\\_test.dart \ufb01le; \u2022 Select the Debug menu; \u2022 Click on Start Debugging and the tests will be run. If you have set a keyboard shortcut for executing tests immediately, use it. Creating unit tests is not so hard; once you\u2019ve your class or function ready to be tested, create a dedicated \ufb01le in the test/ folder. Use test(\"Description\", () {} to write the logic and possibly group() to group more tests together. \u009f To collect code coverage, add the --coverage <directory> \ufb02ag when calling the test command line tool. The directory will be automatically created if it doesn\u2019t exist and the results will be put there. So far you\u2019ve only seen expect() being called, which just matches for a single case. There\u2019s the possibility to run multiple checks for a single test thanks to allOf(). Be sure to check out the documentation of the matcher 2 for a complete list of methods you can use inside allOf(). 2https://pub.dev/documentation/matcher/latest/matcher/matcher-library.html Flutter Complete Reference 441",
  ". Testing and pro\ufb01ling apps expect('A short string.', allOf([ contains('rt'), startsWith('A '), endsWith('.') ])); If you want to make sure that your code throws an exception under certain circumstances, you could include it in a try catch block and call expect() with boolean values. It\u2019s doable for sure but there\u2019s a better way of dealing with exceptions: expect(() => Fraction(, ), throwsA(isA<FractionException>())); The throwsA() function catches exceptions and it\u2019s generally used together with isA<T>() to match the exact type. There\u2019s also the possibility to use a \"shortcut\" in case of common exception types: expect(() { ... }, throwsException); expect(() { ... }, throwsFormatException); expect(() { ... }, throwsUnsupportedError); // and more... Writing throwsA(isA<Exception>()) is equivalent to throwsException but with less code. As always, check out the o\ufb03cial documentation 3 to see every kind of common exception type available. ...1 Testing asynchronous code and streams If you use async and await regularly, tests will work \"normally\" like if you were working with synchronous calls. The only exception is that they may take a bit longer to execute because the test runner waits until every Future<T> completes. void main() { test('Testing with async and await', () async { final age = await Future<int>.value(); expect(age, equals()); }); } We could have also achieved the same result without using async and await at all. For consistency and readability, we don\u2019t recommend you to go for this kind of approach. 3https://api.\ufb02utter.dev/\ufb02utter/test_api/test_api-library.html Flutter Complete Reference 442",
  ". Testing and pro\ufb01ling apps void main() { test('Testing without async and await', () { final age = Future<int>.value(); expect(age, completion(equals())); }); } The completion() function is used to test a Future<T> object: it ensures that the test doesn\u2019t \ufb01nish until the operation completes. Once available, the value is passed to equals(). With streams, nothing new again: final rocketLaunch = Stream<String>.fromIterable([ \"\", \"\", \"\", \"\", \"Ignition\", \"Success!\" ]); test(\"rocket launch test\", () { expect(rocketLaunch, emitsInOrder([ // This is a value and it matches individual events \"\", // Asserts that one of the options in the list is emitted emitsAnyOf([\"Success!\", \"Failure\"]), // By default, more events are allowed at the end. 'emitsDone' // makes ensure that nothing else is emitted after this matcher. emitsDone ])); }); We\u2019ve created a dummy rocketLaunch stream just as test. Details aside, the structure is always the same: create a new test with test(\"description\", () { ... }) and then use expect() to ensure the correctness of the output. There are many matchers available 4 such as emitsAnyOf() or neverEmits(). ...2 Mocking dependencies In real-world applications it\u2019s very likely you\u2019ll have to deal with http connectivity or Future<T>s in general. They\u2019re very annoying to test using the technique we\u2019ve just described for a few 4https://pub.dev/packages/test#asynchronous-tests Flutter Complete Reference 443",
  ". Testing and pro\ufb01ling apps reasons: . You could successfully run your tests but then, due to a bug in the online API that you don\u2019t control, failures start to pop out. . Making HTTP requests might slow down the execution time of the tests. They could also fail due to a series of connectivity problems related to the response sent by the server. . If the web service goes down for maintenance in the exact moment in which you want to test, you simply can\u2019t do it. Flutter gives you the possibility to mock dependencies. The term \"mocking\" indicates the act of emulating a database, a web service or any other external source in local so that it\u2019s always available. \u009f Let\u2019s say your app normally sends http requests to an online REST API service. When it\u2019s time to test you should create a mock, which is a \"local fake API\" under your control which acts like if it were a real external service. We\u2019re going to create mocks by using the o\ufb03cial mockito 5 package, created by the Dart team. We\u2019re still doing unit tests but with a di\ufb00erent approach. Rather than directly connecting to the server, we emulate a fake one just for testing purposes. import 'package:http/http.dart' as http; class Todos { final _source = \"https://myonlineapi/get/todos\"; String getJson(http.Client client) async { final response = await client.get(_source); if (response.statusCode != ) return response.body; else return \"{}\"; } } 5https://pub.dev/packages/mockito Flutter Complete Reference 444",
  ". Testing and pro\ufb01ling apps In chapter 17 you\u2019ll see many examples about HTTP requests and data parsing. In this example we\u2019re showing how to unit test the class Todos, which uses the o\ufb03cial http 6 package to retrieve a JSON string. \u2022 Add the mockito package in the dependencies list along with the usual test package. As always, be sure to use the latest versions. dependencies: http: ^..2 dev_dependencies: test: ^..3 mockito: ^.. \u2022 Like we\u2019ve done before, create the \ufb01le todos_test.dart inside the test folder which is going to contain our logic. For convenience, mocks can be created in the same \ufb01le as the main(): // The fake API server class HTTPMock extends Mock implements http.Client {} void main() { // tests go here as usual... } The String getJson(...) method is going to receive an instance of HTTPMock rather than http.Client. It works because the mock implements the http client object and thus there\u2019s type compatibility. \u2022 Writing tests is nothing new from what you had seen earlier; use test() to write the logic and, for a better mental organization, divide the methods in multiple groups with group(). class HTTPMock extends Mock implements http.Client {} void main() { final url = \"https://myonlineapi/get/todos\"; test(\"Returns JSON in case of success\", () async { // . final todo = Todos(); 6https://pub.dev/packages/http Flutter Complete Reference 445",
  ". Testing and pro\ufb01ling apps // . final mock = HTTPMock(); final fakeJson = '[{\"id\": , \"desc\": \"Test!\"}]'; // . when(mock.get(url).whenComplete(() { return http.Response(fakeJson, ); })); // . expect( await todo.getJson(mock), // ... or compare the result with 'fakeJson' const TypeMatcher<String>() ); }); } The void when(...) function is provided by the mockito package. . The instante of the class that is going to be tested. . The instance of the mock, the \"fake API\" which is going to return a particular json response. . When the test runs on a speci\ufb01c url, the method get(String url) is not called on the real http client but instead it returns the fake JSON string provided by the mock. . When we call getJson we\u2019re not passing a real http object which connects to the online API. We pass the fake http object which emulates a request and returns a JSON string we can control. \u2022 Run the test via command line by typing: $ dart test/todos_test.dart When HTTP and/or database connectivity are involved, use a package like mockito to easily run your tests. In every other case where there is just \"plain\" Dart code to test, with no Future<T>s or other time-consuming tasks, use a traditional unit test. \u009f Note that even if the web service were down or the connectivity were absent, we Flutter Complete Reference 446",
  ". Testing and pro\ufb01ling apps would still be able to run tests thanks to the mock. Everything is local to the current machine so tests don\u2019t rely on external sources. ...3 Unit testing blocs State management libraries require to be unit tested like any other logic implemented in the app and thus \ufb02utter_bloc is no exception. Thanks to the bloc_test 7 package verifying the behavior of your blocs and cubits couldn\u2019t be easier. \u009f In this example we\u2019re unit-testing the simple CounterBloc we made in chapter . It just expects an event of type increase or decrease and returns an integer. You could manually test blocs using test() but, other than being di\ufb03cult, there wouldn\u2019t be the possibility of verifying certain cases. Testing blocs is very easy: instead of relying on the classic test() we should use blocTest() which simpli\ufb01es the process a lot and makes it very intuitive. Look at this example: void main() { blocTest( 'emits [] when increment is added', build: () => CounterBloc(), act: (bloc) => bloc.add(CounterEvent.increment), expect: [], ); } With act you can send events to the bloc being created in build and expect() is a list of expected emitted states. Of course there\u2019s the possibility to send multiple events and look for multiple results: blocTest( \"emits [, , ] when 2 increments and 1 decrement are added\", build: () => CounterBloc(), act: (bloc) => bloc ..add(CounterEvent.increment); ..add(CounterEvent.increment); 7https://pub.dev/packages/bloc_test Flutter Complete Reference 447",
  ". Testing and pro\ufb01ling apps ..add(CounterEvent.decrement); }, expect: [, , ], ); Setting the optional skip parameters allows you to ignore a certain number of states. By default skip: 0 is set and the initial state is excluded from the expect list. Does your bloc await somewhere and thus you need to wait some time? build: () => MyBloc(), act: (bloc) => ..., wait: const Duration(seconds: ), expect: [...], In this way, when act sends an event to the bloc, the emitted state is returned after the given time span (which is 2 seconds in the example). This is very useful when you need to wait, for example, when debouncing events. build: () => MyBloc(), act: (bloc) => bloc.add(Something()), expect: [], errors: [ isA<Exception>(), ] The errors parameter is used to catch exceptions, generally together with isA<T> to exactly match the type. Of course, bloc tests can be grouped like any other unit test. void main() { group('CounterBloc', () { blocTest(...); blocTest(...); blocTest(...); }); } Flutter Complete Reference 448",
  ". Testing and pro\ufb01ling apps ..2 Widget Test Testing Flutter widgets requires the same process you\u2019ve seen in unit testing with the addition of some new techniques brought by the built-in \ufb02utter_test package. It\u2019s already bundled in the SDK so no need to install it via pub. class Myself extends StatelessWidget { final int age; final String name; const Myself(this.name, this.age); @override Widget build(BuildContext context) { return Row( children: [ Text(name), Text(\"$age\"), ] ); } } Before starting the testing journey for this widget, be sure that the pubspec.yaml \ufb01le declares flutter_test in the dev_dependencies section. Widget tests are meant to check whether one or more widgets have been properly put in the widget tree. \u2022 As usual, create a new \ufb01le called myself_test.dart inside the test folder but this time the main player is testWidgets() rather than test(). void main() { testWidgets(\"Testing if 'Myself' has name and age\", (WidgetTester tester) async { // . await tester.pumpWidget(MySelf(\"Alberto\", \"\")); // . // Basically we're looking for  'Text' widgets // containing \"Alberto\" and \"\" inside 'MySelf' final CommonFinders name = find.text(\"Alberto\"); final CommonFinders age = find.text(\"\"); Flutter Complete Reference 449",
  ". Testing and pro\ufb01ling apps // . expect(name, findsWidgets); expect(age, findsOneWidget); } ); } . The Future<void> pumpWidget() method is used to build and render a widget in a testing environment. It\u2019s like if MySelf were inserted in the widget tree and the framework called its build() method to render it. . The CommonFinders find is part of Flutter\u2019s testing utilities so no external packages are required. The text() method looks for Text widgets in the tree containing the given string. . We\u2019re making sure that the two Text widgets actually appear in the tree (and thus they\u2019re visible on the UI) using a Matcher. The method wants to know how many widgets it has to look for: \u2013 findsNothing: asserts that the \ufb01nder has found no widgets in the tree; \u2013 findsOneWidget: asserts that the \ufb01nder has found exactly one widget in the tree; \u2013 findsWidgets: asserts that the \ufb01nder has found one or more widgets in the tree; \u2013 findsNWidget: asserts that the \ufb01nder has found exactly N widget in the tree, where N is a value de\ufb01ned by you. \u2022 Run the test in the same way you\u2019d do for a classic Dart unit test; the results will appear in your IDE indicating the failures, if any. As you\u2019ve seen, widget testing consists of building a \"fake\" widget tree with pumpWidget() and looking for speci\ufb01c types using a Finder. Of course you can look for any kind of widget, not only Text: \u2022 find.text(...): you\u2019ll often have the need to look for the presence of a Text widget and this method does exactly that. \u2022 find.byWidget(...): it\u2019s useful when you want to look for a speci\ufb01c widget in the tree making sure it appears on the screen a certain number of times. The usage is very easy: // You want to look for an error icon final target = Icon(Icons.error); Flutter Complete Reference 450",
  ". Testing and pro\ufb01ling apps // Build the widget that has to be tested await tester.pumpWidget( Center( child: Padding( padding: const EdgeInsets.all(.), child: target, ) ) ); // Search the icon final finder = find.byWidget(target); // Ensure the icon actually appears expect(finder, findsOneWidget); With this code we\u2019re ensuring that the widget tree contains exactly one error Icon. \u2022 find.byType(...): looks for widgets of a particular type. It can be used in the following way: expect(find.byType(IconButton), findsWidgets); After having obtained an instance of a Finder, the expect method tells us if the \ufb01nder was able to satisfy the criteria we imposed such as findsOneWidget or findsWidgets. \u009f Suppose you had to test a StatefulWidget which has a series of animations inside. Other than making sure certain widgets are appearing to the UI, you could also want to test its performances: await tester.pumpWidget(MyWidget()); await tester.pump(Duration(milliseconds: )); Thanks to Future<void> pump(...) we can trigger rebuilds of the tree after a given Duration. In our example, after 100 milliseconds MyWidget() will be rebuilt. await tester.pumpWidget(MyWidget()); await tester.pump(); await tester.pump(); Flutter Complete Reference 451",
  ". Testing and pro\ufb01ling apps Calls can also be chained for subsequent rebuilds. Passing no parameters to the method causes an immediate rebuild. Be aware that Widget build(...) of the tested widget is called only once, which is when it\u2019s being created via pumpWidget(). In a testing environment, calling setState() has no e\ufb00ect because rebuilds only happen via tester.pump(). ...1 Testing blocs and providers It might happen that a particular part of the widget tree you want to test depends on one or more providers of any kind. There\u2019s nothing special to do when it comes to testing as just need to normally wrap the widget in the provider you need. // With a provider... await tester.pumpWidget( Provider<Something>( child: MyWidget(), ), ); // In case of multiple providers... await tester.pumpWidget( MultiProvider( providers: [...] child: MyWidget(), ), ); Values are still compared using expect. The same concept also applies for \ufb02utter_bloc with the exception that, only for widget testing, the bloc has to be mocked. Taking into account the CountBloc example again, you should create a mock being sure to also depend on mockito: class MockCounterBloc extends MockBloc<int> implements CounterBloc {} void main() { final counterBloc = MockCounterBloc(); // Emit a series of states we've decided whenListen(counterBloc, Stream.fromIterable([, , ])) Flutter Complete Reference 452",
  ". Testing and pro\ufb01ling apps // Build a subtree like you'd regularly do in a widget test await tester.pumpWidget( BlocProvider<CounterBloc>.value( value: counterBloc, child: MyWidget(), ) ); // Making sure the state is correct expect(counterBloc.state, equals()); } Basically before using pumpWidget() you need to create a \"fake bloc\" using a mock, similarly to what you\u2019d do with a fake HTTP client. In this way there\u2019s the possibility to send a series of states we decide just by using whenListen(). It\u2019s also possible making sure that states are emitted in a certain order: // Making sure the state is correct expect(counterBloc.state, equals()); // Making sure the stream emits certain values await expectLater(counterBloc, emitsInOrder(<int>[, ]))); The \ufb01rst case just makes sure that the latest state equals 2 while the second one ensures that the entire \"emission \ufb02ow\" is correct. ..3 Integration testing This kind of test gathers together both the UI and the business logic so that you can test the app as a whole. With integration tests you\u2019re able to verify how the visual components and the code behave together; the app runs on a device (or simulator) and it\u2019s told to do certain things automatically, such as pressing on buttons. Flutter Complete Reference 453",
  ". Testing and pro\ufb01ling apps We\u2019re going to test the counter app we\u2019ve created in chapter 11 with provider; the test has to ensure that both buttons properly increment and decrement the counter at the center. \u2022 The full source code can be found in the website at Resources >",
  "> Integration test. The only di\ufb00erence from the original example in chapter 11 is the addition of a Key required to reference the speci\ufb01c widgets while testing. FlatButton( key: Key(\"increment\"), child: const Text(...), onPressed: () => counter.increment(), ), Text( key: Key(\"counter\"), child: const Text(...), ), FlatButton( key: Key(\"decrement\"), child: const Text(...), onPressed: () => counter.decrement(), ), \u2022 Integration tests are made with the flutter_driver package which has to be added as dependency, as always, in the pubspec.yaml \ufb01le. dev_dependencies: flutter_driver: sdk: flutter test: any \u2022 Instead of using the usual test folder, you have to create a new one called test_driver located at the root of your project (the same level as lib). Flutter Complete Reference 454",
  ". Testing and pro\ufb01ling apps Integration test tools run don\u2019t run in the same process as your app and so, to better represent this separation, Flutter requires you to have a dedicated folder apart. \u2022 Create the \ufb01le test_driver/app.dart but you can name it whatever you want. This \ufb01le initializes the environment so that it can \"automatically\" use your app. In practice the code automatically presses on buttons and analyzes the consequences of this action, which is what a human would do in a manual test. void main() { // . enableFlutterDriverExtension(); // . runApp(CounterApp()) } Notice that in widget testing we could only check if a certain widget were present or not in the tree and, at best, count its occurrences. Here instead we\u2019re testing the functionalities of the widget combined with the Dart logic behind it. . This method prepares the Dart Virtual Machine for executing an \"instrumented test\" of the app which is, in practical terms, performing actions on various UI widgets (such as tapping buttons, scrolling lists or reading text). Instead of being you tapping buttons, it\u2019s the testing driver doing it. . Start the app in the usual way calling runApp(). Pass it any widget you want to test. \u2022 The \ufb01nal step is the implementation of the logic inside the test_driver/app_test.dart \ufb01le. In this example we\u2019re instructing the driver to press on buttons and read the counter Flutter Complete Reference 455",
  ". Testing and pro\ufb01ling apps value from a Text widget. void main() { group(\"Counter App test\", () { // . final counterText = find.byValueKey('counter'); final incrementButton = find.byValueKey('increment'); final decrementButton = find.byValueKey('decrement'); late final FlutterDriver driver; // . setUpAll(() async { driver = await FlutterDriver.connect(); }); // . tearDownAll(() async { driver.close(); }); // . test(\"Counter increment\", () async { await driver.tap(incrementButton); var readText = await driver.getText(counterText); expect(readText, \"\"); }); test(\"Counter decrement\", () async { await driver.tap(decrementButton); var readText = await driver.getText(counterText); expect(readText, \"\"); }); }); } . Here you see why we had set the keys at the beginning; thanks to them, we can locate the widgets in the tree. Each variable holds a \"reference\" that\u2019s going to be used by Flutter Complete Reference 456",
  ". Testing and pro\ufb01ling apps the driver to interact with the widget. . The setUpAll() method is called before any test starts and performs initialization. The driver is connected so that it can start interacting with the app. . By contrary. tearDownAll() is called before the test ends and does the \ufb01nal cleanup of the instances which require a disposing. . It\u2019s the usual test() method you\u2019re used to see in this chapter. The driver variable is able to interact with our app by doing many things: \u2013 Future<void> enterText(): enters the given text in an input \ufb01eld like if the user were tapping on the keyboard; \u2013 Future<void> getText(): reads the text from a Text widget. \u2013 Future<void> scroll(): the driver simulates a \ufb01nger scrolling on a list. It\u2019s possible to also set the direction and the duration. \u2013 Future<void> screenshot(): takes a screenshot of the page and stores it in a PNG \ufb01le. To see any action that a driver can perform on a widget, visit the o\ufb03cial documentation . \u2022 Now you\u2019re ready to run the test. First of all, start your app in an Android or iOS emulator pressing the Run in your IDE. When the simulator is ready and connected to your IDE, run this command: flutter drive --target=test_driver/app.dart Wait for the initialization to \ufb01nish and you\u2019ll see the driver interacting with the app for you pressing on the buttons, reading text or doing any other action it got told to do. The driver tool is very powerful: it\u2019s a convenient way to systematically and automatically test functionalities of your widgets combined with the business logic. Look what the driver could do for you: test(\"Counter decrement\", () async { final textField = find.byValueKey(\"itsName\"); await driver.setTextEntryEmulation(enabled: true); 8https://api.\ufb02utter.dev/\ufb02utter/\ufb02utter_driver/FlutterDriver-class.html Flutter Complete Reference 457",
  ". Testing and pro\ufb01ling apps await driver.tap(textField); await driver.enterText(\"Flutter is... \"); await driver.enterText(\"Awesome!\"); }); This code writes some strings in a text \ufb01eld (more on this in chapter ) and also emulates the insertion of the characters like if they were typed by a real person. You should really try the driver at least once to see how useful and user-friendly it is. .2 Testing performances Flutter guarantees to run at 60 fps regularly and at 120 fps in those devices whose display is ca- pable to. If your code wastes resources due to heavy rebuilds, caused by a lack of const widgets, or badly-handled animations the frame rate might drop. \u009f If you follow the numerous good practices we\u2019ve exposed in this book, there are very high chances that your app won\u2019t su\ufb00er of performance issues. Caching widgets (entire branches of the tree) and not wasting resources are the most fundamental guidelines to put in practice. Sometimes you might be able to see with your eyes that the UI doesn\u2019t render smoothly but of course it depends on the device. Flutter ships with very useful pro\ufb01lers to help you analyzing the performances of your app while it\u2019s running in pro\ufb01le mode. Consider that: \u2022 Pro\ufb01le mode works only if your IDE is connected to a physical device, so there\u2019s the need to connect an Android or iOS phone to your development machine. Pro\ufb01ling on an emulator might not re\ufb02ect the actual performances of the app so a real device is required. \u2022 Pro\ufb01le mode is similar to release mode but they\u2019re absolutely NOT interchangeable. In addition, some services and/or features might not be available while pro\ufb01ling. In practical terms, the pro\ufb01le mode exposes a series of graphs and indications about your app\u2019s performance. According with the results, the developer should be able to identify the potential bottlenecks and make accurate \ufb01xes. It\u2019s the last step before proceeding to the release phase. Flutter Complete Reference 458",
  ". Testing and pro\ufb01ling apps Debugging happens while testing and developing. Pro\ufb01ling is done before releasing the product to make sure that everything is optimal or at least in an acceptable state. ..1 DevTools DevTools is a series of debugging and pro\ufb01ling tools for Dart and Flutter. It works in both debug and pro\ufb01le mode but when it\u2019s time to test the actual performances of your app, you should use it when pro\ufb01ling. It\u2019s like a Flutter-speci\ufb01c debugger with a lot of built-in functionalities. This is how it looks when you\u2019re testing your app\u2019s performances in pro\ufb01le mode: It\u2019s also able to directly interact with the app performing rebuilds, showing grids and slowing down animations to inspect how they a\ufb00ect the performances. The \ufb01rst time you start DevTools, your IDE will automatically download it. ..2 Using the Flutter inspector The Flutter inspector is a powerful tool for exploring you app\u2019s widget tree: it allows you to see literally everything about the widgets you\u2019ve created. The inspector can also be opened in Android Studio/Visual Studio code but the web version on DevTools is more spacious and user friendly. It can be used in debug mode. Flutter Complete Reference 459",
  ". Testing and pro\ufb01ling apps In the above image we\u2019re analyzing a Column with the possibility to also change in real time its properties. For example, you could click on center, change it to end and see a preview of how the new con\ufb01guration would look like. On the left, there\u2019s a representation of your app\u2019s widget tree which can easily be explored. In this page, there are many actions to perform: \u2022 Slow Animations. Slows down animations to inspect whether the source of the slowness is a particular animation. It\u2019s very useful when you have a jank in the UI and you want to \ufb01nd out if the source of problems is a too expensive animation. \u2022 Debug Mode Banner. Enables or disables the red \"debug\" stripe on the top-right border. \u2022 Select widget mode. It allows you to click in a widget on the tree (on the left) to inspect it. You can for example see the associated keys, the sizes, the constraints of the widget itself and so on. \u2022 Debug Paint. Adds debugging hints to better see spaces such as alignments, margins and paddings. It\u2019s useful when you want to see relative alignments of widgets to make sure they\u2019re properly placed on the screen. Flutter Complete Reference 460",
  ". Testing and pro\ufb01ling apps \u2022 Paint Baselines. Any RenderBox paints a line at each of its text baselines. ..3 Using the Timeline view This view is made up of multiple bars, each of them representing a single Flutter frame. Clicking on a bar opens a detailed view at the bottom with any single call made by the CPU. There also is the possibility to show these bars directly in your app clicking on the button next to Pro\ufb01le granularity. They appear at the top of your application, when run in pro\ufb01le mode, with two important graphs. You don\u2019t have control on them as they aren\u2019t regular Flutter widgets; they\u2019re painted directly by Skia on top of you app. Both charts are identical: they show the same data but with a di\ufb00erent layout. Flutter Complete Reference 461",
  ". Testing and pro\ufb01ling apps The charts show the latest 300 frames produced by your app and they\u2019re updated whenever Flut- ter paints something to the UI, which is when build() is called. Each bar is a frame. If you want your app to run at 60 frames per second (fps), each frame should be built in about 16 milliseconds. \u009f 60fps means that each frame has to be rendered in /60th of a second which is about /60s = ,01667s (16 milliseconds). A frame is said to be janky if it\u2019s taken more than 16ms to complete (and it\u2019s represented by a red bar). The charts represent data about the raster thread and the UI thread, which are the relevant ones for the developer. Flutter also has an I/O thread, for time-consuming operations, and a platform thread which talks to the underlying OS. \u2022 UI thread: here\u2019s where your code is executed in the Dart VM. Any action made in the UI thread has consequences on the other threads so it doesn\u2019t have to be blocked for a long time. In practical terms, using async/await and const constructors plays a fundamental role! \u2022 Raster thread: Skia runs here. If this thread is slow it\u2019s a consequence of the fact that your Dart code (which runs in the UI thread) is also slow. The raster thread executes graphics code from the Flutter engine. Let\u2019s jump to the practical part to see how to actually pro\ufb01le a Flutter application. Once you\u2019ve connected the IDE to a real device and launched the pro\ufb01le mode, show the performance overlay and start pro\ufb01ling: \u2022 Interact with your app as much as possible: press on buttons, navigate among routes, scroll repeatedly list and so on. Use di\ufb00erent devices with di\ufb00erent hardware specs if possible. Whenever you see a red bar (jank), start investigating to \ufb01nd the cause. \u2022 The overlay could show red vertical bars indicating that a particular frame took too long to render (more than 16ms). If it happens in the UI thread, then you should review the Dart source code and improve it: \u2013 try to improve animations (if any) using the caching techniques we\u2019ve shown in chapter  (especially, look at .); \u2013 have you used const constructors? can you refactor to create more immutable widgets (so that they can have a constant constructor)? can you \"manually\" cache some portions of the tree? Flutter Complete Reference 462",
  ". Testing and pro\ufb01ling apps \u2013 be sure you\u2019re lazily-initializing ListViews and GridViews using their builder named constructor. It\u2019s very e\ufb03cient. \u2013 try to see if unnecessary rebuilds are happening. Is FutureBuilder using a non cached Future? FutureBuider<String>( future: _MakeHttpRequest(), ) Doing something like this is absolutely bad and we will explain, in detail, why in chapter . Basically, a Future<T> object should be cached and initialized inside initState() (or with late final). \u2013 You can optimize a ListView by setting the itemExtent property, which is used to determine the height of the children. ListView.builder( itemExtent: ., itemCount: , itemBuilder: (context, index) {...} ) In this way Flutter knows in advance the extent and this foreknowledge saves some work making the scrolling more e\ufb03cient, especially when there are drastic position changes. \u2013 Do you have the possibility to cache data using a Map<K,V>? Do you have the possi- bility to cache data on a local storage like a database? In this way, you could save a lot of computational time. Red bars on the raster thread are a consequence of your Dart code being too \"slow\" and thus the app, on average, doesn\u2019t run at 60fps. \u2022 It might happen that red bars appear only in the raster chart and not in the UI one. There are a few actions you can take in order to investigate the problem: \u2013 Some widgets such as Opacity are relatively expensive: if you\u2019re using them many times (especially inside animations) they could be a problem. If you\u2019re using them, try to remove them or reduce their usage and see what happens. \u2013 Click the Slow animation to run animations slower in the DevTool control panel. See if the problem is caused by the entire animation or only at certain points of the execution. Flutter Complete Reference 463",
  ". Testing and pro\ufb01ling apps \u2013 Use DevTool to discover, in the TimelineView section, which part of your app is slow (more on this later). In most of cases, red bars indicate that at certain frames the UI is rebuilt more than required so you should act on the Dart code. Generally, this behavior is caused by animations or Future<T>s. \u009f Make apps whose frames are ready in less than 16ms (all blue bars) or at least try to stay at 16ms on average. Other than visual bene\ufb01ts you might not notice, low frame rendering leads to better battery life and less device heating. Don\u2019t pro\ufb01le your apps exclusively on powerful last generation devices. If your app renders good frames on older devices, whose hardware is not particularly excellent, on better devices results can only improve. You can always display the performance overlay programmatically inside material or cupertino widgets: MaterialApp( showPerformanceOverlay: true, title: 'My App', ) CupertinoApp( showPerformanceOverlay: true, title: 'My App', ) The performance overlay always works, but a meaningful usage only happens in pro\ufb01le mode (which is the closest to the release mode). ..4 Using the Memory view In Dart there\u2019s no need to take care of cleaning the memory from unused objects because there\u2019s an e\ufb03cient garbage collector doing the job for us. Thanks to the Memory View tab you can see how an isolate is using the memory at a given moment. Flutter Complete Reference 464",
  ". Testing and pro\ufb01ling apps This tab should be used only in pro\ufb01le mode as it\u2019s the \"closest\" to release mode in terms of performances. Despite being very accurate, pro\ufb01le mode might show sometimes some slightly higher values because the isolate is running a special service in order to run the pro\ufb01ling. This special service doesn\u2019t exist in release mode. There are two main parts on the page: . At the top, a chart shows the state of the heap at a certain point of the time. In other words, it\u2019s a general overview of the memory while the application is running having some dots and lines updating in real time. Dots represents GC events, which is when garbage collection happens. . At the bottom, there\u2019s the Snapshot button which takes a \"photo\" of the memory at the given instant and reports a detailed analysis of the heap status. Note that external refers to data put on the heap by the operating system and thus not managed by Flutter. Thanks to this chart you could also \ufb01nd potential memory leaks, which are unused object lying on the heap wasting memory. They are hard to debug and the garbage collector isn\u2019t able to catch those \"leaked objects\": they waste space, put pressure on the VM and increase memory fragmentation. Finding memory leaks requires experience and skill (as it\u2019s not an easy job), but there are two buttons you can use to try spotting them: \u2022 Clicking the Reset button in the top-right corner sets to 0 the total instances count of the classes. \u2022 Clicking the Snapshot button in the bottom area of the page shows the list of currently active objects on the heap (along with an instance counter). Flutter Complete Reference 465",
  ". Testing and pro\ufb01ling apps If you click on Snapshot after having pressed Reset, you\u2019ll be able to see how many new in- stances have been allocated on the heap since the last reset. This can be an useful strategy to \ufb01nd potential leaks, which is the case where there are object that cannot be reached anymore (and cannot be freed by the garbage collector). \u009f Analyzing the memory to spot leaks and improve you app\u2019s performance it not easy at all. It requires a lot of experience and skills we cannot explain here because they go beyond the scope of this book. Dart and Flutter themselves don\u2019t leak memory. You can leak memory when you forget to call dispose() on resources that require to be \"cleared\" after being used. As you already know from chapter , an AnimationController has to be disposed in order to avoid leaks. ..5 Using the Network view Use this tab to inspect HTTP network tra\ufb03c from your Flutter (or Dart) application. By default the tra\ufb03c is captured and logged in the big list on the left: clicking on a row, shows all the details about that particular HTTP event. Flutter Complete Reference 466",
  ". Testing and pro\ufb01ling apps As you can see, there are a lot of very useful details about requests being sent. We strongly recommend you to use this tab rather than using debugPrint() or other logging techniques (see below) to deeply analyze HTTP requests. ..6 Using the Logging view As the name suggests, this tab simply consists of a logger showing events from Flutter, the Dart runtime and other logging events coming from your application. By default, the page will show you: \u2022 Flutter framework events; \u2022 events from the garbage collector; \u2022 events sent from the application, such as the ones \ufb01red by log() When we talk about \"events sent from the application\" we\u2019re referring to the fact that you can log messages (or error messages) from your Dart/Flutter apps while debugging. You have two ways to show messages in the logger tab of DevTools: . Use the debugPrint(\"...\") from Flutter\u2019s foundation library. You could also use print() but if the string is too long, some lines might be ignored by Android. This doesn\u2019t happen if you use debugPrint. . While debugPrint is very simple (it just prints a string), log is more powerful as it\u2019s able to log more information about something you need to analyze. import 'dart:developer' as developer; import 'dart:convert'; String getName(BuildContext context) { // Getting some data using provider final userData = context.read<UserData>(); // Logging the data developer.log( 'Checking whether the name is correct', name: 'event_name', error: jsonEncode(userData) ); Flutter Complete Reference 467",
  ". Testing and pro\ufb01ling apps return userData.name; } Using developer.log() we can send a log event to the Logging view with many mode information. For example, name is the name of the source of the log message and error generally contains additional data to show along with the message. String getName(BuildContext context) { final userData = context.read<UserData>(); if (kDebugMode) { developer.log(...); } return userData.name; With the following approach, logs are being sent only in debug more and thanks to tree shaking 9 developer.log() is automatically removed in pro\ufb01le and release mode. ..7 Monitoring widget rebuilds In Android Studio, when the app is running in debug mode on a real device or emulator, you can easily track the rebuild statistics of any widget. In practice, this table tells you how many times any widget was rebuilt both in the last frame or since when the route has been opened. 9See chapter [TODO] about tree shaking Flutter Complete Reference 468",
  ". Testing and pro\ufb01ling apps Tapping on the grey circle moves the code editor to the interested widget. With these interesting data you can also see how important const constructors are: without them the rebuild count will frequently increase. Instead, constant widgets are built only once and thus you\u2019ll see their counter being stuck at , which is good. \u2022 When you see red bars in pro\ufb01le mode, run the app in debug mode and use this table to see which widgets rebuild quite often. Try to see if you can reduce calls to build by using constant constructors, caching data into \ufb01elds or using some strategies we\u2019ve listed above. \u2022 Don\u2019t look at the Frame rendering time chart above because it shows your app\u2019s fps in debug mode, which is not accurate as you know. Flutter Complete Reference  \"The most important property of a program is whether it accomplishes the intention of its user.\" Charles A. R. Hoare Part III Practical Flutter examples   | Networking .1 Making HTTP requests Nowadays almost any app uses internet to fetch data from an API, interact with Firebase or any other action that requires a Wi-Fi or wired connection. This chapter shows how to properly use Flutter to e\ufb03ciently make HTTP requests to send/receive data from servers. B Resources >",
  "> HTTP Requests ..1 GET requests In this example we\u2019re connecting to JSONPlaceholder , an online API used for testing purposes. It\u2019s a free service at which you can send GET or POST requests and it returns various types of JSON-encoded strings as response. dependencies: http: ^..2 Install the o\ufb03cial http 2 package from the Dart team and follow these step-by-step indications to properly make HTTP requests with Flutter. For brevity, some small classes aren\u2019t shown but they\u2019re of course available in the Resources page of our website. . Our code has to be easily maintainable over the time and easy to read. Here\u2019s where the single responsibility principle and dependency injection come to the rescue. // To be 'implemented' and not 'extended' 1https://jsonplaceholder.typicode.com 2https://pub.dev/packages/http Flutter Complete Reference 473",
  ". Networking abstract class HTTPRequest<T> { Future<T> execute(); } This interface will be implemented by all those classes that perform HTTP requests. Other than respecting the SRP, this class will be injected in the UI widgets via constructor. . The online API we\u2019re connecting to returns a JSON string containing data of a test item. There\u2019s the need to implement HTTPRequest<T> to perform a GET request and returning a model class (Item) representing the received data. import 'package:http/http.dart' as http; class RequestItem implements HTTPRequest<Item> { final String url; const RequestItem({ required this.url }); Future<Item> execute() async { // HTTP request final response = await http.get(url); if (response.statusCode != ) { throw http.ClientException(\"Oh darn!\"); } // Use the model class to make a JSON-to-Item conversion return _parseJson(response.body); } Item _parseJson(String response) => Item.fromJson(jsonDecode(response)); } Thanks to the http package we can perform asynchronous GET or POST requests to get an object of type Response which exposes many useful properties: \u2022 body: the body of the response as a string; \u2022 statusCode: the HTTP status code of the request which can be , 404 or 500 for example; Flutter Complete Reference 474",
  ". Networking \u2022 contentLength: the size, in bytes, of the response body; \u2022 headers: the headers sent from the server in response to our request. As you can imagine, class Item is a simple model that converts a JSON string into an object with the techniques we\u2019ve covered in chapter . It\u2019s been put in a separated function just for readability purposes. . When dealing with futures, like in the case of HTTP requests, there\u2019s the need to use stateful widgets in order to cache the Future<T> object and use it only once. Let\u2019s start with the widget itself: class HTTPWidget extends StatefulWidget { final HTTPRequest<Item> _request; const HTTPWidget(this._request); @override _HTTPWidgetState createState() => _HTTPWidgetState(); } The HTTP request is going to return a JSON object represented by the Item class so we\u2019re requesting for that type in the constructor. Actually, there would be a better way to do this and in .3 we will show how to implement a more complete and \ufb02exible version of HTTPRequest<T>. class _HTTPWidgetState extends State<HTTPWidget> { late final Future<Item> futureItem; @override void initState() { super.initState(); futureItem = widget._request.execute(); } // ... } Since initState executes only once, the API call triggered by execute() is also executed only once. What is absolutely WRONG is fetching HTTP data, or triggering any other method, inside Widget build(): class _HTTPWidgetState extends State<HTTPWidget> { Flutter Complete Reference 475",
  ". Networking @override Widget build(BuildContext context) { // This is absolutely BAD final futureItem = widget._request.execute(); // ... } } Flutter calls build more than once and you can\u2019t predict how many times; with the above code, you\u2019re making an HTTP request at every rebuild of the widget. \u009f Even if you don\u2019t see them, rebuilds happen more often than you think. Putting API calls inside a build method is a bad idea as it wastes resources and performs unneeded HTTP request repeatedly. With a late final member variable you can assign a value only once inside setState and then, in case of a rebuild, the API call won\u2019t be executed again. . Now that we have learnt how to \"cache\" the request, it\u2019s time to use the FutureBuilder<T> widget. Very simply, you give it a Future<T> and it noti\ufb01es you when it\u2019s completed. class _HTTPWidgetState extends State<HTTPWidget> { // ... variables and initState @override Widget build(BuildContext context) { return FutureBuilder<Item>( future: futureItem, builder: (context, snapshot) { if (snapshot.hasError) { return const ErrorItemWidget(); } if (snapshot.hasData) { return SuccessItemWidget(snapshot.data); } Flutter Complete Reference 476",
  ". Networking return const Center( child: CircularProgressIndicator() ); } ); } } Thanks to FutureBuilder<T> you can handle the waiting time, the failure and the success of a Future<T> very easily. The variable AsyncSnapshot<T> snapshot gives you information about the status of the future: (a) hasError: if an exception occurred while executing the Future<T>, this property evaluates to true. A proper widget appears to the screen indicating that something has gone wrong while performing the API call. (b) hasData: it\u2019s false by default but when the Future<T> completes with no errors it becomes true. This is a signal that data have been successfully received and they\u2019re ready to appear. Note that snapshot.data returns a nullable value. The \ufb01nal return statement shows a waiting spinner at the center of the screen. It appears while the Future<T> is still executing; it is very important because it lets the user visually know that some processing is going on in the background. . To use this widget, you \ufb01rst must create an instance of HTTPRequest<T>, outside the build method, and then pass the dependency to the widget. static const _url = \"https://jsonplaceholder.typicode.com/posts/\"; @override Widget build(BuildContext context) { return MaterialApp( home: Scaffold( appBar: AppBar( title: const Text(\"Request Demo\"), ), body: const Center( child: HTTPWidget( RequestItem( url: _url ) Flutter Complete Reference 477",
  ". Networking ) ), ), ); } Notice how we\u2019ve tried to use const constructors as much as possible, especially inside the builder of FutureBuilder<T> where rebuilds happen very frequently. Caching widgets or using constant constructors is always important. ..2 POST requests and headers Making a POST request is no di\ufb00erent from a GET but in addition you have to provide a body of course, which is the payload being sent to the server. final response = await http.post(url, body: \"send this string via POST\", ); You can set encoding: Encoding.getByName(\"utf-\") by passing a lower-case version of the standard charsets names . The body can be of three di\ufb00erent types: \u2022 String: the content-type of the request is automatically set to text/plain; \u2022 List<T>: it\u2019s used as a list of bytes for the body of the request; \u2022 Map<K, V>: it\u2019s treated like if it contained form \ufb01elds and it automatically sets the content- type to application/x-www-form-urlencoded When you do a POST request the returned object is a Future<Response>. For both get() and post() you have the possibility to set headers for the HTTP request; they\u2019re simply implemented as a map where both keys and values are strings: // 'http.post(...)' it works in the same way final response = await http.get(url, headers: { \"Authorization\": \"your_api_key\", } ); 3http://www.iana.org/assignments/character-sets/character-sets.xml Flutter Complete Reference 478",
  ". Networking An API might require incoming requests to contain a special header called \"Authorization\" with a password or a long key. For any request header, add a new entry in the map associated to the headers parameter. \u009f Note that \"Authorization\" is the primary header used by clients to authenticate but it\u2019s not mandatory. The server might request it under a di\ufb00erent name such as \"x-api-key\" or whatever else so be sure to check the documentation before sending the key. The name may vary. The Response object, which is what the request returns, contains the headers returned by the server. It\u2019s a Map<String, String> so it\u2019s easily accessible using the [] operator: final response = await http.get(url); final headers = response.headers; // map of strings final contentLength = response.contentLength; final statusCode = response.statusCode; ..3 Good practices The most important thing to keep in mind is the initialization of a Future<T> inside the initState method so that each rebuild won\u2019t trigger an HTTP request. This is also recommended by the Flutter team 4 in one of their online examples available in the digital cookbook. \u2022 The best way to wait for a Future to complete is the usage of a FutureBuilder<T> widget. It allows you to show a loading indicator while waiting and a very easy handling of the request status (running, completed or failed). \u2022 The builder function of a FutureBuilder<T> class is called many times and thus the usage of const constructors is fundamental. Always remember to use them if possible. When you have to execute a single request, calling http.get(...) or http.post(...) is enough. However, if you\u2019re going to make multiple requests to the same server consider using an instance of an http.Client. final client = http.Client(); try { 4https://\ufb02utter.dev/docs/cookbook/networking/fetch-data#why-is-fetchalbum-called-in-initstate Flutter Complete Reference 479",
  ". Networking final one = await client.get(...); final two = await client.get(...); final three = await client.post(...); // do something else... } finally { client.close(); } Keeping an open connection is more e\ufb03cient than opening and closing single request multiple times. There is less overhead but it\u2019s more \"wasteful\" in terms of internet resources so when you\u2019re done with all of them, close the client immediately. final response1 = await http.get(url); final response2 = await http.post(url); Both get and post methods of the http package are global scope functions you can call straight away. If you look at their internals, they instantiate a client which shoots a single request: // This is how 'get(...)' and 'post(...)' internally work. These functions // are just a shorthand for the creation of a Client object! var client = Client(); try { // 'fn' is declared and used internally return await fn(client); } finally { client.close(); } If you wanted to make a POST request, for example, you could either choose to use the convenient method http.post(...) or create a http.Client() instance. It would be the same. Since there\u2019s no need to add boilerplate code to your logic, in case of single requests use the global methods rather than a client. final url = \"https://mywebsite.com/posts/profile?id=&pages=\"; final response = await http.get(url); The url can directly contain query parameters and the request will execute successfully. If you want to have more control over the string, you have to create an URI object and pass it to the method. Flutter Complete Reference 480",
  ". Networking // Use 'var' if you plan to change this Map later final params = { \"id\": , \"pages\": , }; // Domain and path are required in an URI object final domain = \"mywebsite.com\"; final path = \"/posts/profile\": final uri = Uri.https(domain, path, params); // Pass headers, if any, using the 'header' named optional param await http.get(uri); This is more \ufb02exible but we\u2019ve had to write quite a bit more of boilerplate code than what we\u2019d expect. Notice that Uri de\ufb01nes http and https factories and they are of course not interchange- able. .2 Working with data The http package can also perform I/O operations but dealing with them is actually not so easy. You\u2019d have to work with bytes, encodings, File objects and other things that are a bit too \"low level\". \u009f It\u2019s not a matter of e\ufb03ciency because http does its job very well. The problem is that, for example, there\u2019s no http.downloadFile() and so you\u2019d have to create it by yourself. It doesn\u2019t have many pre-made functions ready to use. There is a very powerful package called dio 5 which provides an easy way to deal with \ufb01les download/upload and, of course, many other networking tasks such as HTTP requests. We recommend to follow this guideline: \u2022 If your app is only going to make HTTP requests, choose between the http or dio packages. They both give you an intuitive and easy way to deal with requests, just pick the one you 5https://pub.dev/packages/dio Flutter Complete Reference 481",
  ". Networking like more. Both are very e\ufb03cient. \u2022 If your app is going to perform networking operations with data, such as downloads or uploads, we recommend to stick with dio as it\u2019s simpler to use. It has a lot of pre-made and useful functions that we\u2019re going to cover in this section. As we\u2019ve already said, with dio you can easily make GET and POST requests which return a Response object, similarly to what http does. There is no need to explain what\u2019s going on because the code is self-explanatory (this is great in terms of maintenance): void main() async { final dio = Dio(); final url = \"https://website.com\"; try { final response1 = await dio.get<String>(url); print(\"${response1.data}\"); final response2 = await dio.post<String>(url, data: { \"key1\": \"\", \"key2\": , }); print(\"${response2.data}\"); } on DioError catch (e) { print(e); } } Very intuitively, queryParameters o\ufb00ers a convenient way to pass query params using a Map<K,V>. In http this process is a bit more tedious because there\u2019s the need for a separated URI object which produces a good amount of boilerplate code. final response1 = await dio.get<String>(url, queryParameters: { \"param1\": , \"param2\": \"\" }); You can also execute multiple requests concurrently and wait for all of them to \ufb01nish. In this case, instead of repeating the same base URL for every request, just set it up once in a new instance of BaseOptions and then make calls with relative paths: Flutter Complete Reference 482",
  ". Networking // The timeout is expressed in milliseconds final options = BaseOptions( baseUrl: \"https://website.com/api/\", connectTimeout: , // 3 seconds ); // New instance of dio with the given options final dio = Dio(options); // Executes 3 requests concurrently and waits for all of them // to complete final response = await Future.wait([ dio.get<String>(\"/version\"), dio.get<String>(\"/products/list\"), dio.post<String>(\"/login\", options: Options( headers: { \"Authentication\": \"auth-key\", } ) ), ]); Thanks to the BaseOptions object the get(\"/version\") method is actually calling the extended version of the URL (get(\"https://website.com/api/version\")) because the value of baseUrl is put in front of the URL endpoint. B Resources >",
  "> Files download ..1 Downloading data We\u2019re now going to see how to create an app that downloads a \ufb01le from a sever and stores it on the device. It\u2019s going to have a button to start the download and a Text to show the completion percentage of the operation. As bytes are received, the percentage increases to re\ufb02ect the progression of the download. Flutter Complete Reference 483",
  ". Networking dependencies: dio: ^..10 provider: ^..+1 path_provider: ^..14 The path_provider package is maintained by the o\ufb03cial Flutter team and it provides a series of utilities to easily get paths to common directories on various operating systems. Just await one of its methods, which return a Directory object, and use the path getter to retrieve the location. final tempDir = await getTemporaryDirectory(); final extDir = await getExternalStorageDirectory(); final downloadDir = await getDownloadsDirectory(); // and more... Our app is going to use the temporary directory of the device but of course it\u2019s just for the sake of the example, you can use any directory you want. The UI is going to look like this: In order to change the text of the button there\u2019s the need to create a ChangeNotifierProvider which will update the percentage while the download is running. DownloadProgress is a model class encapsulating the network I/O logic so it\u2019s a good idea placing it in a dedicated \ufb01le. class DownloadProgress with ChangeNotifier { // Initial value var _progress = .; double get progress => _progress; void start({ required String url, required String filename }) async { Flutter Complete Reference 484",
  ". Networking // download logic... } void _resetProgress() { if (progress != ) { _progress = ; notifyListeners(); } } void _updateProgress(double value) { _progress = value; notifyListeners(); } } The class exposes only the start method, which starts downloading the given \ufb01le to a particular location on the device, and the progress getter, which indicates the completion percentage of the download. void start({ required String url, required String filename }) async { // Reset the percentage in case it isn't at zero _resetProgress(); // Path and name final directory = await getTemporaryDirectory(); final pathName = \"${directory.path}/$filename\"; // Download await Dio().download(url, pathName, options: Options( headers: { HttpHeaders.acceptEncodingHeader: \"*\" } ), Flutter Complete Reference 485",
  ". Networking onReceiveProgress: (received, total) { if (total != -) { // The percentage of the received bytes over // the total size of the file being downloaded var pos = received / total * ; _updateProgress(pos); } } ); } In certain cases it might happen that the total \ufb01le size is not available due to the gzip compression; to avoid this problem set the accept-encoding header to \"*\". If the dimension of the downloaded \ufb01le is not available, total will be set to -1 so always be sure to make a check. @override Widget build(BuildContext context) { return ChangeNotifierProvider<DownloadProgress>( create: (_) => DownloadProgress(), child: MaterialApp( home: Scaffold( appBar: AppBar( title: const Text(\"Demo Download\"); ) body: const Center( child: DownloadWidget(), ) ) ), ); } The noti\ufb01er has to be placed right above the widget listening for progress updates; in this simple application there is a single screen so it just wraps MaterialApp. Be sure to use a Consumer so that only the button will be rebuilt rather than the whole subtree. class DownloadWidget extends StatelessWidget { final String url = \"https://website.com/files/test.pdf\"; const DownloadWidget(); Flutter Complete Reference 486",
  ". Networking @override Widget build(BuildContext context) { return Center( child: Consumer<DownloadProgress>( builder: (context, status, _) { var progress = status.progress.toStringAsFixed(); return RaisedButton( child: Text(\"$progress %\"), onPressed: () => status.start( url: url, localPath: \"myfile.pdf\" ), ); }, ), ); } } If the download fails for any reason, dio automatically stops the download and deletes the contents that have been downloaded up to that point. ..2 Uploading data In certain cases it might happen you had the need to send form data to the server via POST request to a particular URL. For example, one of the most common scenario for this situation is the case in which you have to \ufb01ll an HTML form. <form method=\"post\" action=\"/admin/adduser\" enctype=\"multipart/form-data\"> <input type=\"text\" name=\"nickname\" /> <input type=\"file\" name=\"avatar\" accept=\"image/jpeg\" /> <input type=\"submit\" value=\"Upload\" /> </form> When clicking Upload on the browser, the client sends a request to the server passing a string and an image. With dio it\u2019s possible doing the same thing in just a few lines of code; it sends a POST request to an endpoint with the given payload. Flutter Complete Reference 487",
  ". Networking // Path to the file in the device final fileDir = await getTemporaryDirectory(); final filePath = \"${fileDir.path}/myfile.txt\", // \"Fill the form\" by passing the data final payload = FormData.fromMap({ \"nickname\": \"Roberto\", \"file\": await MultipartFile.fromFile(filePath), }); // Send the request with the payload await dio.post<String>(\"/admin/adduser\", data: payload); The server expects a POST request with \"nickname\" and \"file\" contents; both the HTML page and the Flutter app are sending the data in the same way. Of course you can also send multiple \ufb01les at once in the same request: final payload = FormData.fromMap({ \"nickname\": \"Roberto\", \"moreFiles\": [ await MultipartFile.fromFile(filePath1), await MultipartFile.fromFile(filePath2), await MultipartFile.fromFile(filePath3), ] }); With FormData the default encoding is \"multipart/form-data\" so that your request can also send \ufb01les. If you want another type of encoding, just specify it in the options of the request: await dio.post<String>(\"/admin/adduser\", data: payload, options: Options( contentType: Headers.formUrlEncodedContentType ), ); Like we\u2019ve done for the download, there\u2019s the possibility to show the completion percentage of the upload using a callback that provides the total size of the payload and the current amount of bytes sent. The setup is very similar to what we\u2019ve done in the previous section: \u2022 Create a class UploadProgress with ChangeNotifier which will update our UI with the upload completion percentage. It\u2019s basically the same code of the download example Flutter Complete Reference 488",
  ". Networking with just the di\ufb00erence that we\u2019re using a post() rather than a get(). class UploadProgress with ChangeNotifier { var _progress = .; double get progress => _progress; void start({ required String url, required String filename }) async { // upload logic... } void _resetProgress() { if (progress != ) { _progress = ; notifyListeners(); } } void _updateProgress(double value) { _progress = value; notifyListeners(); } } \u2022 Call the usual post() method but in addition listen to completion percentage changes by giving a value to onSendProgress. void start({ required String url, required String filename }) async { // See the code of the previous example. // Here we reset the progress and get the path to the file await Dio().post<String>(url, fileName, onSendProgress: (sent, total) { Flutter Complete Reference 489",
  ". Networking vas pos = sent / total * ; _updateProgress(pos); } ); } \u2022 At this point use a Consumer<UploadProgress>() in your UI exactly as we did in the previous example to refresh the percentage in the button. This library has a consistent API which is easy to use and full of useful utilities to conveniently convert data formats or construct objects in a few lines. Another demonstration of this is the fact that you\u2019ve multiple ways to pass a \ufb01le to the payload: \u2022 MultipartFile.fromBytes(...): takes as input a List<int> which is the series of bytes representing the \ufb01le; \u2022 MultipartFile.fromFile(...): extracts the \ufb01le\u2019s contents from the given location on the device; \u2022 MultipartFile.fromString(...): converts a string into bytes using the default UTF-8 charset ..3 Good practices We want to point out again that this library isn\u2019t better than http for performance reasons or whatever else because both are very good packages. The biggest advantage in favor of dio is the vastness of its API and the ease of use. For example, downloading a \ufb01le is just a matter of calling download() while http doesn\u2019t have this feature, you\u2019d have to implement it by yourself. \u2022 When you want to listen for upload or download percentages, always rely on provider, \ufb02utter_bloc or another state management library. Avoid the usage of setState or, if it\u2019s really needed (is it?) use it together with InheritedWidget. \u2022 For single requests that don\u2019t need special con\ufb01gurations, you can create an in-place object and use one of its methods immediately. final result = await Dio().get<T>(...); This is not always convenient; for example, if you\u2019re connecting to an API that requires a token you\u2019d better create an instance of Dio with BaseOptions and store the setting in it. In this way any method will inherit the con\ufb01gurations by default. Flutter Complete Reference 490",
  ". Networking final options = BaseOptions( baseUrl: \"https://www.api.website.com/v3/\", connectTimeout: , receiveTimeout: , headers: { \"api-key\": \"value\", \"something\": , } ); final dio = Dio(options); // These request will carry the 'api-key' and 'something' // headers along with all the other settings await dio.get<T>(...); await dio.post<T>(...); await dio.download(...); If you didn\u2019t do this, you\u2019d have to specify the con\ufb01guration for each single request and of course this is not handy at all. \u2022 When you have to deal with \ufb01le downloading, advanced POST requests and/or progress completion status, consider using dio. You\u2019ve seen how easy it is to use in such cases; you could do it with http as well but you\u2019d have to do most of the work by yourself. \u2022 Look for Reso Coder\u2019s online video 6 about Dio and interceptors, a sort of listeners that run every time an action is performed. It will show you how to easily implement retiries in case of connection failures. . B Resources >",
  "> Advanced HTTP .3 Advanced REST API calls Unless you\u2019re using Firebase, which will be covered in detail in chapter , apps very often need to communicate with a JSON REST service. In this section we\u2019re illustrating a possible imple- 6Dio Connectivity Retry Interceptor - Flutter Tutorial Flutter Complete Reference 491",
  ". Networking mentation of e\ufb03cient data fetching and parsing from an online API. \u009f In the following example we\u2019re working with JSON but of course any other format is \ufb01ne. Nowadays most of the REST services work with JSON but, for example, you still might encounter a SOAP service which uses XML. We\u2019re going to receive data from https://jsonplaceholder.typicode.com, a fake online REST API service for testing purposes. Before starting, we need to create a good folder structure for the HTTP client which might look like this: lib/ api/ json_models/ json_parsers/ http_client.dart main.dart routes.dart Let\u2019s see how the logic has been splitted into multiple \ufb01les and folders. ..1 Model classes Inside json_models/ we\u2019re going to place all those model \ufb01les required to parse a json-encoded string into a Dart object, using code generation. For example, the endpoint \"/posts/\" (it could have been any other number) returns this kind of response: { \"userId\": , \"id\": , \"title\": \"abc\", \"body\": \"abc def\" } As we\u2019ve seen in chapter , thanks to code generation, we can easily create a model class for this JSON string. The code is located in json_models/post.dart part 'post.g.dart'; @JsonSerializable() Flutter Complete Reference 492",
  ". Networking class Post { final int userId; final int id; final String title; final String body; const Post(this.userId, this.id, this.title, this.body); factory Post.fromJson(Map<String, dynamic> json) => _$PostFromJson(json); Map<String, dynamic> toJson() => _$PostToJson(this); } Similarly, inside json_models/todos.dart, we\u2019re creating another model class to deal with a list of todo items having the following structure: [ { \"userId\": , \"id\": , \"title\": \"delectus aut autem\", \"completed\": false }, { \"userId\": , \"id\": , \"title\": \"quis ut nam facilis et officia qui\", \"completed\": false }, ] Since the returned JSON is an array, and not an object containing an array, you just need to create a model for the inner object. The array will be manually converted. part 'todo.g.dart'; @JsonSerializable() class Todo { ... } Flutter Complete Reference 493",
  ". Networking Note that if the response were a bit di\ufb00erent, maybe something like this... { \"data\": [ { \"userId\": , \"id\": , \"title\": \"delectus aut autem\", \"completed\": false }, ] } ... you would have to create two model classes. The \ufb01rst one for the \"outer\" object, the one with the list, and the second one to handle the contents of the list: part 'todo.g.dart'; @JsonSerializable(explicitToJson: true) class TodoObject { final List<Todo> data; const TodoObject(this.data); factory TodoObject.fromJson(Map<String, dynamic> json) => ... Map<String, dynamic> toJson() => ... } @JsonSerializable() class Todo { ... } ..2 Parsing JSON Once the HTTP request has completed with success, as you know, we need to convert the JSON string into a convenient Dart object. We should think about a good way of doing it because there\u2019d be the need to: \u2022 keep the maintenance easy so that the addition or removal of JSON parsers shouldn\u2019t a\ufb00ect any other part of the code; Flutter Complete Reference 494",
  ". Networking \u2022 classes should be small, concise and to the point; \u2022 there shouldn\u2019t be strong dependencies in the hierarchy. In other words, our architecture should respect the SOLID principles. Let\u2019s start with a good setup for a base class that will be used by parsers: // lib/api/json_parsers/json_parser.dart library json_parser; export \"post_parser.dart\"; export \"todo_parser.dart\"; export \"object_decoder.dart\"; abstract class JsonParser<T> { const JsonParser(); Future<T> parseFromJson(String json); } This kind of structure is the same you\u2019d use to create Dart/Flutter libraries, as we will see in detail in chapter . We\u2019re creating the \"json_parser\" library and, at the same time, exporting the various parsers we need to translate JSON strings into Dart objects. \u009f Thanks to the export keyword we\u2019re able to import together with the json_parser.dart \ufb01le also other \ufb01les. This is very useful because you can do the following: import 'package:myapp/api/json_parsers/json_parser.dart'; final todo = TodoParser(); final post = PostParser(); There\u2019s only one import directive to be able to use any kind of parsers. If you didn\u2019t use export, you had instead to import classes one by one: import 'package:myapp/api/json_parsers/todo_parser.dart'; import 'package:myapp/api/json_parsers/post_parser.dart'; final todo = TodoParser(); final post = PostParser(); Flutter Complete Reference 495",
  ". Networking This export-way of writing libraries is exactly what the Flutter team suggests when it comes to writing package. This technique is also well described in .1 where we build a Dart/Flutter package from scratch. We have created some convenient mixins. We constrained the mixin (on JsonParser<T>) so that only its subtypes will be able to use those methods. mixin ObjectDecoder<T> on JsonParser<T> { Map<String, dynamic> decodeJsonObject(String json) => jsonDecode(json) as Map<String, dynamic>; } mixin ListDecoder<T> on JsonParser<T> { List<dynamic> decodeJsonList(String json) => jsonDecode(json) as List<dynamic>; } Since our parsers are often going to use jsonDecode(), we want to avoid code duplication among classes and so a mixin is what we\u2019re looking for. Here\u2019s the implementation of the various parsers: // lib/api/json_parsers/post_parser.dart class PostParser extends JsonParser<Post> with ObjectDecoder<Post> { const PostParser(); @override Future<Post> parseFromJson(String json) async { final decoded = decodeJsonObject(json); return Post.fromJson(decoded); } } // lib/api/json_parsers/todo_parser.dart class TodoParser extends JsonParser<List<Todo>> with ListDecoder<List<Todo>> { const TodoParser(); @override Flutter Complete Reference 496",
  ". Networking Future<List<Todo>> parseFromJson(String json) async { return decodeJsonList(json) .map((value) => Todo.fromJson(value as Map<String, dynamic>)) .toList(); } } In the future you may have the need to parse data from the \"/info\" endpoint, for example. No problem! Create the class Info model and then add a new implementation of JsonParser<T>: class InfoParser extends JsonParser<Info> with ObjectDecoder<Info> { @override Future<List<Album>> parseFromJson(String json) async {} } Adding new features doesn\u2019t involve touching existing code but just creating new classes (open- closed principle) and each class is speci\ufb01c for a single type of parsing (single responsibility prin- ciple). ..3 HTTP Client Now that we can parse JSON strings and represent them as Dart objects, there\u2019s the need to make the actual request. The http package is \ufb01ne but dio is more customizable and easier to use on large scale: // lib/api/http_client.dart class RequestREST { final String endpoint; final Map<String, String> data; const RequestREST({ required this.endpoint, this.data = const {}, }); /// HTTP dio client static final _client = Dio( BaseOptions( baseUrl: \"https://jsonplaceholder.typicode.com/\", connectTimeout: , // 3 seconds Flutter Complete Reference 497",
  ". Networking receiveTimeout: , // 3 seconds headers: <String, String>{ \"api-key\": \"add_one_if_needed\", }, ) ); Future<T> executeGet<T>(JsonParser<T> parser) async {...} Future<T> executePost<T>(JsonParser<T> parser) async {...} } We\u2019ve decided to make the client static because those settings will always be the same, so no need to create a new Dio instance for each request. In the constructor we\u2019re asking for two parameters: \u2022 String endpoint: the API endpoint at which the request has to be sent; \u2022 Map<String, String> data: it could hold query parameters for a GET request or the payload of a POST. It\u2019s up to you and it could also be removed if not needed. The only public methods are executeX<T>: they\u2019re called in order to make the actual request. Note how the parser is asked via method injection rather than being directly hard-coded inside the class. Future<T> executeGet<T>(JsonParser<T> parser) async { final response = await _client.get<String>(endpoint); return parser.parseFromJson(response.data); } Future<T> executePost<T>(JsonParser<T> parser) async { final formData = FormData.fromMap(data); final response = await _client.post<String>( endpoint, data: formData, ); return parser.parseFromJson(response.data); } Thanks to generics the code is not tied to a speci\ufb01c model class; both methods can be called on Flutter Complete Reference 498",
  ". Networking any type of object. The parser is passed from the outside so that the methods know nothing about parsing details, which is not their business. \u009f If your app connects to di\ufb00erent APIs you shouldn\u2019t make the internal client of the request class static. Instead, the client should come from the outside via dependency injection: class RequestREST { final Dio client; final String endpoint; final Map<String, String> data; const RequestREST({ required this.client, required this.endpoint, this.data = {}, }); } In this way, there\u2019s the need to pass a client with the given settings for each request (endpoint, timeouts etc). You could make requests in a bloc or in a FutureBuilder<T>, caching the future as you\u2019ve learnt, but they\u2019re always performed in the same way. After having instantiated a RequestREST instance, make a POST or a GET passing the proper parser for the data. // Example of a request in the state of a StatefulWidget late final Future<List<Todo>> todos; @override void initState() { super.initState(); todos = RequestREST(endpoint: \"/todos\") .executeGet<List<Todo>>(const TodoParser()); } Thanks to this setup you can easily write requests: for the simplest cases, you just need to assign Flutter Complete Reference 499",
  ". Networking an endpoint and pass an instance of the JSON parser. The UI is going to use a FutureBuilder<T> with the classic setup: late final Future<List<Todo>> todos; @override void initState() { super.initState(); todos = RequestREST(endpoint: \"/todos\") .executeGet<List<Todo>>(const TodoParser()); } @override Widget build(BuildContext context) { return FutureBuilder<List<Todo>>( future: todos, builder: (context, snapshot) { if (snapshot.hasData) { // Remember that 'snapshot.data' returns a nullable final data = snapshot.data ?? []; return ListView.builder( itemCount: data.length, itemBuilder: (context, index) { ... }, ); } if (snapshot.hasError) { return const ErrorWidget(); } return const Center( child: CircularProgressIndicator(), ); }, ); } In case snapshot.data was null, we could also have shown the error widget. We have provided Flutter Complete Reference 500",
  ". Networking an empty list as default value just for the sake of the example, but of course you have multiple ways to handle the nullability. final data = snapshot.data; if (data != null) { return ListView.builder( itemCount: data.length, itemBuilder: (context, index) { ... }, ); } else { return const ErrorWidget(); } Flutter Complete Reference   | Assets, images and multimedia .1 Assets and images In Flutter you have the possibility to add a series of resources to your app, technically known as assets, like images and videos. Assets are bundled with the binary \ufb01le in order to be used at runtime; there are no restrictions on the \ufb01le formats: \u2022 images of various formats such as JPG, PNG or GIF; \u2022 videos; \u2022 textual \ufb01les such as those with txt, xml or json extension; \u2022 databases such as SQLite \ufb01les; \u2022 any other kind of static data. In order to bundle an asset within your app, and thus being able to use it in the code, it has to be declared in the pubspec.yaml \ufb01le. For example if you wrote this... flutter: assets: - myassets/ ... it would mean that Flutter will look for assets in a folder called myassets. Paths are relative to the root of the project so writing myassets/ implies that a directory called myassets is located at the same level as the pubspec.yaml \ufb01le. flutter: assets: - myassets/logo.png - myassets/client_config.json Flutter Complete Reference 502",
  ". Assets, images and multimedia It\u2019s also possible selectively including certain \ufb01les to the app; in this way only those assets you\u2019ve speci\ufb01ed will be bundled while the others will simply be ignored. From your code, you can reference assets using class AssetBundle which provides two important methods: \u2022 loadString(String path): loads a text asset; \u2022 load(String path): loads a binary asset which can be an image or any other type of \ufb01le; Again, the path is relative to the root of the project and it doesn\u2019t have to start with a slash. Let\u2019s say your project were made up of the following \ufb01les and directories: lib/ myassets/ file.txt pubspec.yaml Flutter would access the asset using load(\"myassets/file.txt\") and not load(\"file.txt\". You have to specify the path from the root to the \ufb01le because directories are not implicitly deducted at build time. import 'package:flutter/services.dart' show rootBundle; class ConfigLoader { void loadConfig() async { final cfg = await rootBundle.loadString(\"myassets/some_cfg.json\"); doSomething(cfg); } } Any Flutter app exposes a rootBundle object that allows you to easily load assets but it shouldn\u2019t be used inside a StatelessWidget or a StatefulWidget. In the example, ConfigLoader is simply a model class made by us. class MyWidget extends StatelessWidget { const MyWidget(); Future<String> loadConfig(BuildContext context) async => await DefaultAssetBundle.of(context) .loadString(\"myassets/some_cfg.json\"); } When you have the need to retrieve an asset from a widget, use DefaultAssetBundle instead of Flutter Complete Reference 503",
  ". Assets, images and multimedia the rootBundle object. Both approaches return the same type of object so you\u2019ll always end up calling load() or loadString(). \u009f We\u2019ve only shown json \ufb01les in the examples but load() is able to read any kind of binary resource from the bundled assets. It returns a ByteData object which is simply a \ufb01xed-length sequence of bytes representing the resource. There is also the possibility to load di\ufb00erent variants of an image in di\ufb00erent ways according to the context in which they are rendered. While this sentence might sound di\ufb03cult to understand, this example will clarify what it\u2019s saying. The following PNG image is the same but it comes in three di\ufb00erent sizes: If you created three di\ufb00erent PNG \ufb01les, one for each size, and you gave them the same name, Flutter would automatically pick the best image according to the pixel ratio of your device. This is quite easy to achieve: just place the smallest \"default\" image at the root of the asset directory and then make a series of sub-directories with a speci\ufb01c name: myassets/ logo.png .0x/logo.png .0x/logo.png Here myassets/logo.png is the default image with a resolution of . (32x32); if your app is run on a device with a .1 aspect ratio, Flutter will automatically pick the myassets/.0x/logo.png variant. It\u2019s important having the names of the folder re\ufb02ecting the actual sizes, so inside .0x the image should double the size of the default one. In fact: \u2022 logo.png: 32 x  (default) Flutter Complete Reference 504",
  ". Assets, images and multimedia \u2022 .0x/logo.png 64 x  (which is  * ) \u2022 .0x/logo.png 96 x  (which is  * ) Di\ufb00erent variants of the image must have the same name: notice that we\u2019ve always used logo.png. You also must call directories following the \"Rx/ \" pattern where R is the num- ber indicating the ratio. You can also use \ufb02oating point numbers such as .5x/ which is valid. \u009f We highly recommend using asset variants for your images because Flutter auto- matically picks the one that suits better according to the device in which the app is being used. Keep in mind that the more assets you bundle in your app, the bigger the size of your \ufb01nal executable will be. Try to reduce the sizes of your assets with techniques such as mini\ufb01cation. We recommend you to try following these guidelines as much as possible: \u2022 Don\u2019t create too much variants for the same image, make your decision according to the devices that your app is going to run on. \u2022 The size of a PNG image can be reduced up to % by optimizing it with dedicated software or even online tools. Try to use them as much as possible if you use PNG images so that the \ufb01nal size of your executable won\u2019t be bloated too much. \u2022 Instead of resizing and scaling an image at runtime, which might result in a low quality picture, use assets variants and bundle di\ufb00erent sizes of the same \ufb01le. On a side note, your app\u2019s con\ufb01guration can also be stored using shared preferences (more on them in chapter ), a secure storage or simply on a web service. Storing data in json assets and loading them is not common. .2 Working with images Once you\u2019ve declared the images you\u2019re going to use as assets via pubspec.yaml they\u2019re ready to be used in the code. Very intuitively you\u2019re going to use the Image() widget to deal with all the supported formats and it will automatically pick the best variant according to the pixel ratio of the device. @override Widget build(BuildContext context) { Flutter Complete Reference 505",
  ". Assets, images and multimedia return const Center( child: Image( image: AssetImage(\"myassets/something.png\"), ) ); } Notice the usage of the const constructor which is as always very important. Alternatively, you can use a named constructor which does the same thing with the exception it doesn\u2019t provide a constant constructor: @override Widget build(BuildContext context) { return Center( child: Image.asset(\"myassets/something.png\"), ); } If you have to load an image stored as a sequence of bytes, use the Image.memory() variant of the constructor which supports only compressed formats (such as png). Uncompressed formats such as rawRgba will lead to undesired runtime exceptions. B Resources >",
  "> Network images ..1 Loading from the network In this example we are going to see how to load an image stored in a server rather than loading it from the assets. We\u2019re \ufb01rst going to see how to do it with a progress indicator, which is useful to show the fetching progress, and then in another way, that just shows a Loading... placeholder. . In this \ufb01rst example we\u2019re creating a widget showing an image obtained from the network and, while it\u2019s being downloaded, a progress indicator appears. All of this is possible thanks to class Image and its very convenient Image.network() constructor. class ImageFromWeb extends StatelessWidget { final String url; const ImageFromWeb({ required this.url }); Flutter Complete Reference 506",
  ". Assets, images and multimedia @override Widget build(BuildContext context) { return Center( child: Image.network(url, loadingBuilder: (context, child, progress) { if (progress == null) return child; return const Center( child: CircularProgressIndicator(), ); }, ), ); } } Given an url pointing to a valid image, while it\u2019s being loaded an animated circular progress indicator appears at the center of the screen. Instead of having a rotating circle spinning around, you might decide to show the actual progression percentage: var percentage = .; final total = progress.expectedTotalBytes; if (total != null) { final current = progress.cumulativeBytesLoaded; percentage = current / total; } return Center( child: CircularProgressIndicator( value: percentage ) ); Alternatively, instead of using a circle, there\u2019s the possibility to use a classic linear progress bar using a di\ufb00erent class name but with the same setup: return Center( child: LinearProgressIndicator( Flutter Complete Reference 507",
  ". Assets, images and multimedia value: percentage ), ); . In this example we\u2019re doing the same thing as before but instead of showing a progress indicator, we are just using a \"placeholder\" widget that doesn\u2019t care about the progression percentage. It just tells the user that the image is being fetched but it gives no info about the progress. class ImageFromWeb extends StatelessWidget { final String url; const ImageFromWeb({ required this.url }); @override Widget build(BuildContext context) { return Center( child: Image.network(url, frameBuilder: (context, child, _, loaded) { if (loaded) return child; // 'Text' or anything else that doesn't // depend on the prgoression value return const Text(\"Loading...\"); }, ), ); } } The text \"Loading...\" remains visible until the \ufb01rst frame of the image is available and then it\u2019s replaced with the picture. Basically this example is the same as before but instead of a progress indicator there\u2019s a simple text. Use the approach that suits better the use-case you\u2019re going to implement; for example if you\u2019re loading a big image, it might be good using the frameBuilder to show progress. If you have something like a custom widget to display while waiting for the download, and it doesn\u2019t depend on the progress, use frameBuilder. Flutter Complete Reference 508",
  ". Assets, images and multimedia \u009f When using loadingBuilder the Image() widget is rebuilt very often until the image is ready to be displayed. If you\u2019re showing a loading progress indicator it\u2019s \ufb01ne, but in any other case (for instance when you use text such as Loading ...) prefer using frameBuilder. The biggest problem is that there isn\u2019t the possibility to directly handle any possible error while fetching the image. A solution would be trying to instantiate a dio client and make a GET request to check if the resource is available, or directly use it for the entire fetching process. However this would require a lot of boilerplate code. Image.network(url, frameBuilder: (...) {}, errorBuilder: (...) {} // it doesn't exist ) These problems are solved by a very popular package called cached_network_image 1 which implements error handling, caching and image fetching. It\u2019s very straightforward to use. class CachedImgNetwork extends StatelessWidget { final String imgUrl; const CachedImgNetwork({ required this.imgUrl }); @override Widget build(BuildContext context) { return CachedNetworkImage( imageUrl: imgUrl, placeholder: (context, url) => const CircularProgressIndicator(), errorWidget: (context, url, error) => const Icon(Icons.error), ); } } When the download completes, the progress indicator goes away and the image appears on the screen with, by default, an animation of type Curves.easeIn. Any issue, such as invalid format or connection error, is handled by errorWidget which also provides the description of what\u2019s gone wrong. You can also set: 1https://pub.dev/packages/cached_network_image Flutter Complete Reference 509",
  ". Assets, images and multimedia \u2022 the type of animation and the duration; \u2022 HTTP headers if needed; \u2022 the size of the images and the box \ufb01t. By default images are cached and stored in the temporary directory of your device; if you try to load the image multiple times it will be downloaded only once. You can change this behavior by subclassing BaseCacheManager and creating your own manager. CachedNetworkImage( imageUrl: imgUrl, progressIndicatorBuilder: (context, url, status) { return CircularProgressIndicator( value: status.progress, ); }, errorWidget: (context, url, error) => const Icon(Icons.error), ); This is a variant of the preceding example in which we\u2019re still using a loading indicator but it\u2019s also showing the progression percentage of the download. \u009f We recommend the usage of CachedNetworkImage as it\u2019s very simple to use and it o\ufb00ers many functionalities. With Image.network(...) you have more work to do to achieve the same results: \u2022 both loadingBuilder and frameBuilder can be animated too but you have to do everything by yourself; \u2022 it doesn\u2019t have an internal cache so you\u2019d have to create it from scratch and handle it separately; \u2022 it has no error detection so you have to invent something. .3 Scalable vector graphics Images in the .svg format are the ones that you should really consider while developing your app. Potentially, they lead to bandwidth savings, simpli\ufb01ed work\ufb02ow and high image quality. The main big advantages of vector images are the following: Flutter Complete Reference 510",
  ". Assets, images and multimedia . This \ufb01le format does NOT depend on the resolution of the screen, the size or any other hardware spec. SVG images are based on shapes, paths and \ufb01lls so they have no resizing or scaling problems; they\u2019ll always be painted in high quality. . Generally a .svg \ufb01le is smaller in size than a .png . We\u2019ve seen that PNG images require di\ufb00erent variants for the same asset because the \ufb01le format is dependent on the screen. The pixels of the image are well-de\ufb01ned on a matrix of colors and, when resizing, the result will drop in quality. If you migrated to SVG images you\u2019d just need to have a single \ufb01le; it has no resizing or pixel density problems at all and it can in\ufb01nitely scale. This is also a practical advantage because there\u2019s no need to maintain n di\ufb00erent variants but only one. \u009f SVG \ufb01les can be optimized as well and there are many online tools for this such as nano 3 that we recommend to use. Vector images guarantee high quality images and (in most of the cases) a small \ufb01le size but 2https://vecta.io/blog/comparing-svg-and-png-\ufb01le-sizes 3https://vecta.io/nano Flutter Complete Reference 511",
  ". Assets, images and multimedia they\u2019re not always the best choice for your project. While the perfect \ufb01le format for any use case doesn\u2019t exist, we can give you this general guideline: \u2022 Use vector images when you need your images to scale well without losing quality at all. This can be the case of a background image whose size can vary a lot because, for example, you might have the need to show it on a mobile phone (6 inches) and a tablet (12 inches). \u2022 Use PNG images in all those cases in which the image is very complex, full of details and it also has to preserve the transparency. Always remember to optimize the \ufb01le to reduce its overall size. Also, if the image has a \ufb01xed size and it doesn\u2019t need scaling, maybe a PNG would work better than a SVG. When the image is very detailed and complex, the SVG representation is hard to create and also relatively expensive for the graphic engine to decode. A PNG would be better because it\u2019s just a map of colors which needs no paths calculations, it still has a high quality but it doesn\u2019t resize well. There are a lot of compromises for both formats, so wisely test your apps before deciding which one suits better. ..1 Working with SVG \ufb01les If you want to work with SVG images you should use the famous \ufb02utter_svg 4 package made by Dan Field. In this simple example we\u2019re going to load an vector image from the assets (assuming it contains no errors inside). \u009f Add the package as dependency in the pubspec.yaml \ufb01le following the instruc- tions at https://pub.dev. Before putting the .svg in your assets, be sure to optimize the \ufb01le with a proper tool such as nano. The SvgPicture class is able to load vector assets from various sources, similarly to what we\u2019ve seen earlier with the Image() class. class SvgDemo extends StatelessWidget { const SvgDemo(); @override Widget build(BuildContext context) { return Center( 4https://pub.dev/packages/\ufb02utter_svg Flutter Complete Reference 512",
  ". Assets, images and multimedia child: SvgPicture.asset( \"myassets/question.svg\", width: , placeholderBuilder: (_) => const CircularProgressIndicator(), ) ); } } If the vector is particularly complex and it requires some time to load, there\u2019s the possibility to show a loading indicator. As you can see, this class is very easy to use and it exposes many useful parameters such as: \u2022 width and height to specify the dimensions of the image; \u2022 fit to determines how to draw the picture in the box that contains it; \u2022 alignment that defaults to Alignment.center ..2 Loading from the network Loading an image from the network with \ufb02utter_svg follows the same pattern you already saw in the previous section. There\u2019s the possibility to show a progress indicator while the \ufb01le is being downloaded and processed, but the class doesn\u2019t provide a way to handle connection errors. SvgPicture.asset( \"https://website.com/images/theimg.svg\" height: , placeholderBuilder: (_) => const CircularProgressIndicator(), ) We\u2019re now going to show a more complete approach that also takes care of error handling and ensures that, in case of problems, the user is noti\ufb01ed. We\u2019re doing it with dio but you could have used any other HTTP package that easily allows you to handle connection failures. . The \ufb01rst step involves the creation of a model class about networking; once the image has been downloaded, it will be passed to the SvgPicture widget which will take care of painting it to the UI. We\u2019ve made the client variables static so that they\u2019re created only once (the same instance can be reused). Flutter Complete Reference 513",
  ". Assets, images and multimedia class Downloader { final String url; const Downloader({ required this.url }); static final _opt = BaseOptions( baseUrl: \"https://fluttercompletereference.com/\", connectTimeout: , responseType: ResponseType.bytes ); static final _client = Dio(_opt); Future<List<int>> start() async { final request = await _client.get<List<int>>(url); return request.data; } } We\u2019re not downloading the vector as a string but as raw bytes; they will be passed to a SvgPicture object which will handle the decoding. For this reason, there\u2019s the need to set the response type to ResponseType.bytes which returns a list of integers. Note: class Downloader { final String url; const Downloader({ required this.url }); Future<List<int>> start(Dio client) async { final request = await client.get<List<int>>(url); return request.data; } } If each request needs a particular setup, don\u2019t make the client and its options static but instead ask them as external dependency (method injection). . Using a FutureBuilder<T> we\u2019re able to place a loading indicator while dio performs the request but we can also show an error message or whatever else in case of problems. You can \ufb01nd the code of the error widgets in the Resources section of our website. class SvgFromWeb extends StatefulWidget { Flutter Complete Reference 514",
  ". Assets, images and multimedia const SvgFromWeb(); @override _SvgFromWebState createState() => _SvgFromWebState(); } class _SvgFromWebState extends State<SvgFromWeb> { late final Downloader downloader; late final Future<List<int>> svgImage; @override void initState() { super.initState(); downloader = const Downloader(url: \"/demoimages/firefox.svg\"); svgImage = downloader.start(); } // build method... } As always, we need to create a stateful widget because we don\u2019t want the FutureBuilder<T> to execute multiple unneded requests. We had already covered this topic in chapter 17 with the same situation; this pattern always applies when working with Future<T>s inside widgets. FutureBuilder<List<int>>( future: svgImage, builder: (context, snapshot) { if (snapshot.hasError) { return const ErrorWidget(); } if (snapshot.hasData) { if (snapshot.data != null) { return SvgPicture.memory( Uint8List.fromList(snapshot.data!), placeholderBuilder: (_) => const DecoderLoader(), ); } else { Flutter Complete Reference 515",
  ". Assets, images and multimedia return const ErrorWidget(); } } return const NetworkLoader(); }, ); By default, a loading indicator appears while the image is being received from the network. If all goes well, we want SvgPicture to show another loader in case the image takes some time to be decoded; the user will always be aware that there\u2019s some work going on. The raw bytes downloaded by dio are passed to the SvgPicture.memory() constructor which decodes an SVG from a series of bytes. memory() loads an in-memory representation of a vector stored as a List<int> and that\u2019s why we set responseType: ResponseType.bytes in our client\u2019s options. Those bytes are stored in memory and then the SvgPicture decoder will read them and paint the image to the screen. In this example we\u2019ve used dio to deal with the networking part and all of its details, SvgPicture to paint the image to the screen and FutureBuilder<T> to take care of loading spinners and error messages, if any. To sum up, this is the execution \ufb02ow: . get the SVG as raw bytes from the network using dio; . thanks to FutureBuilder<List<int>> show a loading indicator; . use the memory() constructor to decode the in memory representation of the vector and paint it. Flutter Complete Reference 516",
  ". Assets, images and multimedia .4 Audio and video with Flutter B Resources >",
  "> Playing a video ..1 Playing a video In this example we\u2019re going to see how to load a video from the network; we will interact with it changing the volume and using the play/stop button. The Flutter team has created the video_player 5 package which provides an easy way to handle video \ufb01les from assets, network or \ufb01le system. The app is going to look like this: The buttons interact with the video by playing or pausing it and the slider below changes the volume. While the UI seems very poor, there are many aspects to consider when writing the 5https://pub.dev/packages/video_player Flutter Complete Reference 517",
  ". Assets, images and multimedia actual code. . First of all there\u2019s the need to add video_player as external dependency in the pubspec \ufb01le. Be sure to open pub.dev and check which is the latest version. . The slider has to change the volume of the video and update its current position so the state of the widget is going to change. We\u2019re going to handle this with provider using the same approach you\u2019ve seen many times up to now. class VolumeManager with ChangeNotifier { var _volume = .; double get volume => _volume; void setVolume({ required double volumeValue, required VideoPlayerController controller }) { _volume = volumeValue; controller.setVolume(_volume); notifyListeners(); } } The VideoPlayerController class comes from video_player package and it\u2019s used to change the volume or play/pause/stop the video; it\u2019s an external dependency. What we really want to do here is notify the Slider that the volume has changed and refresh it. . The widget containing the video, the buttons and the slider have to be stateful because there are initialization and \ufb01nalization tasks to execute. They are needed to setup the video handler and release it when it\u2019s not needed anymore in order to not waste resources. class _VideoWidgetState extends State<VideoWidget> { late final VideoPlayerController controller; late final Future<void> initVideo; @override void initState() { super.initState(); Flutter Complete Reference 518",
  ". Assets, images and multimedia // In this example we're loading it from the assets // but you could also get it from the network! controller = VideoPlayerController.asset( \"assets/butterfly.mp4\" ); controller.setLooping(true); initVideo = controller.initialize(); } @override void dispose() { controller.dispose(); super.dispose(); } // build... } We\u2019re are going to use a FutureBuilder<void> to await the loading of the video so in initState we need to assign the returned value of initialize() to an instance variable. Always remember to dispose the controller inside dispose() to avoid potential memory leaks. Note that class VideoControllerPlayer has many constructors: \u2022 VideoControllerPlayer.asset(): loads a video from the assets; \u2022 VideoControllerPlayer.network(): loads a video from the network; \u2022 VideoControllerPlayer.file(): loads a video from a \ufb01le located somewhere in the \ufb01lesystem of your device. Their initialize() method returns a Future<void> so the interface doesn\u2019t change; just use the named constructor you need and all the other code will stay the same. . Since the controller doesn\u2019t return any data, in FutureBuilder<void> we don\u2019t have to look for snapshot.hasData but instead snapshot.connectionState, which tells us something about the state of the future. @override Widget build(BuildContext context) { return FutureBuilder<void>( Flutter Complete Reference 519",
  ". Assets, images and multimedia future: initVideo, builder: (context, snapshot) { if (snapshot.connectionState == ConnectionState.done) { return PlayWidget(controller); } return const Center( child: CircularProgressIndicator(), ); }, ); } When the status is ConnectionState.done, the video has been loaded with success and it\u2019s ready to be played. The buttons and other UI widgets that interact with the user have been moved to a another widget (PlayWidget) to separate the concerns and keep the method short. . Passing a reference to the controller via constructor injection is very important because we don\u2019t want a strong dependency with the object responsible of playing and stopping the video. We\u2019ve created two private methods that will be called by the buttons to start or pause the video. class PlayWidget extends StatelessWidget { final VideoPlayerController controller; const PlayWidget(this.controller); // build method... void _play() { if (!controller.value.isPlaying) { controller.play(); } } void _pause() { if (controller.value.isPlaying) { controller.pause(); } Flutter Complete Reference 520",
  ". Assets, images and multimedia } } This is the body of the build method with the most important parts. Of course the entire source code is available online in the Resources area of our o\ufb03cial website. Column( mainAxisAlignment: MainAxisAlignment.spaceAround, children: <Widget>[ // The video AspectRatio( aspectRatio: controller.value.aspectRatio, child: VideoPlayer(controller), ), // \"Play!\" and \"Pause\" buttons Row(...), // The slider Consumer<VolumeManager>( builder: (context, manager, _) => Slider( value: manager.volume, onChanged: (value) { manager.setVolume( volumeValue: value, controller: controller, ); }, ), ), ], ); The AspectRatio widget is very important because it ensures that the size of the widget is consistent with the aspect ratio of the video. If you\u2019re playing a video that has a :3 width:height aspect ratio, this widget automatically sets the size. AspectRatio( aspectRatio: /, Flutter Complete Reference 521",
  ". Assets, images and multimedia child: VideoPlayer(controller), ), You could have set the ratio value by hand, which is just a double, but if you assign it with the aspectRatio property of the controller you get the proper value of any video automat- ically. In general, this widget is very useful when you don\u2019t care about the dimensions of the child but you want to preserve its width:height ratio. onChanged: (value) { manager.setVolume( volumeValue: value, controller: controller, ); }, The Slider has an onChanged listener which gives as parameter the current position of the pointer (in our case, the current value of the volume). We use it to update the volume thanks to the object provided by a Consumer<VolumeManager>() which also takes care of rebuilding the slider. B Resources >",
  "> Listening to music ..2 Listening to music In this example we\u2019re showing how you can listen to music, whether it be a single audio or a playlist of any dimension, using the assets_audio_player 6 plugin. Once the music has been bundled as asset, it will be possible to play it. 6https://pub.dev/packages/assets_audio_player Flutter Complete Reference 522",
  ". Assets, images and multimedia The button on the left opens and starts the audio while the one on the right plays/pauses the track. In the middle a Text widget is showing the elapsed time. We\u2019re going to work class AssetsAudioPlayer which is very easy to use: final player = AssetsAudioPlayer(); player.open(Audio(\"assets/music/song1.mp3\")); // And then interact with it! player.pause(); player.playOrPause(); player.stop(); You just need to call open(\"path/to/file.mp3\") to load the \ufb01le and then with the player object you interact with the audio track. Of course, be sure to have your audio \ufb01les declared as assets in the pubspec \ufb01le. You can also load a playlist and the player will play, in sequence, every track of the list: final player = AssetsAudioPlayer(); player.openPlaylist( Playlist( Flutter Complete Reference 523",
  ". Assets, images and multimedia assetAudioPaths: [ \"assets/music/track1.mp3\", \"assets/music/track2.mp3\", \"assets/music/track3.mp3\" ] ) ); player.playlistNext(); player.playlistPrev(); player.stop(); Skip to a particular track using player.playlistPlayAtIndex(n). In our example we\u2019re going for a single audio \ufb01le but you can easily change it to load a playlist and maybe also load a random image at the top. . As usual, start by importing the latest version of the package in the pubspec.yaml \ufb01le. Create a directory called music/ and add in there the audio tracks you\u2019re going to play. dependencies: assets_audio_player: ^..+2 flutter: assets: - music/ . This package works with streams so we\u2019re not going to use the classic FutureBuilder<T> setup. This is the initialization of the audio player and the SVG image at the top (see the previous chapter for more details about vector images). class MusicWidget extends StatelessWidget { static final _assetsAudioPlayer = AssetsAudioPlayer(); const MusicWidget(); @override Widget build(BuildContext context) { return Column( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ // It would have been better if we used 'LayoutBuilder' Flutter Complete Reference 524",
  ". Assets, images and multimedia // to make the image responsive, but for the sake of // the example hard-coding 100 is fine. SvgPicture.asset( \"assets/music-note.svg\", height: , placeholderBuilder: (_) => const CircularProgressIndicator(), ), // Buttons and time elapsed... ], ); } } It\u2019s possible making the audio player static when the music, or the playlist, is always going to be the same. There is no need to create the object many times: thanks to static, we can de\ufb01ne a const constructor and \"cache\" the instance. . Now we\u2019re going to see how the buttons and the elapsed time indicator have been imple- mented. To better discuss the pieces of code, we\u2019ve divided them in three parts. children: <Widget>[ // Start listening IconButton( icon: const Icon(Icons.open_in_browser), onPressed: () { _assetsAudioPlayer.open(Audio(\"assets/music.mp3\")); }, ), // Time elapsed StreamBuilder<Duration>(...), // Play or pause StreamBuilder<bool>(...), ] Very simply, this button tells the player to look for \"music.mp3\" and play it. Flutter Complete Reference 525",
  ". Assets, images and multimedia . The Text widget is frequently updated by a stream containing information about how much time has passed since the audio has started. Note that asyncSnapshot.data is nullable so we need to do a null-check or any other kind of validation. children: <Widget>[ // Start listening IconButton(...), // Time elapsed StreamBuilder<Duration>( stream: _assetsAudioPlayer.currentPosition, builder: (context, asyncSnapshot) { if (asyncSnapshot.hasData) { final time = asyncSnapshot.data; if (time != null) { return Text(\"${time.inMinutes.remainder()}m \" \"${time.inSeconds.remainder()}s\"); } else { return const Text(\"No time available.\"); } } return const Text(\"0m 0s\"); } ), // Play or pause StreamBuilder<bool>(...), ] Thanks to _assetsAudioPlayer.currentPosition you can subscribe and listen for up- dates on the elapsed time, since the beginning, with the usual Duration object. We have used this condition... if (asyncSnapshot.hasData) { ... } ... to know whether there\u2019s an audio playing or not. If nothing is going on (no music is playing), we just return the \"0m 0s\" placeholder. Flutter Complete Reference 526",
  ". Assets, images and multimedia . The last part is about listening to a stream which tells us whether there is an audio playing or not. This information can be useful to swap the play/pause button according to the value of the bool \ufb02ag. children: <Widget>[ // Start listening IconButton(...), // Time elapsed StreamBuilder<Duration>(...), // Play or pause StreamBuilder<bool>( stream: _assetsAudioPlayer.isPlaying, builder: (context, AsyncSnapshot<bool> isPlaying) { if (isPlaying.data ?? false) { return IconButton( icon: const Icon(Icons.pause), onPressed: _assetsAudioPlayer.pause, ); } else { return IconButton( icon: const Icon(Icons.play_arrow), onPressed: _assetsAudioPlayer.play, ); } }, ) ] If isPlaying is true it means that the audio is currently playing so there\u2019s the need to show a button that can pause it. On the other hand, if it\u2019s false then the music is not playing and thus the play button must appear. We have used a tear-o\ufb00rather than a lambda just to reduce the amount of code: // Tear-off (which is a sort of \"method reference\") onPressed: _assetsAudioPlayer.play, // Lambda Flutter Complete Reference 527",
  ". Assets, images and multimedia onPressed: () => _assetsAudioPlayer.play(), Both versions are equivalent but tear-o\ufb00s should be preferred. Flutter Complete Reference   | Forms and gestures B Resources >",
  "> Login form .1 Forms and validation A form consists of a series of \ufb01elds (to be \ufb01lled by the user with some information) that can be processed. A typical example is a login form, in which the app generally could ask you for email and password. Once a con\ufb01rmation button in pressed, an HTTP request or another type of authentication process happens. In this section we are going to create the login form you see in the above picture and, in the following subsections, we will add more functionalities. Flutter Complete Reference 529",
  ". Forms and gestures . The two inputs and the button are positioned at the center of the screen but they take only /3 of the width of the containing widget. If the user rotates the screen for example, we still want to have the form at the center and with the same ratio in order to keep consistency. LayoutBuilder( builder: (context, dimensions) { // (a) final width = dimensions.maxWidth / .; final height = dimensions.maxHeight / ; return Center( // (b) child: SizedBox( width: width, height: height, child: LoginForm(), ), ); }, ), This is the perfect situation in which the LayoutBuilder widget has to be used because it gives the possibility to work with the actual available space. In particular: (a) writing maxWidth / .5 we can get the value of the width so that it takes /3 of the horizontal space. This is very \ufb02exible because if you rotated the screen, the widget would automatically rebuild and the ratio would remain identical; (b) we could have used a Container but since no styling or particular e\ufb00ects are needed, a class SizedBox() \ufb01ts better. Its dimensions are de\ufb01ned by responsive values cal- culated by LayoutBuilder. This is not only useful when the screen rotates but also if your app runs on a big tablet. You could also decide to implement a more complex logic for the sizes of the box but in this case we recommend you to encapsulate the calculations in a separated function: LayoutBuilder( builder: (context, dimensions) { final width = _getWidth(); // calculated width final height = _getHeight(); // calculated height } Flutter Complete Reference 530",
  ". Forms and gestures ), . The Form widget is a container for multiple form \ufb01elds such as TextFormField() which takes the user\u2019s input. In order to provide \ufb01elds validation, we need a GlobalKey<FormState> object that uniquely identi\ufb01es the form in the widget tree. class LoginForm extends StatelessWidget { final _key = GlobalKey<FormState>(); @override Widget build(BuildContext context) { return Form( key: _key, child: Column( mainAxisAlignment: MainAxisAlignment.spaceAround, children: <Widget>[...], ), ); } } . Inside the Column we\u2019re going to put a series of TextFormFields the user has to \ufb01ll. Thanks to the decoration parameter we can customize the look of the text box adding a leading icon and a hint text. There\u2019s the possibility to customize the widget even more; visit the o\ufb03cial documentation for class InputDecoration 1 to get a better overview of the various styling possibilities. // Email TextFormField( decoration: const InputDecoration( icon: Icon(Icons.mail), hintText: \"Email\" ), validator: _validateEmail, ), // Password 1https://api.\ufb02utter.dev/\ufb02utter/material/InputDecoration-class.html Flutter Complete Reference 531",
  ". Forms and gestures TextFormField( decoration: const InputDecoration( icon: Icon(Icons.vpn_key), hintText: \"Password\" ), obscureText: true, validator: _validatePassword, ), // Confirm Button RaisedButton(...) To validate the input, we pass a callback to validate which returns an error message if the string doesn\u2019t satisfy certain conditions. If there are no errors, the function must return null. String? _validateEmail(String value) { if (value.isEmpty) { return \"Field cannot be empty\"; } else { return null; } } String? _validatePassword(String value) { if (value.length < ) { return \"At least 8 chars!\"; } else { return null; } } When the \"Login\" button is tapped but at least one of the two form \ufb01elds doesn\u2019t return null, it means that there\u2019s a problem and a red error text appears below. If multiple \ufb01elds have a validator, they all must return null in order to proceed with the submission of the data otherwise the errors will appear. Flutter Complete Reference 532",
  ". Forms and gestures . The last step is the creation of the submission button which is going to check if no validator returns null (meaning that all inputs are ok). If this is the case, we can start the login logic which might be, for example, a dio HTTP request. children: <Widget>[ // Email TextFormField(...), // Password TextFormField(...), // Login RaisedButton( child: const Text(\"Login\"), onPressed: _login, ), ] The login logic should be placed in a dedicated class in order to keep the UI logic separated from the business logic as much as possible. void _login() { if (_key.currentState?.validate() ?? false) { final login = LoginClass(); // ... } else { // Show an error or something else to alert Flutter Complete Reference 533",
  ". Forms and gestures // that the input fields contain some errors } } You see now why we had to use a GlobalKey<FormState> at the beginning of the example. It\u2019s used to identify the form and check if every \ufb01eld inside is validated or not thanks to bool validate(). ..1 Keyboard and over\ufb02ows In our example the Form is at the center of the screen and there\u2019s enough vertical space so it\u2019s all good. However, when you press on a form \ufb01eld, your device\u2019s keyboard comes out reducing the available height and an over\ufb02ow error might occur if there isn\u2019t enough space anymore in the vertical axis. The problem is that the keyboard reduces the available height and so there won\u2019t be enough space anymore to entirely show the form. To \ufb01x this problem there are two possibilities, depending on how you want the form to behave. . A class SingleChildScrollView is useful when a widget is normally visible but you want to add scrolling behavior in case there weren\u2019t enough space. Basically it ensures that, in case of over\ufb02ows, scrolling is activated. This can be the case where you have an entirely visible form but when the screen rotates or the keyboard appears, some parts might get \"cut o\ufb00\". Flutter Complete Reference 534",
  ". Forms and gestures As you can see from the image, the login box moves up and still remains at the center of the remaining space. If the screen were smaller and the box didn\u2019t \ufb01t the entire height, you would be able to scroll it up and down very conveniently. No over\ufb02ow errors at all. LayoutBuilder( builder: (context, dimensions) { final width = dimensions.maxWidth / .; final height = dimensions.maxHeight / ; return Center( child: SingleChildScrollView( child: ConstrainedBox( constraints: BoxConstraints( minHeight: height, maxWidth: width, ), Flutter Complete Reference 535",
  ". Forms and gestures child: LoginForm(), ), ), ); }, ), The direct child should really be a ConstrainedBox as it imposes its children to have the sizes given by the constraints parameter. Since they are taken from a LayoutBuilder, we\u2019re sure about the responsiveness of the layout. . The other solution doesn\u2019t involve any scrolling; it simply puts the keyboard \"in front of your app\" but it covers the widgets behind it. This is not optimal in the case of a form because the user cannot see what he\u2019s typing and he\u2019d have to close the keyboard. You cannot scroll the login box up or down because there is no scroll bar. If this is what you Flutter Complete Reference 536",
  ". Forms and gestures need, go to the Scaffold containing the form and add set resizeToAvoidBottomInset: Scaffold( resizeToAvoidBottomInset: false, // add this line appBar: AppBar(...), body: MyBody(...), ) Forms aside, the solutions we\u2019ve exposed are valid for any widget with this kind of problem. When you aren\u2019t sure that the height will always be enough to show a widget entirely, consider using a SingleChildScrollView to avoid unexpected over\ufb02ow errors. ..2 Getting the text from a text \ufb01eld So far we\u2019ve only seen how to make sure the user has \ufb01lled the inputs in a proper way (data validation). The second step is learning how to get the text from the form \ufb01elds (data acqui- sition). . In a StatefulWidget, create an instance of a TextEditingController and assign it to a TextFormField. We need to convert the previous LoginForm widget into a stateful one because the controller has to be disposed. class LoginForm extends StatefulWidget { const LoginForm(); @override _LoginFormState createState() => _LoginFormState(); } class _LoginFormState extends State<LoginForm> { final emailController = TextEditingController(); final passwController = TextEditingController(); @override void dispose() { emailController.dispose(); passwController.dispose(); super.dispose(); } Flutter Complete Reference 537",
  ". Forms and gestures @override Widget build(BuildContext context) { ... } } You have to create one controller for each form \ufb01eld you want to get the text. . Assign the controller to a form \ufb01eld using the controller property. children: <Widget>[ TextFormField( controller: emailController, ... ), TextFormField( controller: passwController, ... ), RaisedButton( child: const Text(\"Login\"), onPressed: _login, ), ] . Get the current text of the \ufb01eld using the text property of the controller. void _login() { if (_key.currentState?.validate() ?? false) { final email = emailController.text; final passw = passwController.text; final login = LoginClass( user: email, password: passw, ); // ... } else { // ... Flutter Complete Reference 538",
  ". Forms and gestures } } Other than text, another very interesting property is selection 2 which lets you handle the text the user has selected. For example, if the user selected LUTT in the word FLUTTER, this code... debugPrint(\"Selection: ${myController.selection.start} - \" \"${myController.selection.end}\"); ... would print \"Selection:  - \" because the selected chars start from position 1 of the string and end at  (not inclusive). If you want to get the selected text, work with the o\ufb00sets to extract a substring. final start = myController.selection.start; final end = myController.selection.end; final selectedText = myController.text.substring(start, end); debugPrint(selectedText); // prints \"LUTT\" ..3 Constraining the input By default the user is able to type as many characters as he wants because there are no restrictions on the length. If you want to limit the length of the input, just set the maxLength property with the max char count. TextFormField( maxLength: , ... ), With this simple addition, the user is able to type up to 20 characters. A counter automatically appears on the bottom-right corner of the \ufb01eld to show how much space left there is in the \ufb01eld. 2https://api.\ufb02utter.dev/\ufb02utter/widgets/TextEditingController/selection.html Flutter Complete Reference 539",
  ". Forms and gestures The counter can be disabled setting counterText: \"\" in the InputDecorator assigned to the TextFormField. A custom text combined with a counter requires a bit more of setup but of course it\u2019s still doable: . Create a variable to hold the maximum allowed length and preferably make it static const if you know that it doesn\u2019t have to change. class _LoginFormState extends State<LoginForm> { static const maxLength = ; final emailController = TextEditingController(); } . We\u2019re going to use the text property of the controller because it immediately updates whenever a new character is added or removed in the form \ufb01eld. Thanks to this, we can still show the remaining space but with a di\ufb00erent label: TextFormField( controller: emailController, maxLength: maxLength, decoration: InputDecoration( counterText: \"Chars left: \" \"${maxLength - emailController.text.length}\", ), ), If your input \ufb01eld contains sensible data such as a password, you can constrain it to show dots instead of the actual text with obscureText: true. Lastly, we show you a possible way to im- plement a dropdown menu in which the user doesn\u2019t have the freedom to write but he\u2019s forced to pick an option from a set of prede\ufb01ned items. Flutter Complete Reference 540",
  ". Forms and gestures B Resources >",
  "> Dropdown menu . The dropdown has to rebuild whenever a new option is picked and we also need to store somewhere the selected item. All of this can easily be achieved with the classic provider + ChangeNotifier approach. class DropdownText with ChangeNotifier { static final _list = [\"Pasta\", \"Pizza\", \"Maccheroni\"] .map<DropdownMenuItem<String>>((item) { return DropdownMenuItem<String>( value: item, child: Text(item), ); }) .toList(); final menuItems = UnmodifiableListView(_list); var _text = \"\"; String get text => _text; void setText(String value) { _text = value; notifyListeners(); } } Instead of manually writing each single DropdownMenuItem<T> by hand, you can work on a private array (_list) which is easier maintain. The map() method will automatically build a list of items for the dropdown widget. . Create a ChangeNotifierProvider right above the widget that is going to have the drop- down picker. Other than rebuilding the dropdown, it will also expose the selected item via text property. ChangeNotifierProvider<DropdownText>( create: (_) => DropdownText(), child: Center( child: const SizedBox( Flutter Complete Reference 541",
  ". Forms and gestures width: , child: DropDown(), ), ), ), In a production app, instead of hard-coding the width, you should calculate it using a LayoutBuilder to get a responsive widget. . The DropdownButtonFormField<T> widget must contain a list of DropdownMenuItem<T> childred, where T is the data type the widget represents. @override Widget build(BuildContext context) { return Consumer<DropdownText>( builder: (context, dropdown, _) { return DropdownButtonFormField<String>( items: dropdown.menuItems, value: dropdown.text, onChanged: (value) => dropdown.setText(value), ); }, ); } Since we have a list of ingredients, we want them to be strings. Thanks to provider we\u2019re able to attach the list of items via items and also set the currently visible element via value. The dropdown gets automatically updated when the selected item is changed thanks to setText(value). Whenever we want to obtain the currently selected value of the dropdown picker we need to use provider and ask for dropdown.text which returns a stirng. Please keep in mind that an exception will be thrown if: \u2022 items is null or has no elements; \u2022 there are duplicates in items; \u2022 value doesn\u2019t appear somewhere in items; Flutter Complete Reference 542",
  ". Forms and gestures .2 Gestures A gesture is a semantic action (such as \"tap\", \"slide\" or \"drag\") recognized by a pointer event on the UI. In practice, with the term gesture you indicate all those actions that can be done with one or more \ufb01ngers such as tapping or sliding in a certain direction. Flutter handles gestures using the class GestureDetector which has many listeners , such as: \u2022 onTap, \u2022 onDoubleTap, \u2022 onLongPress, \u2022 onVerticalDragStart, \u2022 onVerticalDragEnd \u2022 and much more... A GestureDetector is very useful because it can make any widget \"clickable\". For example, an image has no onPressed event by default (or similar) but you can assign it one or more gestures: GestureDetector( onTap: () => debugPrint(\"Click!\"), onDoubleTap: () => debugPrint(\"Double click!\"), child: Image.asset(\"...\"), ) In this way a lot of widgets gain the possibility to interact with the user in many di\ufb00erent ways. Nevertheless, keep in mind that Flutter also has dedicated widgets for single tap events that should be preferred. For instance: \u2022 DO use the class IconButton if you want to make an icon clickable because there already is a tap handler (the onPressed callback). // OK IconButton( icon: const Icon(Icons.add), onPressed: () {} ) 3https://\ufb02utter.dev/docs/development/ui/advanced/gestures#gestures Flutter Complete Reference 543",
  ". Forms and gestures \u2022 DO NOT use a GestureDetector if you want to make an icon clickable. There already is a dedicated widget made by the Flutter team. // It works but it's not a good idea; prefer using an 'IconButton' GestureDetector( onTap: () {}, child: const Icon(Icons.add), ) When you want to implement a gesture for a widget, whether it be a tap, a swipe or anything else, \ufb01rst try to see if there\u2019s something already crafted in the material or cupertino library. If it\u2019s not the case then you can start working on your own gesture management using a GestureDetector. B Resources >",
  "> Swipe to dismiss ..1 Swipe to dismiss When there\u2019s an item of a list that needs to be deleted, rather than clicking on a button the user can swipe to the left/right to remove it. This is a common UI pattern known as \"swipe to dismiss\" and we\u2019re going to implement it in Flutter: Given a list of widgets, when you swipe an item to the right it gets deleted. Later on we will also implement a deletion con\ufb01rmation dialog. Flutter Complete Reference 544",
  ". Forms and gestures . Since the list is potentially going to remove elements, we need to manage the state of the widget. We\u2019re using the usual model class with ChangeNotifier so that a provider can listen for changes. class SourceList with ChangeNotifier { final _myList = List<String>.generate(, (i) { return \"Number $i\"; }); List<String> get values => UnmodifiableListView(_myList); void removeItem(int index) { _myList.removeAt(index); notifyListeners(); } } Rather than returning the list itself, we return an unmodi\ufb01able view of the list to ensure that the only way to delete items is via removeItem(int). This is compulsory because the method contains a call to notifyListeners() while removeAt() alone doesn\u2019t. . Now we need to setup the provider making sure it\u2019s placed exactly one level above the widget with the list. In this way the scope doesn\u2019t get polluted and all those widgets that don\u2019t care about the list aren\u2019t involved. ChangeNotifierProvider( create: (_) => SourceList(), child: const SwipeItems(), ), As always, we need a Consumer<T> to retrieve the value held by provider which is, in this case, a list of strings. class SwipeItems extends StatelessWidget { const SwipeItems(); @override Widget build(BuildContext context) { return Consumer<SourceList>( builder: (context, list, _) { return ListView.builder(...) Flutter Complete Reference 545",
  ". Forms and gestures }, ); } } . For long lists, the builder() 4 constructor of ListView is very convenient as it automat- ically generates the children. The \"swipe to dismiss\" pattern is implemented with the Dismissible widget. return ListView.builder( itemCount: list.values.length, itemBuilder: (context, index) { var item = list.values[index]; return Dismissible( // a. key: Key(item), // b. background: Container(color: Colors.redAccent), // c. onDismissed: (direction) => list.removeItem(index), direction: DismissDirection.startToEnd, child: ListTile( leading: const Icon(Icons.trending_flat), title: Text(item), ), ); }, ); By default, each item of the list can be swiped to the left or to the right; thanks to direction we\u2019ve forces that the only allowed action to delete is \"swipe to the right\". Of course you can change it to whatever you want because DismissDirection provides many directions. (a) The Key is fundamental because it uniquely identi\ufb01es an item of the list and it\u2019s internally used by Dismissible. Be sure to create the key with an unique value for each item, otherwise you\u2019ll incur an error. 4https://api.\ufb02utter.dev/\ufb02utter/widgets/ListView/ListView.builder.html Flutter Complete Reference 546",
  ". Forms and gestures (b) This is the background widget that will appear while the item is being moved to the right. Of course it doesn\u2019t always have to be a Container: any widget is \ufb01ne. (c) This callback is triggered when the swiping action is \ufb01nished, which is when the user\u2019s \ufb01nger leaves the screen and the item has completely slided to the right. The element will be removed and the noti\ufb01er will rebuild the list immediately. As you can see, the Dismissible widget makes the implementation of the \"swipe to dismiss\" pattern very easy. It also o\ufb00ers the possibility to con\ufb01rm a pending deletion by setting the confirmDismiss callback. One of the best con\ufb01rmation widgets is AlertDialog, from the material library, and we\u2019re going to use it to obtain the above result. Basically it informs the user about situations where an action from his part is needed. . Let\u2019s start by de\ufb01ning a callback to be attached to the confirmDismiss parameter. When set, it waits for a Future<T> to return either true or false to decide if the swiped item has to be deleted or not. Dismissible( confirmDismiss: (direction) => _getConfirm(context, direction), ... ) . Create the Future<bool> _getConfirm(...) method and use showDialog() inside it to actually show a dialog on the UI. Future<bool> _getConfirm(BuildContext context, DismissDirection direction) { return showDialog<bool>( Flutter Complete Reference 547",
  ". Forms and gestures context: context, builder: (BuildContext context) { return AlertDialog( title: const Text(\"Confirm\"), content: const Text(\"Delete this item?\"), actions: <Widget>[ RaisedButton( child: const Text(\"Nope\"), onPressed: () => Navigator.of(context)?.pop(false), ), FlatButton( child: const Text(\"Yes\"), onPressed: () => Navigator.of(context)?.pop(true), ), ] ); }, ); } The showDialog<bool>() method returns a Future<bool> whose computed value is the argument of the pop() function. In fact, for example when you press on \"Yes\" the true value of the pop(true) call is \"captured\" by the dialog and returned. B Resources >",
  "> Drag and drop ..2 Dragging items In this section we\u2019re going to see how easy it is to implement the \"drag and drop\" functionality in Flutter by creating the skeleton of a simple game. Basically a random number appears at the center of the screen and you have to move it to the left or to the right whether it\u2019s even or odd. Flutter Complete Reference 548",
  ". Forms and gestures If you move a number in the correct box, you get points. You could try to use our example as a starting point and then add more functionalities such as a timer, a scoreboard or a more complex point management system. . The logic of the game has to be encapsulated in a dedicated class or in a well-designed hierarchy if you plan to make it more complex. In our case, we just need to handle the total amount of gained points and the generation of new values. class GameScore with ChangeNotifier { var _score = ; var _currentValue = _random(); int get score => _score; int get currentValue => _currentValue; static int _random() => Random().nextInt() + ; void addPoints(int pts) { _score += pts; Flutter Complete Reference 549",
  ". Forms and gestures _currentValue = _random(); notifyListeners(); } } While _score keeps track of the total points earned, _currentValue holds the current number that has to be dragged in the \"Even\" or \"Odd\" container of the UI. . Now we\u2019re creating the widget for the game itself. We\u2019ve removed some styling widgets such as Padding and TextStyle to focus on the important ones; you\u2019ll \ufb01nd the complete code in the online resources. // This is inside a stateless widget called \"DragWidget\" Column( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ // The blue total score at the top Consumer<GameScore>( builder: (context, game, _) { return Text(\"Total: ${game.score}\"); }, ), // The two boxes and the random number at the center Row( mainAxisAlignment: MainAxisAlignment.spaceAround, children: const <Widget>[ EvenContainer(), NumberContainer(), OddContainer(), ], ), ] ), This is the content of class DragWidget, the \"container\" of the game. At the top there is a Consumer<GameScore> that listens to score updates and refreshes the text; below there is the draggable number and the two target boxes. Flutter Complete Reference 550",
  ". Forms and gestures . With the Draggable<T> widget you\u2019re able to drag and move around any widget. It has the data property which represents the type of value (T) it\u2019s holding. In our case we\u2019re dealing with an int. class NumberContainer extends StatelessWidget { const NumberContainer(); @override Widget build(BuildContext context) { return Consumer<GameScore>( builder: (context, game, _) { return Draggable<int>( data: game.currentValue, feedback: ... child: ... ); }, ); } } The game.currentValue variable is the random number appearing at the center of the screen and it has to be linked to the data property. In this way, when the widget will be freely dragged around the screen it will also carry the int value (the even/odd number). Draggable<int>( data: game.currentValue, feedback: Container( width: , height: , decoration: BoxDecoration( borderRadius: BorderRadius.circular(), color: Colors.black26, ), child: Center( child: Text(\"${game.currentValue}\"), ), ), child: Container( Flutter Complete Reference 551",
  ". Forms and gestures width: , height: , child: Center( child: Text(\"${game.currentValue}\"), ), ), ); The child widget usually displays the data that the Draggable is holding and feedback is how the item should look while it\u2019s being dragged. As you can see, while the number is being dragged there\u2019s a circular transparent container around represented by the feedback property. It\u2019s been styled with a Container. . Since we want to show a snackbar at the bottom of the screen every time the user scored new points, we\u2019re creating a mixin to share the implementation across multiple widgets. mixin SnackMessage { void showMessage(BuildContext context, String text) { Scaffold.of(context).showSnackBar( SnackBar( Flutter Complete Reference 552",
  ". Forms and gestures content: Text(text), duration: const Duration(milliseconds: ), ) ); } } The EvenContainer and OddContainer widgets are going to be the landing zones of the dragged item, depending if it\u2019s respectively an even or an odd number. The _willAccept method determines whether the received item is valid or not. class EvenContainer extends StatelessWidget with SnackMessage { const EvenContainer(); @override Widget build(BuildContext context) { return Container( width: , height: , decoration: BoxDecoration( borderRadius: BorderRadius.circular(), color: Colors.blueAccent, ), child: DragTarget<int>(...), ); } void _onAccept(BuildContext context, int data) { context.read<GameScore>().addPoints(data); showMessage(context, \"Points: + $data\"); } bool _willAccept(int? data) => data != null && data %  == ; } A Draggable<T> widget can land only in a DragTarget<T> widget of the same type. In our speci\ufb01c case we can release a Draggable<int> only inside a DragTarget<int> widget, and our UI contains two of them. Container( Flutter Complete Reference 553",
  ". Forms and gestures ... child: DragTarget<int>( onAccept: (data) => _onAccept(context, data), onWillAccept: _willAccept, builder: (context, _, __) { return const Rectangle(text: \"Even\"); }, ), ), Very intuitively, the builder method returns the widget that will be displayed in the UI, which is in our case a blue rectangle with a white text. The Rectangle class is a custom widget we\u2019ve made for reusability. \u2022 onWillAccept: the callback is used to determine if this widget is interested in accept- ing a piece of data being dragged over this target. In practice, it checks if we\u2019re trying to put in here a Draggable whose value is an even number. \u2022 onAccept: if a dropped piece has been accepted because onWillAccept returned true, this method is called. In other words, when we\u2019re sure that the user dropped an even number, we can give him the points and show the snack bar. The OddContainer widget is very similar; it just changes some styling and the onWillAccept callback evaluates to true only if the number is odd. Note that instead of context.read<GameScore>() we could have used the non-extension version, remembering to set listen: false because the call is made outside of the widget tree. // Equivalent to calling 'context.read<GameScore>()' Provider.of<GameScore>(context, listen: false).addPoints(data); Flutter Complete Reference   | Interacting with the device B Resources >",
  "> Taking photos .1 Taking a picture It wouldn\u2019t be a surprise if you were asked to take a photo with your app and eventually store the image \ufb01le you\u2019ve acquired. The o\ufb03cial camera 1 package allows you to work with any camera of your device, display previews and acquire photos. 1https://pub.dev/packages/camera Flutter Complete Reference 555",
  ". Interacting with the device The app we\u2019re going to build shows a live preview of what\u2019s going to be captured and an icon at the bottom which stores the picture in the temporary directory. There are some packages you need to import: \u2022 camera, to work with the cameras of the device; \u2022 path_provider, to easily \ufb01nd folders\u2019 paths; \u2022 path, to easily get paths on any platform. Please note that in order to successfully compile the camera plugin you have to change the minimum Android sdk version to 21 at app/build.gradle. Look for the minSdkVersion label and set it to be  (the default value might be lower, such as ). For iOS users instead add two new entries in ios/Runner/Info.plist \u2022 Privacy - Camera Usage Description \u2022 Privacy - Microphone Usage Description Associate to each key a meaningful description that will be prompted to the user. At this point the setup is ready and we can start creating the app. . In the initialization phase, we need to retrieve the list of all available cameras of the device by using availableCameras(). Generally there are two, one at the front and one at the back. void main() async { // This call makes sure the camera plugin has been // properly initialized and it's ready to be used. WidgetsFlutterBinding.ensureInitialized(); final cameras = await availableCameras(); final firstCamera = cameras.first; runApp(...); } The cameras variable is of type List<CameraDescription> so calling cameras.first is equivalent to writing cameras[]. . In order to establish a connection with the device\u2019s camera you need a CameraController and, like any other controller, it has to be initialized and disposed. For this reason, create a StatefulWidget which will take care of the controller\u2019s lifecycle. Flutter Complete Reference 556",
  ". Interacting with the device class TakePicture extends StatefulWidget { final CameraDescription camera; TakePicture({required this.camera}); @override _TakePictureState createState() => _TakePictureState(); } class _TakePictureState extends State<TakePicture> { late final CameraController _controller; late final Future<void> _initController; @override void initState() { super.initState(); _controller = CameraController( widget.camera, ResolutionPreset.high, ); _initController = _controller.initialize(); } @override void dispose() { _controller.dispose(); super.dispose(); } // build... } You\u2019ll see that _initController is used in a FutureBuilder<T> to wait for the loading of the camera preview screen. You can decide to take high or low quality pictures with one of these controller\u2019s constants: \u2022 ResolutionPreset.low (240p), \u2022 ResolutionPreset.medium (480p), Flutter Complete Reference 557",
  ". Interacting with the device \u2022 ResolutionPreset.high (720p), \u2022 ResolutionPreset.veryHigh (1080p), \u2022 ResolutionPreset.ultraHigh (2160p) Alternatively, if you don\u2019t know which is the maximum resolution supported by the device, you can use ResolutionPreset.max which automatically picks the highest preset possible. For the sake of the example we\u2019ve simply used a Column but you could try to make a more complex layout. @override Widget build(BuildContext context) { return Column( mainAxisAlignment: MainAxisAlignment.spaceAround, children: <Widget>[ FutureBuilder<void>(...), IconButton(...) ], ); } . The FutureBuilder<void> widget is going to await for the initialization of the camera because, as soon as it\u2019s ready, we want it to give a live preview of what it\u2019s framing. FutureBuilder<void>( future: _initController, builder: (context, snapshot) { if (snapshot.connectionState == ConnectionState.done) { return Expanded( child: Center( child: AspectRatio( aspectRatio: _controller.value.aspectRatio, child: CameraPreview(_controller), ), ), ); } return const Center( Flutter Complete Reference 558",
  ". Interacting with the device child: CircularProgressIndicator(), ); }, ), We recommend the usage of the AspectRatio widget as it shows the preview with proper proportions between width and height. It\u2019s not compulsory, you could have put the CameraPreview widget directly inside Expanded and it would have covered the entire avail- able space. return Expanded( child: CameraPreview(_controller), ) Since we\u2019re inside a Column we need somehow to constrain the height and Expanded does exactly this. Alternatively you could have used a Container or a SizedBox. . In the FutureBuilder<void> we\u2019ve placed the button to actually take the photo and store the image in the temporary directory with a \"random\" \ufb01lename. IconButton( icon: const Icon(Icons.photo_camera), onPressed: () => _takePhoto(context), ) We underline again the fact that it\u2019s a good idea putting the business logic outside of the UI logic and thus the body of the onPressed callback has been created in a separated function. void _takePhoto(BuildContext context) async { // Ensure the controller is ready await _initController; // File name and path final dir = await getTemporaryDirectory(); final name = \"mypic_${DateTime.now()}.png\"; // Store the picture at the given location final fullPath = path.join(dir.path, name); await _controller.takePicture(fullPath); Scaffold.of(context).showSnackBar( Flutter Complete Reference 559",
  ". Interacting with the device SnackBar( content: const Text(\"Picture taken!\"), duration: const Duration(milliseconds: ), ) ); } A common strategy to avoid \ufb01le name con\ufb02icts is relying on the current date and time in the name. While this approach is not bullet proof, for simple tasks it\u2019s good enough. Note the usage of join: final fullPath = path.join(dir.path, name); Combining paths in cross-platform apps is not easy because you have to take into account the \ufb01lesystem structure of every single supported OS. This is something low-level that you don\u2019t want to deal with, so Flutter has a package ready for you and it\u2019s called path! B Resources >",
  "> Sensors .2 Working with sensors Nowadays almost any device has built-in sensors to measure orientation, motion or other environ- mental conditions with a very high accuracy. To monitor the three-dimensional data the device is able to provide you can use the o\ufb03cial sensor 2 package. \u2022 GyroscopeEvents: data about the rotation of the device; \u2022 AccelerometerEvent: these data let you know in which direction the device is moving, keeping into account the gravity; \u2022 UserAccelerometerEvent: similar to AccelerometerEvent but it doesn\u2019t care about the gravity We\u2019re creating a very basic app that shows data obtained from the sensors at the center of the screen. They are useful when you want to implement motion-based functionalities in your app. 2https://pub.dev/packages/sensors Flutter Complete Reference 560",
  ". Interacting with the device The API of the sensor package is very simple to use and it relies on streams. . The Wrap widget places the children side by side in the horizontal or vertical direction. It\u2019s very similar to Row and Column but with the di\ufb00erence that its sizes are constrained: when there is no more space to lay out the children, it wraps to the next column/row. class SensorWidget extends StatelessWidget { const SensorWidget(); @override Widget build(BuildContext context) { return Wrap( spacing: ., direction: Axis.vertical, children: const <Widget>[ AccelerometerData(), UserAccelerometerData(), GyroscopeData() ], ); } } Flutter Complete Reference 561",
  ". Interacting with the device Here we\u2019re placing a series of widgets vertically with a certain space in between. If you try to rotate the screen and set a big gap, such as spacing: , you\u2019ll see that widgets are rearranged di\ufb00erently and no over\ufb02ow errors appear. . As you know, the StreamBuilder<T> widget deals with streams and we strongly recommend you to always supply some initial data to it. This ensures that the \ufb01rst frame will show useful data rather than null, which is safe. class AccelerometerData extends StatelessWidget { static final initialData = AccelerometerEvent(, , ); const AccelerometerData(); @override Widget build(BuildContext context) { return StreamBuilder<AccelerometerEvent>( stream: accelerometerEvents, initialData: initialData, builder: (context, accel) { final data = accel.data; if (data != null) { final x = data.x.toStringAsFixed(); final y = data.y.toStringAsFixed(); final z = data.z.toStringAsFixed(); return ChipWithIcon( icon: Icon(Icons.drive_eta), text: \"Accelerometer: $x, $y, $z\" ); } return const Text(\"No data to display.\"); }, ); } } The accelerometerEvents stream is provided by the sensor package and it continuously sends a series of three-dimensional data we\u2019re showing on the UI. At the center of the screen Flutter Complete Reference 562",
  ". Interacting with the device there\u2019s a material Chip, a rounded box representing short spans of text. class ChipWithIcon extends StatelessWidget { final Icon icon; final String text; const ChipWithIcon({ required this.icon, required this.text }); @override Widget build(BuildContext context) { return Chip( avatar: icon, padding: const EdgeInsets.fromLTRB(, , , ), labelPadding: const EdgeInsets.only(left: ), label: Text(text), ); } } We haven\u2019t discussed the implementations of the other two listeners because they\u2019re basically identical to AccelerometerData with the only di\ufb00erence that they subscribe to a di\ufb00erent stream. B Resources >",
  "> Geolocation .3 Working with Geolocation A very popular geolocation package for Flutter is geolocator , well-known for its easy way to access the device\u2019s location services. Before starting with the examples, apply the following changes to your project: \u2022 On Android you need to add two permissions in the manifest at android/app/src/main. <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /> 3https://pub.dev/packages/geolocator Flutter Complete Reference 563",
  ". Interacting with the device <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /> In addition, make sure the gradle.properties \ufb01le has AndroidX enabled by checking if these two lines are present. They are required for version ..0 and above of the plugin to work. android.useAndroidX=true android.enableJetifier=true \u2022 On iOS you have to setup the permission in the Info.plist \ufb01le. <key>NSLocationWhenInUseUsageDescription</key> <string>Give me location permissions pls</string> Note that in early versions you had to access members using class Geolocator which im- plemented the singleton design pattern via factory constructor. Now the class doesn\u2019t exist anymore: the package just exposes a series of top-level functions. var position = await getCurrentPosition( desiredAccuracy: LocationAccuracy.high ); var lat = position.latitude; var lon = position.longitude; var alt = position.altitude; You could also use position.speed to indicate the speed at which the device is moving but it\u2019s not always available. There\u2019s also the possibility to listen for position changes thanks to getPositionStream() which returns a Stream<Position>. Flutter Complete Reference 564",
  ". Interacting with the device In this very simple example we have an SVG image at the top and below there is a string reporting the current latitude and longitude. If we went out for a walk, we would see the text automatically updating to re\ufb02ect the new coordinates thanks to the stream. . The setup for the GPSWidget is very easy to understand. We have decided to make the _stream variable static to be able to declare a const constructor. class GPSWidget extends StatelessWidget { static final _stream = getPositionStream(); const GPSWidget(); @override Widget build(BuildContext context) { ... } } . As usual, we\u2019re going to use the StreamBuilder<T> widget to subscribe to the stream and constantly update the text below the image. return Wrap( spacing: , direction: Axis.vertical, crossAxisAlignment: WrapCrossAlignment.center, children: <Widget>[ Flutter Complete Reference 565",
  ". Interacting with the device SvgPicture.asset( \"assets/geolocate.svg\", height: , ), StreamBuilder<Position>( stream: _stream, builder: (context, positionData) { if (positionData.hasData) { final data = positionData.data; if (data != null) { final lat = data.latitude.toStringAsFixed(); final lon = data.longitude.toStringAsFixed(); return Text(\"$lat | $lon\"); } else { return const Text(\"No data available.\"); } } return const CircularProgressIndicator(); }, ) ], ); Alternatively to Wrap you could have achieved the same result with a column but it would have required more boilerplate code. It has no spacing property so you\u2019d have to deal with Padding or another \"spacer\" widget. // A 'SizedBox' can be good to add spaces between widgets const SizedBox( height:  ); If you wish to calculate the distance between two points in the world, use distanceBetween() and pass latitude and longitude of the starting and ending point. The distance is expressed in meters. Flutter Complete Reference 566",
  ". Interacting with the device final double distance = await distanceBetween( ., ., // starting point lat-long ., . // ending point lat-long ); Another very interesting package is called geocoding because it gives you the possibility to trans- late latitude/longitude coordinates into an address and vice versa. It\u2019s very easy to use: final placemarks = await placemarkFromCoordinates(., .); if (placemarks.isNotEmpty) { final result = placemarks[]; debugPrint(\"${result.administrativeArea}\"); // Lazio debugPrint(\"${result.locality}\"); // Rome debugPrint(\"${result.country}\"); // Italy } Ideally the placemarks list will contain only 1 item that exactly matches what you\u2019re looking for but in certain cases there might be multiple results. It\u2019s of type List<Placemark> and it has a ton of properties  (in addition to the ones we\u2019ve used above). var locations = await locationFromAddress(\"Rome\"); if (locations.isNotEmpty) { var result = locations[]; debugPrint(\"${result.latitude}\"); // .... debugPrint(\"${result.longitude}\"); // .... } This is very similar to the previous example but instead of passing the latitude and the longitude, we pass the name of the desired location. .4 Platform-speci\ufb01c packages Flutter\u2019s o\ufb03cial pub 5 page has many packages to interact with some platform-speci\ufb01c APIs. Be sure to also have a look at the GitHub repo 6 for a summary table that redirects you to the install page of the packages. 4https://pub.dev/packages/geocoding 5https://pub.dev/\ufb02utter/packages 6https://github.com/\ufb02utter/plugins Flutter Complete Reference 567",
  ". Interacting with the device ..1 Battery level The battery package lets you extract various information about your device\u2019s battery such as the current charge level. Once it\u2019s been imported you just need to create an instance of class Battery and then use its asynchronous API. Future<int> level() async { var b = Battery(); return await b.batteryLevel; } If you wanted your device to listen for battery changes, subscribe to the onBatteryStateChanged stream which exposes a BatteryState. It is an enum representing the current state of the battery. enum BatteryState { /// The battery is completely full of energy. full, /// The battery is currently storing energy. charging, /// The battery is currently losing energy. discharging } ..2 Device info To get a lot of info about the device in which your app is running you can use the device_info 7 package from the o\ufb03cial Flutter team. It\u2019s just a matter of instantiating DeviceInfoPlugin() and then using the getters. final deviceInfo = await DeviceInfoPlugin().androidInfo; //final deviceInfo = await DeviceInfoPlugin().iosInfo; debugPrint(deviceInfo.display); debugPrint(deviceInfo.brand); debugPrint(deviceInfo.product); 7https://pub.dev/packages/device_info Flutter Complete Reference 568",
  ". Interacting with the device debugPrint(deviceInfo.manufacturer); // and much more... There is a very long series of data this package is able to extract so be sure to check out the documentation. B Resources >",
  "> Connectivity ..3 Internet connectivity So far we\u2019ve used dio and http to make HTTP requests, download/upload \ufb01les and handle po- tential errors. They\u2019re not able to detect the connection status before making the actual request but the connectivity 8 package can. var status = await Connectivity().checkConnectivity(); switch (status) { case ConnectivityResult.wifi: debugPrint(\"Connected via wifi\"); break; case ConnectivityResult.mobile: debugPrint(\"Connected via mobile\"); break; case ConnectivityResult.none: debugPrint(\"not connected\"); break; } The checkConnectivity() method returns enum ConnectivityResult which lets us know if we are re connected to a network (via wi\ufb01or mobile) or not. In addition, we can also listen to connectivity changes while the app is running thanks to streams. 8https://pub.dev/packages/connectivity Flutter Complete Reference 569",
  ". Interacting with the device Thanks to a StreamBuilder<ConnectivityResult> we are able to listen to changes and show proper widgets accordingly. You\u2019ve seen this pattern many times up to now so it should be easy to understand. . The Connectivity class implements the singleton pattern so it will always return the same instance via factory constructor. For this reason, we can \"cache\" an instance in a static variable to de\ufb01ne a constant constructor. class ConnectionWidget extends StatelessWidget { static final _conn = Connectivity(); const ConnectionWidget(); @override Widget build(BuildContext context) { ... } } . For each connection type (wi\ufb01, mobile or none) we\u2019re creating the widget representing the status with an icon and the text. class WifiConnectionWidget extends StatelessWidget { const WifiConnectionWidget(); @override Widget build(BuildContext context) { return Wrap( spacing: , crossAxisAlignment: WrapCrossAlignment.center, direction: Axis.vertical, children: const <Widget>[ Flutter Complete Reference 570",
  ". Interacting with the device Icon(Icons.wifi), Text(\"Connected to WiFi\") ], ); } } class MobileConnectionWidget extends StatelessWidget { ... } class NoConnectionWidget extends StatelessWidget { ... } . At this point we can setup the StreamBuilder<ConnectivityResult> so that it can listen to connectivity changes and display the proper widget. A result of type none indicates that there\u2019s no internet connectivity at all. @override Widget build(BuildContext context) { return StreamBuilder<ConnectivityResult>( stream: _conn.onConnectivityChanged, builder: (context, status) { if (status.hasData) { final data = status.data; if (data != null) { switch (data) { case ConnectivityResult.wifi: return const WifiConnectionWidget(); case ConnectivityResult.mobile: return const MobileConnectionWidget(); case ConnectivityResult.none: return const NoConnectionWidget(); } } else { debugPrint(\"Whoops\"); } } return const CircularProgressIndicator(); }, Flutter Complete Reference 571",
  ". Interacting with the device ); } ..4 Shared preferences The shared_preferences 9 package is very useful when you have a small collection of key-value data to save. Those data persist on the disk so even if you close the app, they will be available again at the next startup. Some scenarios in which you could use them are: \u2022 storing some \ufb02ags you app has to read at startup, such as styling con\ufb01gurations set by the user; \u2022 storing some app\u2019s preferences such as the currently selected download directory; \u2022 storing all those \"small\" data like numbers or strings you want to quickly read without having to setup a database. Use class SharedPreferences when you want to work with int, double, String or bool. If you have a lot of con\ufb01gurations to store or a complex data structure, consider using a more reliable data structure such as a database . final prefs = await SharedPreferences.getInstance(); // Store a value await prefs.setInt('age', ); // Read a value var value = prefs.getInt('age') ?? -; If age wasn\u2019t an integer an exception would occur. Do not store critical data using shared preferences nor rely on them to build you app\u2019s storage; they are just a simple way to store small data without having the overhead of managing a database. SharedPreferences.setMockInitialValues({ \"name\": \"Robert\", \"age\":  }); Use setMockInitialValues() in your tests to manually populate SharedPreferences with some initial values. 9https://pub.dev/packages/shared_preferences 10See appendix B.2 Flutter Complete Reference   | Widgets showcase In this section we\u2019re going to list a series of well known widgets that follow the \"Material\" or \"Cupertino\" design styles. A complete and updated list of any widget made by the Flutter team is available in their o\ufb03cial online catalog . .1 Material \u2022 Reference: https://material.io ..1 Drawer A navigation drawer is a panel that slides from a side to the center of the screen and contains a series of options. The material implementation of a drawer, called Drawer, is generally declared inside a Scaffold because they nicely integrate together. 1https://\ufb02utter.dev/docs/development/ui/widgets Flutter Complete Reference 573",
  ". Widgets showcase A drawer generally is made up of a header (with an image or some user data) and then a series of clickable options below. In general, when an item is tapped the user navigates to another route. A drawer is very useful when there are a lot of possible routes but there isn\u2019t enough space in the UI to show them all. . By default, a drawer can slide from the left side of the screen to the center hovering the current view. Even if it\u2019s not required, you should always use a ListView as child in order to enable scrolling in case the vertical space weren\u2019t enough. Scaffold( appBar: AppBar(), body: const MyPage, drawer: Drawer( child: ListView( children: [...] ), ) ), The Scaffold automatically adds an hamburger icon in the top bar so that the drawer can also be opened by tapping on that button. There\u2019s also the possibility to add endDrawer: Drawer(...) which is simply a drawer sliding from the opposite side: from the right of the device to the center. . In general it\u2019s a good idea having a drawer in a dedicated widget, so you should create a stateless widget (called for example class DrawerMenu) and put all the logic there. Use a Flutter Complete Reference 574",
  ". Widgets showcase ListView to group the children. class DrawerMenu extends StatelessWidget { const DrawerMenu(); @override Widget build(BuildContext context) { return ListView( children: [...], ); } } . If you want to create a header section in your drawer, Flutter has the DrawerHeader class. It\u2019s very customizable but of course, if it doesn\u2019t \ufb01t your needs, you can always create a completely new widget from scratch. ListView( children: [ DrawerHeader( padding: EdgeInsets.all(), child: Wrap( direction: Axis.vertical, children: const <Widget>[ Icon(Icons.person), Text(\"myemail@gmail.com\") ], ), ) ], ) We\u2019re going to show how to create items of a navigation drawer with a very Android-like imple- mentation. Tapping on each item opens a new route because generally it\u2019s the expected behavior from a drawer item. Flutter Complete Reference 575",
  ". Widgets showcase By convention, drawer items are represented by class ListTile which shows an icon and a short piece of text. You can also visually group tiles using a Divider and maybe give a name to the group with a Text widget. ListView( children: [ ListTile( leading: const Icon(Icons.email), title: const Text(\"My e-mail\"), onTap: () => Navigator.of(context)?.pushNamed(...), ), const Divider( height: , color: Colors.grey, ), const DrawerTitle(\"App management\"), ListTile( leading: const Icon(Icons.settings), title: const Text(\"Settings\"), onTap: () => Navigator.of(context)?.pushNamed(), ), ListTile( leading: const Icon(Icons.info), title: const Text(\"Info\"), Flutter Complete Reference 576",
  ". Widgets showcase onTap: () => Navigator.of(context)?.pushNamed(), ), const Divider( height: , color: Colors.grey, ), ], ); Since there might be more than a single section title in your drawer, we\u2019ve decided to create a simple reusable DrawerTitle widget that styles some text. Note that a Divider can also have a custom thickness and color. class DrawerTitle extends StatelessWidget { final String text; const DrawerTitle(this.text); @override Widget build(BuildContext context) { return Padding( padding: const EdgeInsets.fromLTRB(, , , ), child: const Text(\"App management\", style: TextStyle( fontSize: , fontWeight: FontWeight.w500 ), ), ); } } ..2 BottomNavigationBar This material widget is displayed at the bottom of the screen and it\u2019s generally used to navigate among a small amount of pages. There are no restrictions on the maximum icon number but you shouldn\u2019t use more than 4 items otherwise the bar becomes too dense. Flutter Complete Reference 577",
  ". Widgets showcase The selected icon is highlighted with a custom color. You could also decide to only show the text or only the image. To create this kind of navigation bar, you need again a Scaffold, the basic building block of any material app, and then a BottomNavigationBar. Scaffold( appBar: AppBar(...), body: const MyPage(), bottomNavigationBar: BottomNavigationBar( currentIndex: , selectedItemColor: Colors.orange, onTap: (int index) {...}, items: const [ BottomNavigationBarItem( icon: Icon(Icons.home), label: \"Home page\" ), BottomNavigationBarItem( icon: Icon(Icons.email), label: \"E-mail\", ), ], ), ) The currentIndex parameter indicates which icon at the bottom has been tapped and thus selected. onTap is a callback for any children in items and it should act on the currentIndex property. In the above example we have hard coded it but in reality your code would look like this: Flutter Complete Reference 578",
  ". Widgets showcase bottomNavigationBar: BottomNavigationBar( currentIndex: selectedIndex, onTap: (int index) => _changePage(index), items: const [...], ), Using provider or \ufb02utter_bloc you can make it so that int selectedIndex = 0 is declared somewhere and then, using void _changePage(int index), you change the value to rebuild the Scaffold. In other words, changing the value of currentIndex also changes the currently visible page. ..3 NavigationRail A class NavigationRail 2 is basically a BottomNavigationBar that appears on the left or right of the screen (rather than at the bottom). It\u2019s generally used to navigate among a small group of routes, typically four or at maximum \ufb01ve. Scaffold( body: Row( children: <Widget>[ // Contains the circles NavigationRail( selectedIndex: currentPage, onDestinationSelected: (int index) {...}, destinations: const [ NavigationRailDestination( icon: Icon(Icons.account_circle), label: Text('User'), ), NavigationRailDestination( icon: Icon(Icons.book), label: Text('Favorites'), ), ] ), const VerticalDivider( thickness: , 2https://api.\ufb02utter.dev/\ufb02utter/material/NavigationRail-class.html Flutter Complete Reference 579",
  ". Widgets showcase width:  ), // Actual content of the page Expanded( child: Center( child: Text('selectedIndex: $currentPage'), ), ), ] ), ); The int currentPage variable should be handled by a state management library as it indicates which page is currently visible. Changing the value of currentPage, which has to happen inside the onDestinationSelected callback, also changes the selected item in destinations. The tappable circles are represented by class NavigationRailDestination where the only required parameter is the icon. If you want the navigation rail to be at the right of the screen, just puy it as last child of the Row(): Row( children: <Widget>[ Expanded(...), const VerticalDivider(...), NavigationRail(...), ] ); Flutter Complete Reference 580",
  ". Widgets showcase There\u2019s also the possibility to change the icon of a selected element by setting the selectedIcon property. For example: NavigationRailDestination( icon: Icon(Icons.info_outline), selectedIcon: Icon(Icons.info), ), By default the Icons.info_outline icon appears but when the destination is tapped, it\u2019s re- placed by a Icons.info. ..4 TabBar Working with tabs in Flutter is very easy because it\u2019s just a matter of using a controller and a Scaffold; on Android instead there would be a lot of styling and coding to do. A tabbed layout is used to group multiple pages in a single view: the user can move among tabs by swiping or by tapping on the top bar. Similarly from what we\u2019ve suggested for a BottomNavigationBar, you should display three or at maximum four tabs in the page. There aren\u2019t any limitations but if you have too many icons the bar becomes too dense and not optimal in terms of user experience (which is essential). DefaultTabController( length: , child: Scaffold( appBar: AppBar( Flutter Complete Reference 581",
  ". Widgets showcase title: const Text(\"Using tabs\"), bottom: const TabBar( tabs: [ Tab( icon: Icon(Icons.vpn_key), text: \"Passwords\", ), Tab( icon: Icon(Icons.history), text: \"History\", ), ], ), ), body: const TabBarView( children: [ PageOne(), PageTwo(), ], ), ), ), There\u2019s the need to use a DefaultTabController widget to make everything work and the length parameter must re\ufb02ect the actual number of tabs, otherwise an exception is thrown. The TabBar widget handles the tabs in the top bar, TabBarView instead handles the body of the tabs (the actual pages). class PageOne extends StatelessWidget { const PageOne(); ... } class PageTwo extends StatelessWidget { const PageTwo(); ... } Be sure to create the children of a TabBarView into separated widgets so that each page lays in Flutter Complete Reference 582",
  ". Widgets showcase its dedicated \ufb01le/class. The DefaultTabController widget internally contains a TabController which is automatically managed. However, if you want to have more control of your tabs, you should directly work with a controller: class _PageState extends State<Page> with SingleTickerProviderStateMixin { late final TabController tabController; @override void initState() { super.initState(); tabController = TabController( vsync: this, length: , ); } @override void dispose() { tabController.dispose(); super.dispose(); } void _changePage(int index) { if (index >= ) { tabController.animateTo(index); } } @override Widget build(BuildContext context) { return TabBarView( controller: tabController, children: const [...], ); } } There\u2019s more code to write because now you have to manually create, initialize and dispose a controller while earlier the DefaultTabController did it for you. The advantage is that you Flutter Complete Reference 583",
  ". Widgets showcase have more control of the tabs because, for example, you can change tabs programmatically: tabController.animateTo(index); Thanks to animateTo() you can move to the desired tab with a swipe animation without needing the user\u2019s \ufb01nger to swipe/tap. Unless you need to do special manual work on tabs, go for a DefaultTabController which is much less boilerplate code. ..5 Stepper If you need a widget that guides the user over a series of steps before getting a result, a Stepper might be the right choice. It is very useful when there is a form to \ufb01ll and certain types of data require the submission of other data in order. There\u2019s the possibility to control the contents of the circles, which can be a tick or a pencil to indicate the current status, and the user can navigate back/forth. A Stepper can also be used in vertical mode which is probably better when there is a lot of available height: Flutter Complete Reference 584",
  ". Widgets showcase You could decide to always use the stepper in a single direction, which is \ufb01ne as it provides automatic scrolling in case of over\ufb02ow. However, you should consider the usage of LayoutBuilder to make the widget responsive: LayoutBuilder( builder: (context, dimensions) { var stepperType = StepperType.vertical; if (dimensions.maxWidth > ) { stepperType = StepperType.horizontal; } return Stepper( type: stepperType, steps: const [...], ); }, ), A Stepper takes a list of Step indicating the single actions the user is asked to accomplish. Note Flutter Complete Reference 585",
  ". Widgets showcase that class Step { ... } is not a widget but it still requires some parameters: \u2022 currentStep. It\u2019s the currently visible step and it should be handled via provider or \ufb02utter_bloc, for example. The int associated with this value has to change to re\ufb02ect the actual step the user has to see. \u2022 onStepContinue. Callback triggered when the \"Continue\" button is pressed; it should be used to increment the value of currentStep. \u2022 onStepCancel. Callback triggered when the \"Cancel\" button is pressed; it should be used to decrement the value of currentStep. In this example we\u2019ve hard coded some values just for the sake of simplicity. Your state manage- ment library should also handle the state parameter which changes the icon associated with the name of the step in the UI. If you don\u2019t set it, numbers are shown by default. Stepper( currentStep: , type: stepperType, onStepContinue: () {...}, onStepCancel: () {...}, steps: const [ Step(...), Step( title: Text(\"Address\"), content: Text(\"Form with inputs\"), state: StepState.editing, ), Step(...), ], ); Callbacks should be de\ufb01ned into separated functions rather than directly inside the Stepper. ..6 DataTable Sometimes certain type of information can only be represented in a table because other kind of layouts just don\u2019t \ufb01t well. You could start using the Table widget but you\u2019d have to manually Flutter Complete Reference 586",
  ". Widgets showcase code any extra feature (like sorting) by yourself. A very good alternative is the DataTable widget. Thanks to the DataTable widget you\u2019re able to easily display tabular data, containing of course any kind of widget. Columns automatically resize to \ufb01t the contents. Other than the following, there are many built-in options to enable such as the possibility to sort the entire table just by tapping on the header. SingleChildScrollView( child: DataTable( sortColumnIndex: , sortAscending: false, columns: const [...], rows: [...], ), ), You can decide the sorting \"direction\" thanks to sortAscending, de\ufb01ne callbacks for rows, setting margins and much more. We recommend wrapping the table in a SingleChildScrollView to ensure that over\ufb02ows will be automatically handled with scroll bars. Use a DataColumn widget to setup a column of a DataTable. columns: [ DataColumn( Flutter Complete Reference 587",
  ". Widgets showcase label: const Text(\"Language\"), onSort: (int colIndex, bool ascending) {...} ), const DataColumn( label: Text(\"Likes\"), numeric: true ), const DataColumn( label: Text(\"Mascot\") ), ], With the column parameter you give the header a name, set whether it\u2019s numeric (which is false by default) and/or set a callback for sorting purposes. If onSort is not de\ufb01ned, the column is considered to be \"\ufb01xed\" and thus it cannot be sorted. Each cell of the table can be populated with rows, which is allowed to only contain a list of DataRows. The DataCell widget can contain anything such as images, icons, text, SVG and so on. In our example we\u2019ve populated the cell with a Wrap widget. rows: [ DataRow(cells: [ DataCell( Wrap( spacing: , Flutter Complete Reference 588",
  ". Widgets showcase children: const [ Text(\"Java\"), Icon(Icons.verified_user, color: Colors.green, size: , ) ], ), ), const DataCell(Text(\"\")), const DataCell(Text(\"Duke\")), ]), DataRow(cells: [ DataCell(...), const DataCell(Text(\"\")), const DataCell(Text(\"Dash\")), ]), ], The number of children in a DataRow (the table cells) must be equal to the number of columns de\ufb01ned in the table otherwise an exception is thrown. Each DataCell also de\ufb01nes an onTap callback and the possibility to show an icon to edit the \ufb01eld. DataCell( onTap: () {...} showEditIcon: true, ), The o\ufb03cial DataTable documentation says that tables are relatively expensive to be rendered so when you have a lot of data to display you should paginate the results. Indicatively, 10x10 or 12x12 tables are considered \"big\" but actually it also depends a lot on the physical device. An old and slow mobile phone for example might be in trouble even with a few dozens of data. Flutter Complete Reference 589",
  ". Widgets showcase The above result is obtained with a PaginatedDataTable widget: it limits the number of visible rows by paginating the results. In this way, data can be lazy-loaded avoiding an expensive build of the table and the user is not presented a too long list of data on the screen. PaginatedDataTable( rowsPerPage: , header: const Text(\"Info\"), columns: const [ DataColumn( label: Text(\"Language\"), ), DataColumn( label: Text(\"Mascot\"), ), ], source: Source(), ); You can decide how many rows have to appear per page with rowsPerPage. The header is required and it\u2019s just a widget that appears at the top of the table. Rows aren\u2019t assigned in the \"classic\" way using a rows parameter but instead there\u2019s the need to subclass a DataTableSource, which exposes data to the table. Flutter Complete Reference 590",
  ". Widgets showcase class Source extends DataTableSource { // The data of the table. They're here as a static list just // to keep the example simple. static final values = { \"Flutter\": \"Dash\", \"Java\": \"Duke\", \"Delphi\": \"Helmet\", \"PHP\": \"ElePHPant\", \"MySQL\": \"Dolphin\", }.entries.toList(); @override DataRow? getRow(int index) { final data = values[index]; return DataRow.byIndex( index: index, cells: [ DataCell(Text(data.key)), DataCell(Text(data.value)), ] ); } @override bool get isRowCountApproximate => false; @override int get rowCount => values.length; @override int get selectedRowCount => ; } It\u2019s declared as abstract class DataTableSource extends ChangeNotifier because when- ever the data source changes, you need to call notifyListeners() to refresh the table. In our example we\u2019ve simply hard-coded a list with a few values, but in reality you should pass the data via constructor injection. Flutter Complete Reference 591",
  ". Widgets showcase \u2022 getRow: returns the actual data represented by a DataRow type. You should use the byIndex constructor in order to avoid worrying about using keys to uniquely identify rows. Remember that: \u2013 the number of cells must match the column count; \u2013 call notifyListeners(); whenever you add/remove a row or any content is changed. Note that DataTableSource extends ChangeNotifier so you\u2019re able to triggers rebuilds calling notifyListeners() inside your model class. \u2022 isRowCountApproximate: a value of false means that the row count is \ufb01xed (the table won\u2019t change). When set to true, then you\u2019re estimating the row count which will be \ufb01nalized in a second moment (and updated via notifyListeners();). This is useful when the table rows aren\u2019t immediately ready: some might appear later because of waiting for a Future<T> or an external event to \ufb01nish. \u2022 selectedRowCount: number of currently selected rows, which we\u2019ve set to 0 by default. \u2022 rowCount: if isRowCountApproximate returns false, then this method should just return the exact length of the data source (because the data source won\u2019t change). Instead, if it returned true you should change the body of getRow(); DataRow? getRow(int index) { // Trying to access an item not yet in the table. Return // 'null' to show an animated circular loading indicator. if (index >= values.length) return null; final data = values[index]; return DataRow.byIndex(...); } Basically, if the table tries to access an element not yet in the data source, you need to return null. In this way, a loading indicator automatically appears; it will disappear once the element has been added and updated via notifyListeners(). You should set isRowCountApproximate => true when you plan to add/remove data on the table at runtime or when a Future<T>/Stream<T> completed. The table automatically shows a loading indicator as a placeholder; when data are ready and the table won\u2019t be modi\ufb01ed anymore, change this to returning false. Flutter Complete Reference 592",
  ". Widgets showcase .2 Cupertino \u2022 Reference: https://developer.apple.com/design/human-interface-guidelines/ios/ ..1 CupertinoDatePicker It\u2019s a traditional iOS-styled picker where data are laid out in columns and they\u2019re scrollable in the vertical direction. The widget is localized because it automatically translates according to the device\u2019s language. The order of the columns may vary according to the current locale. You can get this result using a showModalBottomSheet<T> to wrap the CupertinoDatePicker widget. Since the popup overlays a large part of the screen, we need its height to be calculated according to the physical device screen dimensions. For this reason, we\u2019re using MediaQuery rather than LayotuBuilder. void _showPicker(BuildContext context){ showModalBottomSheet( context: context, builder: (BuildContext context){ Flutter Complete Reference 593",
  ". Widgets showcase final size = MediaQuery.of(context)?.size.height; final panelHeight = size == null ?  : size / .; return SizedBox( height: panelHeight, child: CupertinoDatePicker( initialDateTime: DateTime.now(), onDateTimeChanged: (DateTime newDate) {}, minimumYear: , maximumYear: , mode: CupertinoDatePickerMode.date, ), ); } ); } The widget is quite easy to setup; the _showPicker method is inkoved on a button tap and a dialog slides up (with an animation) from the bottom. Very easily, the picker can only show the date, the time or both just by changing the mode: mode: CupertinoDatePickerMode.date, mode: CupertinoDatePickerMode.dateAndTime, mode: CupertinoDatePickerMode.time, The onDateTimeChanged callback can be used to get the currently selected date from the picker. It\u2019s very convenient and e\ufb03cient because there\u2019s no need for controllers or keys. ..2 CupertinoActionSheet If you have the need to show a list of selectable options in an iOS style, the CupertinoActionSheet could really be the right choice. It implements the \"action sheet\" UI design which is basically a list of actions sliding up from the bottom of the screen. CupertinoActionSheet( actions: <Widget>[ CupertinoActionSheetAction( child: const Text(\"Do something\"), onPressed: () {}, isDefaultAction: true, Flutter Complete Reference 594",
  ". Widgets showcase ), CupertinoActionSheetAction( child: const Text(\"Delete\"), onPressed: () {}, isDestructiveAction: true, ), ], ), With isDefaultAction: true and isDestructiveAction: true you set the text to bold or red respectively; the latter is used when you\u2019re implementing a button that deletes something. There\u2019s also the possibility to create a separated \"Cancel\" button at the bottom of the list: CupertinoActionSheet( cancelButton: CupertinoActionSheetAction( child: const Text(\"Cancel\"), onPressed: () {...}, ), actions: <Widget>[...] ), ..3 CupertinoSegmentedControl This widget is typically used when the user is asked to select between a number of mutually exclusive options. The idea is to associate a type to a widget, which is generally a Text(), so that when it\u2019s pressed, the data it points to are returned. CupertinoSegmentedControl( children: const <int, Widget>{ : ChildIcon(\"Option \"), : ChildIcon(\"Option \"), : ChildIcon(\"Option \"), }, onValueChanged: (int value) { _currentValue = value; }, groupValue: _currentValue, ) The children parameter takes a map that associates an int to a ChildIcon widget. When the Flutter Complete Reference 595",
  ". Widgets showcase user chooses one of the three options, the onValueChanged callback is called with the currently selected value. For example if you tapped on \"Option \", in onValueChanged the int value variable would contain 2 because it\u2019s the value associated with the selected widget. We have created a reusable widget in order to keep consistency in the control and avoid code duplication, as usual: class ChildIcon extends StatelessWidget { final String text; const ChildIcon(this.text); @override Widget build(BuildContext context) { return Padding( padding: EdgeInsets.fromLTRB(, , , ), child: Text(text), ); } } .3 Community widgets At https://pub.dev there are lots of packages and the number is at a constant growth thanks to your help. We\u2019re listing now some high quality packages you might \ufb01nd useful during your development journey. The descriptions have been taken from their package\u2019s home page. \u2022 sq\ufb02ite. Flutter plugin for SQLite, a self-contained, high-reliable, embedded database en- gine. \u2022 mobx. MobX is a library for reactively managing the state of your applications. Use the power of observables, actions, and reactions to supercharge your Dart and Flutter apps. \u2022 RxDart. RxDart is an implementation of the popular reactiveX api for asynchronous programming, leveraging the native Dart Streams api. Flutter Complete Reference 596",
  ". Widgets showcase \u2022 carousel_slider. A carousel slider widget, support in\ufb01nite scroll and custom child widget. \u2022 \ufb02utter_slideable. A Flutter implementation of a slidable list item with directional slide actions that can be dismissed. \u2022 \ufb02utter_staggered_grid_view. A Flutter staggered grid view which supports multiple columns with rows of varying sizes. \u2022 \ufb02utter_secure_storage. Flutter Secure Storage provides API to store data in secure storage. Keychain is used in iOS, KeyStore based solution is used in Android. \u2022 over\ufb02ow_view. A widget displaying children in a line with an over\ufb02ow indicator at the end if there is not enough space. \u2022 hive. Lightweight and blazing fast key-value database written in pure Dart. Strongly encrypted using AES-. In chapter 23 we will talk in detail about packages, likes and the scoring system. ..1 Flutter Hooks A StatefulWidget is essential in some cases: when using animations for example, its dispose() method must be used to perform cleanup operations on the controllers. Following this case, here\u2019s the typical skeleton of a StatefulWidget with two animations: class Example extends StatefulWidget { const Example(); @override _ExampleState createState() => _ExampleState(); } class _ExampleState extends State<Example> with SingleTickerProviderStateMixin{ late final AnimationController _controller1; late final AnimationController _controller2; @override void initState() { super.initState(); _controller1 = AnimationController( Flutter Complete Reference 597",
  ". Widgets showcase vsync: this, duration: const Duration(seconds: ), ); _controller2 = AnimationController( vsync: this, duration: const Duration(seconds: ), ); } @override void dispose() { _controller1.dispose(); _controller2.dispose(); super.dispose(); } @override Widget build(BuildContext context) { return MyWidget(); } } Indeed there\u2019s a lot of code to write because controllers generally require to be initialized and disposed. It would have been the same if we had used a TextEditingController for example, because it also has to be initialized and disposed. We can notice a few problems with the \"controllers pattern\": . a lot of boilerplate code to write; . we\u2019d like to create reusable instances of our controllers but they\u2019re tied to initState() and dispose(); . a mixin could be a good idea but it can be used only once (if your class required two controllers, you\u2019d have to use the mixin twice but that\u2019s not possible). In other words, the code inside a StatefulWidget is di\ufb03cult to reuse. Performance here don\u2019t matter: the problem is the potentially big amount of code duplication \"caused\" by the structure of the class itself. There\u2019s no built-in way to solve this maintenance problem but thankfully the Flutter community comes to the rescue! Flutter Complete Reference 598",
  ". Widgets showcase Thanks to the \ufb02utter_hooks package (by R\u00e9mi Rousselet), you can create \"reusable stateful widgets\" to get rid of all those code duplication issues we exposed above. Using hooks, the same animation example at the beginning of the section can be rewritten in the following way: // - same thing as before but less boilerplate and more reusability // - initState/dispose are not needed because 'useAnimationController' does // the job for us class Example extends HookWidget { const Example(); @override Widget build(BuildContext context) { final controller1 = useAnimationController( duration: const Duration(seconds: ) ); final controller2 = useAnimationController( duration: const Duration(seconds: ) ); return Container(); } } This is a huge improvement. Hooks do everything automatically: internally they initialize and dispose the controllers so that you don\u2019t have to write too much code. Basically, a HookWidget is a \"reusable StatefulWidget\" which automatically handles your widget\u2019s resources. Before going on, there\u2019s something more to say: \u2022 Even if declared inside build(), hooks \"survive\" to rebuilds and they can be reused an in\ufb01nite number of times. \u2022 Hooks cannot be used in the build() method of StatefulWidget or StatelessWidget. Flutter Complete Reference 599",
  ". Widgets showcase \u2022 useAnimationController() is a \"hook\", like many others we will see in a few lines. \u2022 There\u2019s nothing weird under the hood because internally HookWidget inherits from a state- less widget so it\u2019s still a \"normal\" Flutter widget. Of course, hooks are not required but they are very convenient and you might get used to them very quickly. Here\u2019s a side-by-side comparison between the StatefulWidget and HookWidget implementation of a simple animation example. Animation with StatefulWidget .Animation with HookWidget static const R =  * .; late AnimationController ctl; @override void initState() { super.initState(); ctl = AnimationController( vsync: this, duration: const Duration( seconds:  ), )..repeat(); } @override void dispose() { ctl.dispose(); super.dispose(); } @override Widget build(BuildContext ctx) { static const R =  * .; @override Widget build(BuildContext context) { final ctl = useAnimationController( duration: const Duration( seconds:  ) )..repeat(); return AnimatedBuilder( animation: ctl, builder: (context, child) { return Transform.rotate( angle: ctl.value * R, child: child ); }, child: const FlutterLogo( size: , ), ); } Flutter Complete Reference 600",
  ". Widgets showcase return AnimatedBuilder( animation: ctl, builder: (context, child) { return Transform.rotate( angle: ctl.value * R, child: child ); }, child: const FlutterLogo( size: , ), ); } . The type and the usage of the ctl variable is identical because, in both cases, it\u2019s always a AnimationController. Initialization and disposal happen in the hook as well but they\u2019re \"hidden\". So far we\u2019ve only shown a single type hook which works with animations but there are many more you can use, such as: . useTextEditingController(). Creates a TextEditingController and automatically takes care of disposing it when not needed anymore. Optionally, it can be initialized with some text. @override Widget build(BuildContext context) { final emailController = useTextEditingController(\"default@me.com\"); return TextFormField( controller: emailController, ); } . useTabController(). Creates a TabController and automatically takes care of disposing it when not needed anymore. As you\u2019ve already seen in .., it\u2019s used to manually move among tabs on a TabBarView. . useStream<T>(). Subscribes to a Stream<T> and uses an AsyncSnapshot<T> to return the current state. Flutter Complete Reference 601",
  ". Widgets showcase . useFuture<T>(). Subscribes to a Future<T> and uses an AsyncSnapshot<T> to return the current state. . useMemoized<T>(). Caches an instance of an object for a later use. As you already know, hooks \"survive\" to rebuilds so this method persists the data. @override Widget build(BuildContext context) { final cachedUser = useMemoized<User>(() => const User( name: \"Alberto\", surname: \"Miola\". )); return UserWidget( data: cachedUser ); } The User instance is immediately stored; when the HookWidget rebuilds, useMemoized() returns the previous instance. useContext(). Returns the BuildContext of the current HookWidget. Be sure to visit the o\ufb03cial documentation 3 to see all the types of hooks you can use. If you can\u2019t \ufb01nd what you\u2019re looking for, there\u2019s even the possibility to create your own hooks just by overriding Hook. Let\u2019s see how we can create a hook to generate random numbers: . Create a new \ufb01le called time_hook.dart. . Create a top-level function to \"hide\" the actual class implementing the hook and be sure to start with the word use. These are just conventions you should follow to keep consistency with the \"hooks environment\". int useRandomGenerator(int value) { return use<int>(_RandomGenerator(maxValue: value)); } . In the same \ufb01le, create the actual hook extending Hook<T> which has a the same structure as a StatefulWidget. When inside the state, you can reference members de\ufb01ned in the class using the hook property (where in a StatefulWidget you\u2019d have used widget). 3https://pub.dev/documentation/\ufb02utter_hooks/latest/ Flutter Complete Reference 602",
  ". Widgets showcase class _RandomGenerator extends Hook<int> { final int maxValue; const _RandomGenerator({ required this.maxValue }); @override _RandomGeneratorState createState() => _RandomGeneratorState(); } class _RandomGeneratorState extends HookState<int, _RandomGenerator> { late final Random random; @override void initHook() { super.initHook(); random = Random(); } @override int build(BuildContext context) => random.nextInt(hook.maxValue); @override void dispose() { debugPrint(\"Disposed the 'RandomGenerator' hook\"); super.dispose(); } } This is also how useAnimationController and others work under the hood. De\ufb01ne your ini- tialization and \ufb01nalization logic inside initHook and dispose. The build() method returns the data type you need which is an int in this case. ..2 State noti\ufb01er You\u2019ve seen many examples where we used ChangeNotifier to create \"listenable\" model classes that can be watched by a ChangeNotifierProvider<T> (from the provider package). It\u2019s the Flutter Complete Reference 603",
  ". Widgets showcase most common way of working and it\u2019s very e\ufb03cient. class DateCache with ChangeNotifier { DateTime _date = DateTime.now(); Date get currentDate => _date; void refresh() { _date = DateTime.now(); notifyListeners(); } } This small model class simply exposes a date and noti\ufb01es its listeners when it\u2019s updated. All good here but thanks to the state_noti\ufb01er package we can do the same thing with less code (and probably readability would bene\ufb01t as well). class DateCache extends StateNotifier<DateTime> { DateCache(): super(DateTime.now()); void refresh() { state = DateTime.now(); } } StateNotifierProvider is the equivalent of ChangeNotifierProvider but in the \"state noti- \ufb01er\" world. They do the same thing but of course the former works with StateNotifier<T> and the latter with ChangeNotifier. // Requires the 'flutter_state_notifier' package to be imported StateNotifierProvider<DateCache, DateTime>( create: (_) => DateCache(), child: const Something(), ) // Inside the 'Something' widget @override Widget build(BuildContext context) { return Column( children: [ Flutter Complete Reference 604",
  ". Widgets showcase Text(\"${context.watch<DateTime>()}\"), RaisedButton( child: const Text(\"Refresh\"), onPressed: () => context.read<DateCache>().refresh(), ) ] ); } Very intuitively, watch<T>() is used to rebuild the widget whenever the date changes and read<T> just returns a reference without rebuilding anything. Note that watch<T>() needs the type of the state while read<T>() needs the type of the noti\ufb01er. Flutter Complete Reference   | Using Firebase with Flutter .1 Installation In this chapter we\u2019re working with FlutterFire plugins, a series of packages that connect your Flutter apps to Firebase. Before any of the Firebase services can be used, you always need to setup your platform and thus, for new projects, the following guide is required. We\u2019re only covering the most commonly used package: visit the o\ufb03cial documentation 1 to get a complete overview. https://\ufb01rebase.\ufb02utter.dev As example, we\u2019re going to con\ufb01gure the app we will build in the next section. Regardless, these steps will always be the same for any new project. Go to the Firebase console 2 and log in with your Google account. Click on \"Add project\", give it a name (once decided, it cannot be changed) and leave all the other settings as they are. 1https://\ufb01rebase.\ufb02utter.dev 2https://console.\ufb01rebase.google.com/u// Flutter Complete Reference 606",
  ". Using Firebase with Flutter After a few seconds you\u2019ll be redirected to the new project page from which you can link Firebase\u2019s services (database, storage, analytics...) to your apps. Let\u2019s start by clicking on Add Firebase to your Android app and follow the steps: . Type the package name you want and be sure to also use this same name when the Flutter project will be created. Having an identical name is fundamental in order to link an app to your Firebase cloud project. . Download the google-services.json \ufb01le which we\u2019re going to use soon. It\u2019s a con\ufb01gura- tion \ufb01le needed in our projects in order to recognize which Firebase project your app has to point at. The Android setup is now ready so we can add more platforms clicking on \"Add another app\". In case you had the need to use Firebase for iOS, just hit Add Firebase to your iOS app and follow the same procedure as before: . Type the bundle ID you want and, again, be sure it matches the bundle ID name of your iOS app. In practice, it must be identical to the string you put earlier for Android since Flutter Complete Reference 607",
  ". Using Firebase with Flutter the project is the same. . Download the con\ufb01guration \ufb01le. Since we\u2019re creating a cross-platform app with Flutter, both Android and iOS should really have the same value for package name and bundle ID respectively. Firebase is now completely setup so it\u2019s time to create a new Flutter project with the correct package name (screenshot from Android Studio): It\u2019s the same string we\u2019ve put earlier when registering both the Android and iOS projects. Lastly, there\u2019s the need to get the con\ufb01guration \ufb01les in place, the ones downloaded at the second step of the platform setup. For Android: . Move google-services.json in your Flutter project at android/app, which is the same directory of the build.gradle \ufb01le . Open the android/build.gradle \ufb01le and inside dependencies add a reference to google services (be sure to use the latest version): buildscript { Flutter Complete Reference 608",
  ". Using Firebase with Flutter repositories { google() jcenter() } dependencies { ... classpath 'com.google.gms:google-services:..' } } . Open the android/app/build.gradle \ufb01le and at the bottom, below the dependencies group, add this line: apply plugin: 'com.google.gms.google-services' For iOS instead you need to open Xcode, select the .xcworkspace \ufb01le with your project\u2019s name, right click it and choose \"Add \ufb01les to \u2019Runner\u2019\". Select the GoogleServices-Info.plist \ufb01le and import it. Don\u2019t manually move it via \ufb01lesystem because it won\u2019t work. dependencies: flutter: sdk: flutter firebase_core: ^..0 Be sure to add the firebase_core plugin in your dependencies list because it\u2019s required by any FlutterFire package. It links your Flutter app to Firebase. It has to be initialized before any Firebase interaction happens so ideally Firebase.initializeApp(); should be called in the home page. class HomePage extends StatefulWidget { const HomePage(); @override _HomePageState createState() => _HomePageState(); } class _HomePageState extends State<HomePage> { late final Future<FirebaseApp> _initialization; @override Flutter Complete Reference 609",
  ". Using Firebase with Flutter void initState() { super.initState(); _initialization = Firebase.initializeApp(); } @override Widget build(BuildContext context) { return FutureBuilder<FirebaseApp>( future: _initialization, builder: (context, snapshot) { if (snapshot.hasError) { return const ErrorWidget(); } if (snapshot.connectionState == ConnectionState.done) { return const HomePageBody(); } return const Center( child: SomeLoadingWidget(), ); }, ); } } For more info on how to gracefully perform startup initialization, see appendix B.. If you use a FlutterFire plugin without having called initializeApp() \ufb01rst, your app won\u2019t work. .2 Using Firestore as backend Firestore is Google\u2019s backend solution for your desktop, web or mobile apps which o\ufb00ers scalabil- ity, reliability and real-time data sync. In this section we\u2019re going to create an app to keep track of votes submitted by users about their favorite programming language. Flutter Complete Reference 610",
  ". Using Firebase with Flutter Very simply, pressing the green thumb for a certain language increases the \"like\" counter by . We\u2019re going to see the implementation of this app, backed by a Firestore NoSQL database, in the very next section. We now want to focus a bit on the advantages brought by this cloud-based service: . When you tap on the \"like\" button, the database is updated and changes are re\ufb02ected immediately on any device. Data are updated in real-time so anyone looking at the app can see the counters increasing... in real-time! No need to press on a \"refresh\" button or perform any action to update the UI. . The data, such as \"likes\" and programming language names, are stored in Firestore (a NoSQL database) and the integration with the app happens thanks to the cloud_\ufb01restore plugin. . Firestore is a very robust, distributed and reliable service maintained by Google, along with its Flutter implementation. You don\u2019t have to worry about compatibility or the complexity of the API because there are a series of Dart classes ready for you to use. . You don\u2019t have to create/test a web service, manage a database, setup periodic backups and all those important backend tasks. Firestore takes care of everything so that you can fully concentrate on app development. Flutter Complete Reference 611",
  ". Using Firebase with Flutter Firestore is very powerful and handy but of course it\u2019s not the only way to create a backend for a Flutter application. For example, we could have used a Linux server with a traditional MySQL database and a webservice exposing a REST API. In this case, we\u2019d have to take care of both the backend and the frontend. Firebase instead exposes a series of services for our apps and thanks to FlutterFire, there\u2019s even more integration and ease of use. You can only focus on the frontend. Before adopting it, you should explore its capabilities and doing some demo projects in order to be able to evaluate its pros and cons. ..1 Building the backend Go to the Firestore console, choose the newly created project, click on \"Database\" on the left and choose \"Cloud Firestore\" as project database. For our demo app, going for test mode is \ufb01ne but if you consider keeping your project alive for a long time, you should later switch to locked mode. It\u2019s more secure. Flutter Complete Reference 612",
  ". Using Firebase with Flutter Wait a minute while the Firestore instance prepares and then you\u2019re ready to start. We\u2019re going to work with a NoSQL database, which has no relations and foreign keys as it\u2019s structured like a JSON \ufb01le with key-value pairs. It\u2019s made up of three important parts: A series of data is grouped together in a document, which must have an unique id. One or more documents are grouped inside a collection. To be more speci\ufb01c, in our example we\u2019ve decided to use a collection called \"languages\" which is going to contain a series of documents about programming languages: Flutter Complete Reference 613",
  ". Using Firebase with Flutter Data can be of various types such as arrays, integers, strings or time. Each document has an id, represented by a weird long string (it\u2019s been automatically generated by Firestore but you could manually assign one). Each document holds data about a certain programming language; you should use the same names across the entire collection in order to make easy queries. Flutter Complete Reference 614",
  ". Using Firebase with Flutter As you can see, \"Document ID\" is the unique identi\ufb01er we\u2019ve decided to automatically assign just to keep the example easy. You should really look at the best practices 3 section of the doc- umentation which is very useful, especially for beginners. We\u2019re good with these settings so we can move to the frontend section. B Resources >",
  "> Cloud Firestore ..2 Building the frontend Add the o\ufb03cial cloud_\ufb01restore 4 package as dependency in your pubspec.yaml \ufb01le and be sure you\u2019ve already called Firebase.initializeApp(). In order to receive real-time updates from the database, we\u2019re going to work with streams. class FavoriteList extends StatelessWidget { static Stream<QuerySnapshot> getStream() => FirebaseFirestore .instance .collection(\"languages\") .orderBy(\"likes\", descending: true) //  .snapshots(); // 2 const FavoriteList(); // build... } Thanks to collection(\"languages\") we can reference the \"languages\" collection on Firestore created in the previous step. The FirebaseFirestore.instance already knows how to point to the correct database in the cloud because settings are taken from the json or .plist con\ufb01guration \ufb01les. . You can build a query and \ufb01lter the data received from the database. In this example we\u2019re ordering rows but you can also use other functions such as limit() or where(). . The snapshot() method returns a stream listening to the given collection: new values are emitted whenever something changes. Thanks to this approach, we\u2019re able to show 3https://\ufb01rebase.google.com/docs/\ufb01restore/best-practices 4https://pub.dev/packages/cloud_\ufb01restore Flutter Complete Reference 615",
  ". Using Firebase with Flutter live changes in our app without having to manually refresh the page. Data are always automatically kept in sync with the database. The stream is handled in the usual way: the hasData property tells whether data are ready to be displayed or not. As always, remember to use const constructors as much as possible because builder functions are called quite often. @override Widget build(BuildContext context) { return StreamBuilder<QuerySnapshot>( stream: getStream(), builder: (context, languages) { if (languages.hasError) { return const ErrorWidget(); } if (languages.hasData) { final data = languages.data; if (data != null) { return ListView.builder( itemExtent: ., itemCount: data.docs.length, itemBuilder: (context, index) => LanguageItem(data.docs[index]), ); } else { return const ErrorWidget(); } } return const Center( child: CircularProgressIndicator() ); }, ); } To favor code readability, making a reusable widget to represent each item of the list is a good Flutter Complete Reference 616",
  ". Using Firebase with Flutter idea so we created class LanguageItem. The docs list contains the list of documents returned by the query executed on the \"languages\" collection. class LanguageItem extends StatelessWidget { final String name; final int likes; final String asset; final QueryDocumentSnapshot _snapshot; LanguageItem(this._snapshot) : asset = _snapshot.get(\"image\") as String, likes = _snapshot.get(\"likes\") as int, name = _snapshot.get(\"name\") as String; // build and updateVote... } The QueryDocumentSnapshot object holds data about a document of the collection, which is in our case the data about a programming language. We have to pay attention to write the correct \ufb01eld names otherwise an exception will be thrown. In case you wanted to add another \ufb01eld, go to the online console and click on \"Add \ufb01eld\" for each object in the collection. Each programming language is represented by a ListTile widget which is very handy when it comes to showing data in a ListView. The image \ufb01eld we set in the Firestore collection indicates the name of the .svg asset the app has to load. @override Widget build(BuildContext context) { return ListTile( leading: SvgPicture.asset(\"images/$asset\", height: , ), Flutter Complete Reference 617",
  ". Using Firebase with Flutter title: Text(name), subtitle: Text(\"Total likes: $likes\"), trailing: IconButton( icon: const Icon(Icons.thumb_up), onPressed: _updateVote, ... ), ); } When tapping on the icon we want to update the item in the database so that the \"like counter\" increases by . We need to reference again the collection via FirebaseFirestore.instance, increase the value on the correct document and send the update to Firestore. It will then take care of notifying listeners about changes. void _updateVote() { FirebaseFirestore.instance.runTransaction((transaction) async { // . final secureSnapshot = await transaction.get( _snapshot.reference ); // Getting the current likes count final int currentLikes = secureSnapshot.get(\"likes\") as int; // . transaction.update(secureSnapshot.reference, { \"likes\": currentLikes +  }); }); } This approach is secure and free from data races. We\u2019re guaranteed that there won\u2019t be con- currency problems thanks to the runTransaction() method, which is basically the safe way to update data on Firestore. Inside the scope of a transaction you can update data and be sure that the action will execute \"atomically\". . The secureSnapshot object contains a fresh new copy of the language item from which we can safely read and, most importantly, write values. Flutter Complete Reference 618",
  ". Using Firebase with Flutter . With update() you can change the content of the given \ufb01eld, assuming you\u2019re passing the correct name. In our case the like counter has to be incremented by 1 so we assign the new value to the \ufb01eld \"likes\". Firestore has built-in support for o\ufb04ine mode. When reading and writing data, an internal local database is kept in sync with the cloud. In case of no internet connection available, Firestore continues to work and when connectivity comes back data are automatically synchronized. void main() { FirebaseFirestore.instance.settings = Settings( persistenceEnabled: false, cacheSizeBytes: Settings.CACHE_SIZE_UNLIMITED, ); runApp(MyApp()); } This is very powerful but you might want to rely only on the internet connection. For this reason, setting persistenceEnabled: false disables the \"o\ufb04ine mode\". The default cache size value is 40 MB and the minimum value you can use is 1 MB. The local database can be removed but the following call has to be made before any Firestore interaction. await FirebaseFirestore.instance.clearPersistence(); Calling clearPersistence() after even a single Firebase call will clear the local database on the next app startup. ..3 Working with data In the previous example, we\u2019ve seen how to read data and receive real-time updates whenever something changes. Other than listening for changes on collections, you can also listen for single documents in a similar way. // Real-time changes on the collection final Stream<QuerySnapshot> collection = FirebaseFirestore .instance.collection('my_collection').snapshots(); // Real-time changes on the document final Stream<DocumentSnapshot> document = FirebaseFirestore .instance.collection('my_collection').doc('doc_id').snapshots(); Flutter Complete Reference 619",
  ". Using Firebase with Flutter In both cases, you get a Stream<T> instance which can be used in a StreamBuilder<T> widget. To reference a speci\ufb01c document on the collection, you need to provide its ID. If you aren\u2019t interested in real-time updates, you can execute an one-time read: // Get all the documents in a collection final Future<QuerySnapshot> documents = FirebaseFirestore .instance.collection('my_collection').get(); // Get all the data inside a single document final Future<DocumentSnapshot> documents = FirebaseFirestore .instance.collection('my_collection').doc('doc_id').get(); The result is now a Future<T> because data are one-time received and not listened. In both cases (real-time and one-time) you can query collections but of course there\u2019s no possibility to query documents. Here are some examples based on our \"languages\" collection: \u2022 Sorting. FirebaseFirestore.instance .collection(\"languages\") .orderBy(\"likes\") .snapshots(); FirebaseFirestore.instance .collection(\"languages\") .orderBy(\"name\", descending: true) .snapshots(); Ascending is the default direction. \u2022 Limiting. FirebaseFirestore.instance .collection(\"languages\") .limit() .snapshots(); Limits the number of documents retrieved by a query. Use limitToLast() to limit but from the bottom. \u2022 Filtering. FirebaseFirestore.instance Flutter Complete Reference 620",
  ". Using Firebase with Flutter .collection(\"languages\") .where(\"likes\", isLessThan: ) .snapshots(); FirebaseFirestore.instance .collection(\"languages\") .where(\"likes\", isGreaterThanOrEqualTo: ) .orderBy(\"likes\", descending: true) .snapshots(); You can also use arrayContains for collections. To add a new document in a collection, simply use FirebaseFirestore to get a reference to the collection and then call the add(Map<String, dynamic> data) method which returns a Future<T> object. // Generates an unique random ID FirebaseFirestore.instance .collection(\"languages\") .add({ \"image\": \"java.svg\", \"likes\": , \"name\": \"Java\" }); With this approach, a new document is added with an auto-generated ID. If you want to be able to manually specify an ID, use set(Map<String, dynamic> data) on a document reference. Pay attention because a duplicate ID replaces the other document rather than throwing an exception. // Uses the ID you give FirebaseFirestore.instance .collection(\"languages\") .doc(\"my_id_012\") .set({ \"image\": \"java.svg\", \"likes\": , \"name\": \"Java\" }); Call delete() on a DocumentReference to delete the document. You can also selectively delete Flutter Complete Reference 621",
  ". Using Firebase with Flutter \ufb01elds of a document using a combination of update() and FieldValue.delete(). // Remove the 'image' value from the document FirebaseFirestore.instance .collection(\"languages\") .doc(\"my_id_012\") .update({ \"image\": FieldValue.delete(), }); Using update() alone might introduce data race problems because concurrency in Firestore plays a very important role. For this reason, you\u2019d better update your documents\u2019 data inside a transaction. ..4 Transactions and batches You\u2019ve already seen an example of a transaction in the \"languages\" example where the like counter is safely incremented by one. Transactions are generally used to ensure a safe read/update of a \ufb01eld based on its current value or the value of other \ufb01elds. Let\u2019s see an example where we try to increase the age of a person: \u2022 Without transactions, Firestore updates a value in two di\ufb00erent steps. It \ufb01rst executes get(\"age\") to retrieve the value and then, with another separated operation, it executes the update() method. final currValue = docSnapshot.get(\"age\") as int; await docSnapshot.reference.update({ \"age\": currValue +  }); The problem is that between get() and update(), the \ufb01eld \"age\" might be changed by another call so our update() is actually working on \"outdated\" data. The \ufb01nal result is unde\ufb01ned because it depends on the order in which calls happen. This problem is also known as \"data race\". \u2022 With transactions, Firestore updates a value in a single step because all the operations are guaranteed to be executed together (like if they were an unique method call). FirebaseFirestore.instance.runTransaction((transaction) async { final secureSnapshot = await transaction.get(docSnapshot.reference); final currValue = secureSnapshot.get(\"age\") as int; Flutter Complete Reference 622",
  ". Using Firebase with Flutter transaction.update(secureSnapshot.reference, { \"age\": currValue +  }); }); In this case, get() and update() are executed together like if they were a single call. There won\u2019t be data race problems. A transaction is generally made up of a series of get() followed by a series of delete(), set() or update() calls. When it fails, an exception is thrown and no data are written in the database. A batch instead is basically a transaction in which you don\u2019t need to call get() to read data. Future<void> deleteDocuments() { final batch = FirebaseFirestore.instance.batch(); final langs = await FirebaseFirestore.instance .collection(\"languages\") .get(); langs.documents.forEach((document) { batch.delete(document.reference); }); return batch.commit(); } This batch deletes all the documents inside the \"languages\" collection in a single operation. The gist is the same as transactions (the delete()s are executed all together like if they were a single call), but no read operations happen in between (only delete(), set() or update()). .3 Monetizing your apps with AdMob Google has two main platforms to give you money in change of showing ad banners: AdSense, for the web world, and AdMob, for the mobile world. Giving a detailed explanation on how they work and the techniques to maximize the earnings are out of the scope of this book. However, we can give you a general overview of the system from a practical point of view. . The main requirement is an active Google account (and thus a Gmail email) which will be linked to Adsense. Before starting monetizing your websites and/or mobile apps, there\u2019s the need to submit a website or a YouTube channel to the Adsense team. They need to approve it because not every product is eligible for monetization. Flutter Complete Reference 623",
  ". Using Firebase with Flutter When your account will be approved, you will be able to start placing ads in your products and receive money back according to views of banners, clicks and many other factors. Without an approved account, there\u2019s absolutely no way to show ads. We suggest you to do the following: (a) If you have a YouTube channel, you can submit it to the AdSense team. If it meets some speci\ufb01c criteria you can further investigate in the o\ufb03cial website , your account will be approved. (b) If you have a website, you can submit the link to the AdSense team and they\u2019ll review it. If it meets their speci\ufb01c approval criteria, your website will be accepted and your account will be validated. Check their resources page 6 to see how you can improve a website to raise the chances of being approved. Once you get an approved account, you got most of the work done. Generally the approval phase is the longest one as it requires some technical time and not every website might be accepted at the \ufb01rst try. You might have various improvements to do before having success. . When developing mobile apps you have to deal with the AdMob platform, which is inte- grated in the Flutter environment. You need to have a validated AdSense account in order to use AdMob because the two services are linked together. Even if they have two di\ufb00erent names, AdSense is still the \"main provider\". From now on, we assume that you have a veri\ufb01ed AdSense account and thus you\u2019re able to properly show ads and receive money. Activating an AdMob account is immediate because it\u2019s directly linked to AdSense so both work together. 5https://www.youtube.com/account_monetization?nv= 6https://www.google.com/adsense/start/resources/ Flutter Complete Reference 624",
  ". Using Firebase with Flutter ..1 Ad banners Let\u2019s say you have an app published in the o\ufb03cial stores for Android and iOS, or at least one of them. To get started, login with your veri\ufb01ed account at AdMob and register your product in order to let Google know it has to start distributing ads for your app. . On the home page, look at the right and click on \"App\": a popup menu appears and click on \"Add app\" at the bottom. If your app has already been published in the App store or in the Play store choose Yes and search it. If you\u2019ve just published your app in the stores, you might not be able to see it at \ufb01rst but it\u2019s normal; just wait up to 24 hours and then try again. Google needs some time to index the apps in the stores and refresh its databases. . Click on \"Create ad unit\" and select \"Banner\". The name you\u2019re asked to give in only used internally by AdMob to label a banner so that you can easily \ufb01nd it among the others. Once saved, you\u2019ll arrive at this point: These two codes are very important and they should be kept in a secure place. App ID and unit ID are used in both Android and iOS to identify your account and show the ads; Flutter Complete Reference 625",
  ". Using Firebase with Flutter don\u2019t expose them to the public! Create a new Flutter project making sure is has support for AndroidX (it should be enabled by default, don\u2019t untick it). Be sure to also setup a new Firestore project to download the .json con\ufb01guration \ufb01les as explained in the installation guide. If your app is running on Android devices, open the AndroidManifest.xml \ufb01le and add this line inside the <application> tag: <meta-data android:name=\"com.google.android.gms.ads.APPLICATION_ID\" android:value=\"ca-app-pub-################~##########\"/> The long code starting with ca-app-pub and containing a tilde is the app ID we obtained earlier from the website. Similarly, for iOS open the Info.plist \ufb01le and add the following entry to the list: <key>GADApplicationIdentifier</key> <string>ca-app-pub-################~##########</string> If you forget to add these settings, you app will crash at startup. Be sure to properly place both \ufb01les, google-services.json for Android and GoogleServices-Info.plist for iOS, following the installation guide. \u009f At the time of writing this book, there isn\u2019t a Flutter widget to display ads. You can\u2019t freely put them where you want, they\u2019re just shown \"in front\" of your app using platform-speci\ufb01c code. The o\ufb03cial GitHub 7 page of the FlutterFire project states that, in the Future, the \ufb01rebase_admob package will be improved with a dedicated Flutter widget. At this point the setup is over and it\u2019s time to start using \ufb01rebase_admob. An ad banner is NOT a widget and thus you can\u2019t freely decide to put it wherever you want. It\u2019s always placed \"in front\" of you app: there\u2019s no possibility to control this behavior so the best thing to do is placing it at the bottom. 7https://github.com/\ufb01rebaseextended/\ufb02utter\ufb01re Flutter Complete Reference 626",
  ". Using Firebase with Flutter On the right you see how the UI would look if we didn\u2019t add any spacing; the banner stays in front of the whole app and it covers some contents. On the left we\u2019ve solved the problem using the Padding widget. Basically it creates a gap from the bottom of the screen equal to the banner\u2019s height, which is \ufb01xed: \u2022 AdSize.banner is 320x50 (where the height is ); \u2022 AdSize.largeBanner is 320x100; \u2022 AdSize.mediumRectangle is 300x250; \u2022 AdSize.fullBanner is 468x60; \u2022 AdSize.leaderboard is 728x90; \u2022 AdSize.smartBanner the Mobile Ads SDK adjusts at runtime the width and the height but this is hard to handle. If you want to be sure that the dimensions of the banners are always under your control, which is probably a good idea, don\u2019t use a smart banner. The AdSize.banner is the shortest and least intrusive from an user-perspective while AdSize.large and AdSize.full are intrusive. Here\u2019s how you can setup your app: . The Firebase AdMob service requires startup initialization in order to show ad banners so we\u2019re going to create a StatefulWidget. You should make the initialization in the root widget so that it\u2019s executed only once (at startup) and not repeatedly. We\u2019re going to use a FutureBuilder<T> following the classic pattern. void main() => runApp(const DemoApp()); Flutter Complete Reference 627",
  ". Using Firebase with Flutter class DemoApp extends StatefulWidget { const DemoApp(); @override _DemoAppState createState() => _DemoAppState(); } class _DemoAppState extends State<DemoApp> { late final Future<bool> initializer; Future<bool> loadAds(BannerAd banner) async { await FirebaseAdMob.instance.initialize( appId: \"ca-app-pub-################~##########\" ); await banner.load(); return banner.show(); } @override void initState() { super.initState(); initializer = loadAds( BannerAd( adUnitId: \"ca-app-pub-################/##########\", size: AdSize.banner, ) ); } @override Widget build(BuildContext context) => FutureBuilder<bool>(...); } If you forget to call initialize() your app will crash at startup, even if the .json con\ufb01gu- ration \ufb01le is at the correct place. It\u2019s also important calling load() before show() otherwise the ad might not appear. Flutter Complete Reference 628",
  ". Using Firebase with Flutter . In the same \ufb01le, create a package private widget which is going to contain the body of the app with a small gap at the bottom. In this way we can use a constant constructor (const _AppBody()) in the FutureBuilder<void> rather than working with Padding() which cannot be constant. void main() => runApp(DemoApp()); class DemoApp extends StatefulWidget { ... } class _DemoAppState extends State<DemoApp> { ... } class _AppBody extends StatelessWidget { const _AppBody(); @override Widget build(BuildContext context) { return Padding( padding: EdgeInsets.only( bottom: AdSize.banner.height.toDouble() ), child: MaterialApp(...), ); } } Thanks to Padding, your entire app is visible because it has a bottom padding which gives enough space to the ad to show. The \ufb01nal result will look like this: Flutter Complete Reference 629",
  ". Using Firebase with Flutter . We can now use a FutureBuilder<void> and always return widgets with constant con- structors. class _DemoAppState extends State<DemoApp> with AdBanner { late final Future<bool> initializer; Future<bool> loadAds(BannerAd banner) async {...} @override void initState() {...} @override Widget build(BuildContext context) => FutureBuilder<bool>( future: initializer, builder: (context, snapshot) { if (snapshot.hasError) { return const ErrorWidget(); } if (snapshot.connectionState == ConnectionState.done) { return const _AppBody(); } return const Center( child: CircularProgressIndicator(), ); } ); } Alternatively, you could remove the progress indicator and immediately show the app. In this case, simply use const _AppBody() as default fallback and only handle errors. Ads will still appear at the bottom but later. FutureBuilder<bool>( future: initializer, builder: (context, snapshot) { if (snapshot.hasError) { return const ErrorWidget(); Flutter Complete Reference 630",
  ". Using Firebase with Flutter } return const _AppBody(); } ); While this solution works, you might not like having a black background behind the banner or so much \"empty\" space at the bottom. A better solution would involve the usage of a Column to contain the app and a Container to style the \"empty space\". class _AppBody extends StatelessWidget { const _AppBody(); @override Widget build(BuildContext context) { return Column( children: <Widget>[ Expanded( // The app itself child: MaterialApp(...), ), // What's behind the banner LayoutBuilder( builder: (context, constraints) { return Container( width: constraints.maxWidth, height: AdSize.banner.height.toDouble(), decoration: const BoxDecoration(...), ); }, ), ], ); } Thanks to Expanded we\u2019re guaranteed that our app will cover as much space as possible. At the bottom there is a Container covering the entire width and it has the same height as the banner; it can be styled via decoration as you prefer. Flutter Complete Reference 631",
  ". Using Firebase with Flutter Instead of having black spaces behind the banner, now there\u2019s a white background which \ufb01ts better with the style of the UI. It might require some work but an Image() or SvgPicture could end up with am even better result. ..2 Rewarded video ads This kind of advertising is di\ufb00erent from banners as it\u2019s not always visible. Video rewards are used very often in mobile games: the user is asked to watch a video until the end and, as a prize, in-game credits are added. Here\u2019s a common execution \ufb02ow: \u2022 The player taps a button to get coins/gems/credits; \u2022 a full screen ad video appears and it generally lasts a few seconds (it can of course be manually closed); \u2022 if the video has been watched until the end, the player gets a reward. Video ads don\u2019t need to be initialized only once because internally they implement the singleton pattern. Nevertheless, it\u2019s still a good practice initializing them only once in the same way as banners, so we\u2019re going to use the classic FutureBuilder<T> pattern: late final Future<bool> initializer; Future<bool> loadRewardedVideo() async { await RewardedVideoAd.instance.load( adUnitId: \"ca-app-pub-################/##########\" ); Flutter Complete Reference 632",
  ". Using Firebase with Flutter RewardedVideoAd.instance.listener = _listener; } @override void initState() { super.initState(); initializer = loadRewardedVideo(); } void _listener(RewardedVideoAdEvent event, { String? rewardType, required int rewardAmount }) { if (event == RewardedVideoAdEvent.rewarded) { gamePoints.add(); gameCredits.increase(rewardAmount); } } The listener of a RewardedVideoAd is called every time the user interacts with a video ad. Using event we can check if the video has been watched until the end and decide whether it\u2019s the case or not to give a prize. RaisedButton( child: const Text(\"Show video ad\"), onPressed: () => RewardedVideoAd.instance.show(), ) To display the video, you can call show everywhere in your app and the listener associated to the RewardedVideoAdEvent will be triggered. The ad appears in front of your app covering it almost completely but it will always have a close button, generally in the top-right corner. .4 Flutter ML Kit Face detection, image labelling, text parsing and machine learning might sound hard to imple- ment due to the complexity of the topic and the actual skills required. With Flutter\u2019s ML Vision plugin realizing all these tasks becomes very easy because almost all of the complex work is pow- Flutter Complete Reference 633",
  ". Using Firebase with Flutter ered by Firebase. \u009f Firebase\u2019s ML Kit is a powerful collection of machine learning modules ready for you to use. They\u2019re well-integrated in the Flutter environment thanks to the o\ufb03cial plugins made by the Google team so you should de\ufb01nitely give them a try. ..1 Detecting faces In this example we\u2019re going to create a face detection app that takes an image from our device\u2019s gallery and detects if there are one or more humans portrayed on it. It will be also able to detect where faces are with additional information (whether the person is smiling or not, for example). We\u2019re going to need two plugins: \u2022 image_picker: the o\ufb03cial Flutter plugin for picking images from the gallery or any other available location in the device; \u2022 \ufb01rebase_ml_vision: a very powerful plugin that uses the ML (Machine Learning) kit from Firebase8 The app is made up of a single page in which the user is asked to select an image from the gallery, but it could have been taken from the camera or anywhere else. The Firebase plugin will detect any human face, head rotation, smiles and some red rectangles will surround the results (if any). The app will look like this: 8https://pub.dev/packages/\ufb01rebase_ml_vision Flutter Complete Reference 634",
  ". Using Firebase with Flutter As always, be sure to install google-services.json and/or the GoogleServices-Info.plist con\ufb01guration \ufb01les as we\u2019ve explained in the installation guide at the beginning of the section. . Let\u2019s start with the creation of a class that is just going to contain the results of the face detection process. Since Dart cannot return multiple values from a function, we need to create a \"wrapper\" to expose more than a single value: import \"dart:ui\" as ui; class FaceDetectorData { final List<Face> faces; final ui.Image image; const FaceDetectorData(this.faces, this.image); } Note that we\u2019re using ui.Image rather than Image because the canvas (more on it later) understands a di\ufb00erent kind of image format. The type Face is given by the ML Kit package: it contains data about the detected face. . Now we need a model class which uses the ML vision plugin to detect faces in a given image. We\u2019re hard-coding the size of the image to keep the example simple, but in general you should handle the sizes of the images dynamically according to the screen\u2019s dimensions. Flutter Complete Reference 635",
  ". Using Firebase with Flutter class FaceDetectorModel { const FaceDetectorModel(); Future<FaceDetectorData> detectFaces() async { // Choose the image final picker = ImagePicker(); final imageFile = await picker.getImage( source: ImageSource.gallery, maxWidth: , maxHeight: , ); // Load the image and setup the Vision kit final file = File(imageFile.path); final image = FirebaseVisionImage.fromFile(file); final detector = FirebaseVision.instance.faceDetector(); // Process data final faces = await detector.processImage(image); final canvasImage = await _decodeImage(file); return FaceDetectorData(faces, canvasImage); } Future<ui.Image> _decodeImage(File file) async {...} } Calling the getImage() method, your device opens the gallery and lets you select one of the available images returning a reference to the chosen \ufb01le. You could have also taken the image directly from the camera: source: ImageSource.camera, The processImage() method looks for faces in the given image and returns a list of Face objects. It contains a lot of useful information we will explore later. As you can see, processing images and detecting faces using a machine learning library takes very few lines of code. Future<ui.Image> _decodeImage(File file) async { // 'file' is a reference to the image we picked earlier from the // gallery. Flutter Complete Reference 636",
  ". Using Firebase with Flutter final rawFile = await file.readAsBytes(); // The 'Codec' class is used by the Flutter engine and it shouldn't // be directly instantiated. Instead, it can be properly created // with the 'instantiateImageCodec' final Codec codec = await instantiateImageCodec(rawFile); // 'FrameInfo' contains information for a single frame of an // animation. We need it to extract an 'ui.Image' object which // is a low level representation of an image final FrameInfo frameInfo = await codec.getNextFrame(); // Finally... the object we need! return frameInfo.image; } This function does some low-level data manipulations. In order to show images on the canvas and draw on it, we need to return an instance of ui.Image. This is how you \"load\" images into a canvas. The code is complicated but in practice you\u2019ll never use those methods so don\u2019t worry too much about them. . Now that Firebase models are ready, we can start working on the UI. We\u2019re using provider to expose a boolean variable which will decide whether it\u2019s the case to show the image picker or the result widget with the detected faces. class FaceProvider with ChangeNotifier { bool _showDetector = false; bool get isDetectorVisible => _showDetector; void setDetectorVisible(bool isVisible) { _showDetector = isVisible; notifyListeners(); } } The isDetectorVisible getter returns false by default because when the app loads, we want the user to click on the \"Detect faces\" button to select an image from the gallery. Flutter Complete Reference 637",
  ". Using Firebase with Flutter With this technique we\u2019re able to easily change the visible widget setting true or false in the model class, exposed with a provider. In particular, a Consumer<T> will read the value and will decide which widget to show. Consumer<FaceProvider>( builder: (context, faceDetector, _) { if (faceDetector.isDetectorVisible) { // Shows the image with the detected faces return const DetectFacesFromImage(); } // Shows the button 'Detect faces' and opens the gallery return const DetectionImgPicker(); }, ) Flutter Complete Reference 638",
  ". Using Firebase with Flutter . The DetectionImgPicker widget is nothing special as it\u2019s just a Wrap() containing a button and an icon. We need a Consumer<FaceProvider> to move from the currently visible widget (image picker) to the result page widget (detected faces). Consumer<FaceProvider>( builder: (context, faceDetector, _) { return RaisedButton( child: const Text(\"Detect faces\"), onPressed: () => faceDetector.setDetectorVisible(true), ); }, ), As we\u2019ve explained earlier, changing the value to true, the currently visible widget becomes DetectionImgPicker instead of DetectFacesFromImage . The DetectFacesFromImage widget has to be stateful because there\u2019s a Future<T> to await and thus we\u2019re going to implement the classic FutureBuilder<T> pattern. class _DetectFacesFromImageState extends State<DetectFacesFromImage> { late final Future<FaceDetectorData> _faces; final _model = FaceDetectorModel(); @override void initState() { super.initState(); _faces = _model.detectFaces(); } @override Widget build(BuildContext context) { return FutureBuilder<FaceDetectorData>( future: _faces, builder: (context, facesList) { if (facesList.hasData) {...} return const Center( child: CircularProgressIndicator(), Flutter Complete Reference 639",
  ". Using Firebase with Flutter ); }, ); } } The hasData property becomes true when the plugin has successfully decoded the image. We want to show the original image and, in addition, a series of red rectangles surrounding any face recognized; in order to do so, we need a CustomPaint widget. Wrap( children: <Widget>[ SizedBox( width: , height: , child: CustomPaint( painter: RectanglePainter( facesPositions: data.faces, selectedImage: data.images, ), ), ), Consumer<FaceProvider>( builder: (context, detector, _) { return RaisedButton( child: const Text(\"New detection\"), onPressed: () => detector.setDetectorVisible(false), ); }, ), ], ), The button at the bottom sets isDetectorVisible to false to come back to the image selection widget. In the next section we\u2019re exploring in detail the RectanglePainter class. Flutter Complete Reference 640",
  ". Using Firebase with Flutter ...1 CustomPainter and the canvas A CustomPainter exposes a canvas in which you can draw lines, shapes or any kind of custom painting. While Flutter is very powerful and customizable, there could be certain cases in which very sophisticated paintings are required for a particular UI so it\u2019s the case to use a painter. class RectanglePainter extends CustomPainter { @override void paint(Canvas canvas, Size size) { ... } @override bool shouldRepaint(RectanglePainter oldDelegate) { ... } } If you want to implement a painter, which is NOT a widget, you have to subclass CustomPainter and override its two methods. It can be seen as a low level tool to freely draw on the UI. \u2022 the paint() method exposes a canvas in which you can paint anything. All the drawing commands should occur within the bounds given by the size object to avoid undesired misalignments of the shapes. Some popular methods are: canvas.drawRect(...); // draws a rectangle canvas.drawCircle(...); // draws a circle canvas.drawOval(...); // draws an oval canvas.drawPath(...); // for B\u00e9zier curves // and much much more... Check out the o\ufb03cial documentation of Canvas 9 to see the painting methods you can use. \u2022 the shouldRepaint() method controls when the painter should redraw. If your painter has no mutable properties, you can safely return false otherwise there will be the need to setup a proper logic. Given a picture, we want to draw red rectangles around the faces that have been detected. We already have the coordinates because they\u2019re inside the Face objects so we\u2019re ready to paint. . Other than drawing the rectangles, we also want the original image to be in the background. A canvas doesn\u2019t understand the Image type given by Flutter but instead it works with the Image class of the 'dart:ui' package. import 'dart:ui' as ui show Image; 9https://api.\ufb02utter.dev/\ufb02utter/dart-ui/Canvas-class.html Flutter Complete Reference 641",
  ". Using Firebase with Flutter We need to import \"dart:ui\" and give it an alias just to be sure to not get confused by the names. Inside class FaceDetectorModel we declared the canvasImage property which exactly returns an instance of ui.Image; it\u2019s created right after the image is selected from the gallery. class RectanglePainter extends CustomPainter { final List<Face> facesPositions; final ui.Image selectedImage; const RectanglePainter({ required this.facesPositions, required this.selectedImage }); // paint and shouldRepaint... } Here we have selectedImage, used as background, and facesPositions, which tells us how many rectangles will be painted and their exact positions in the canvas. . This class will paint a some rectangles according to the contents of selectedImage and the items of the list could potentially change every time the instance is used. For this reason we need to override shouldRepaint with a logic: @override bool shouldRepaint(RectanglePainter oldDelegate) => selectedImage != oldDelegate.selectedImage || facesPositions != oldDelegate.facesPositions; If the class didn\u2019t depend on mutable external parameters, we could have overridden this method to simply return false. In the example below we have a class with no references to external dependencies and the drawing is always the same, so it\u2019s a \"static piece\" that doesn\u2019t need to be repainted. class MyPainter extends CustomPainter { const RectanglePainter(); @override void paint(Canvas canvas, Size size) { canvas.drawArc(...); } Flutter Complete Reference 642",
  ". Using Firebase with Flutter @override bool shouldRepaint(MyPainter oldDelegate) => false; } . Let\u2019s now see how we can actually draw red rectangles around the detected faces, if any. Every time we call a drawX function we need to pass a Paint object which describes how the \ufb01gure has to look like. static final Paint _painter = Paint() ..style = PaintingStyle.stroke // . ..strokeWidth = . // . ..color = Colors.redAccent; // . We\u2019ve decided to create a red () shape with no background color, with visible borders () and with a certain thickness (). Instead, if we used PaintingStyle.fill the shape would have been entirely \ufb01lled with the given color. @override void paint(Canvas canvas, Size size) { canvas.drawImage(selectedImage, Offset.zero, Paint()); for(final face in facesPositions) { final coords = face.boundingBox; final rect = Rect.fromLTRB( coords.left, coords.top, coords.right, coords.bottom ); canvas.drawRect(rect, _painter); } } The Rect class represents a 2D rectangle whose coordinates are relative to a certain origin. With drawRect() we can exactly tell the engine where the rectangle has to be painted in the canvas. Since each Face object contains top, left, right, and botton o\ufb00sets we can easily build a Rect with no extra e\ufb00ort. Flutter Complete Reference 643",
  ". Using Firebase with Flutter Those red rectangles are drawn by canvas.drawRect() and their position/sizes have been calculated by the Firebase plugin earlier. Since a subclass of CustomPainter can\u2019t be directly used in the build() method, there\u2019s the need to wrap it into a widget called CustomPaint. The painter parameter passes an instance of a CustomPainter telling the widget what and how has to be painted. // Inside the 'DetectFacesFromImage' widget CustomPaint( painter: RectanglePainter( facesPositions: facesList.data, selectedImage: _model.canvasImage ), ), ..2 Firebase vision kit If you visit the o\ufb03cial pub page of the \ufb01rebase_ml_vision package 10 you\u2019ll \ufb01nd many other useful detectors for your apps. They all can be used in the same way: you could organize the code in order to favor reusability and maintainability as much as possible. \u2022 class BarcodeDetector. Detector for barcode scanning on an input image. 10https://pub.dev/packages/\ufb01rebase_ml_vision Flutter Complete Reference 644",
  ". Using Firebase with Flutter final file = FirebaseVisionImage.fromFile(...); final barCodes = await FirebaseVision.instance .barcodeDetector() .detectInImage(file); \u2022 class ImageLabeler. Do you have an image of a family in Paris with the Ei\ufb00el tower in the background on a sunny day? This detector will recognize people, things, places and much more with a certain con\ufb01dence degree. final file = FirebaseVisionImage.fromFile(...); final labels = await FirebaseVision.instance .imageLabeler() .processImage(file); Each label has a score indicating the con\ufb01dence the ML model has in its relevance. In other words, each label has a number indicating how close the algorithm is to the real meaning of the image. \u2022 class TextRecognizer. Detector for performing optical character recognition (OCR) on an input image. It can output the whole text on a single string or divide it in multiple blocks. final file = FirebaseVisionImage.fromFile(...); final textBlocks = await FirebaseVision.instance .textRecognizer() .processImage(file); If you \ufb01nd these packages useful, you should keep an eye on them because the Flutter team is looking forward into more integration with Firebase ML modules. .5 Push noti\ufb01cations with FCM Push noti\ufb01cations are messages sent outside of the app\u2019s UI, even when it\u2019s closed, to notify the user about something. They generally appear at the top with a small icon on the left and a short body which describes the purpose of the alert. Firebase is the starring again because it\u2019s respon- sible of dispatching noti\ufb01cations on mobile devices. There\u2019s a minimal setup for Android: . Download, as usual, the google-services.json con\ufb01guration following the installation guide at the beginning of the chapter. . In order to be able to react to the user\u2019s tap on the noti\ufb01cation bar (at the top of your Flutter Complete Reference 645",
  ". Using Firebase with Flutter device) be sure to add the following lines in the manifest \ufb01le. <intent-filter> <action android:name=\"FLUTTER_NOTIFICATION_CLICK\" /> <category android:name=\"android.intent.category.DEFAULT\" /> </intent-filter> Of course, push noti\ufb01cations for iOS are managed by Firebase too and you\u2019re asked to do the following setup as well: . You need to generate a certi\ufb01cate for your app but it\u2019s quite easy to do: (a) Open your developer account page and go to \"Certi\ufb01cates, Identi\ufb01ers and Pro\ufb01les\". Click on Keys and add a new one by giving a custom description. (b) Select the checkbox next to \"Apple Push Noti\ufb01cation service\" (c) Con\ufb01rm your selection and download the \ufb01le. Be sure to not lose it because it\u2019s a one-time download that cannot be retrieved later! . Place the GoogleService-Info.plist following the installation guide at the beginning of the chapter, unless you haven\u2019t already done this step. . Still on Xcode, select Runner and inside \"Capabilities\" turn on push noti\ufb01cations, back- ground modes, background fetch and remote noti\ufb01cations. . Check the pub.dev package page of \ufb01rebase_messaging to see how to upload the APN certi\ufb01cate and enabling the noti\ufb01cation manager via Objective-C/Swift. After this long preparation, you\u2019re \ufb01nally ready to write some Dart code to make the noti\ufb01cation work. Add firebase_messaging as dependency and create a dedicated \ufb01le, which could be called fcm_setup.dart, containing the logic to send requests to the FCM cloud service. class FirebasePushManager { FirebasePushManager._(); // A singleton static final _instance = FirebasePushManager._(); factory FirebasePushManager() => _instance; bool _initialized = false; Future<void> init() async { Flutter Complete Reference 646",
  ". Using Firebase with Flutter if (!_initialized) { // Note that 'FirebaseMessaging' is a singleton as well. We // create 'firebaseMsg' just for conveniency final firebaseMsg = FirebaseMessaging(); // This appears only on iOS but it's really important. await firebaseMsg.requestNotificationPermissions(); firebaseMsg.configure(...); _initialized = true; } } } This class interacts with FCM (Firebase Cloum Messaging) to send and receive push noti\ufb01- cations. The init() method should be called at startup, maybe in the way we\u2019ve suggested in appendix B.. After having called init(), your device will be able to successfully receive push noti\ufb01cations. In addition, you probably might \ufb01nd calling another method very useful as well: // still inside the 'init()' method await firebaseMsg.requestNotificationPermissions(); firebaseMsg.configure( onLaunch: (Map<String, dynamic> data) { ... }, onMessage: (Map<String, dynamic> data) { ... }, onResume: (Map<String, dynamic> data) { ... }, ); When a push noti\ufb01cation is received, other than a message and the icon to show in the device\u2019s tray icon, it can also carry some data. The Map<String, dynamic> data parameter represents the payload coming together with the noti\ufb01cation: \u2022 the onMessage callback is triggered when the app is in the foreground, which is practically when \"the app is opened\" (the user can interact with it); \u2022 the onLaunch and onResume callbacks are called when the app is closed or it\u2019s in the background. When you see a push noti\ufb01cation at the top of your device, generally you want to be able to tap on it and open the app. More speci\ufb01cally, it would be even better if you were redirected to a Flutter Complete Reference 647",
  ". Using Firebase with Flutter speci\ufb01c route of your app when tapping on the noti\ufb01cation. ..1 Handling push noti\ufb01cations The Map<String, dynamic> data parameter contains the additional information received to- gether with the noti\ufb01cation. In the next section, we\u2019re going to see how to add this kind of data. In the init() method, we start by con\ufb01guring this: firebaseMsg.configure( onMessage: _showAlert, onLaunch: _navigateToRoute, onResume: _navigateToRoute, ); Since onMessage is triggered while the user is interacting with the app, moving suddenly to a new page might be confusing and \"intrusive\". For this reason, an alert dialog (or any other form of message) is better. Future<void> _showAlert(Map<String, dynamic> data) async { final author = data[\"author\"] as String; // Actually you should use 'showDialog' or 'showCupertinoDialog' // to nicely display a message to the user debugPrint(\"Notification sent by $author\"); } The onLaunch and onResume callbacks are triggered, respectively, when the app is closed or in the background and the noti\ufb01cation is tapped. A very common need is the following: the app is closed, a push noti\ufb01cation is received, the user taps on it and a speci\ufb01c route has to open. Future<void> _navigateToRoute(Map<String, dynamic> data) async { // When sending a notification, you add as payload the name of // the route to which you want to navigate. final routeName = data[\"route\"] as String; // Navigate to the route... but there's no context available! Navigator.of(context)?.pushNamed(routeName); } In this way, tapping on the noti\ufb01cation opens your app and moves to the given route. However, with our setup there\u2019s no BuildContext available because the method signature only has a Flutter Complete Reference 648",
  ". Using Firebase with Flutter Map<K,V>. You have two solutions: \u2022 change the signature and add a BuildContext context parameter but then you might still be in trouble passing a context; \u2022 use a GlobalKey and associate to it a navigatorKey in your material or cupertino root widget. In order to do this, you could create a new key in RouteGenerator as we\u2019ve seen in .: class RouteGenerator { RouteGenerator._(); // Expose a key to use a navigator without a context static final key = GlobalKey<NavigatorState>(); state Route<dynamic> generateRoute(RouteSettings settings) {...} } It can now be attached to the navigator in the root widget: MaterialApp( onGenerateRoute: RouteGenerator.generateRoute, navigatorKey: RouteGenerator.key, ) There\u2019s now the possibility to navigate among routes without having a context available. Thanks to the key, we can now use this code so that when the push noti\ufb01cation is tapped, the given route is opened. Future<void> _navigateToRoute(Map<String, dynamic> data) async { // Name of the route received from the payload final routeName = data[\"route\"] as String; // Navigate to the route without having a context RouteGenerator.key.currentState?.pushNamed(routeName); } ..2 Sending push noti\ufb01cations Push noti\ufb01cations can be sent very easily in the online Firebase console. Just open it, select your project, click on \"Cloud Messaging\" and create a new noti\ufb01cation. Give it a title, a body and Flutter Complete Reference 649",
  ". Using Firebase with Flutter the URL of an image that will be displayed along with the noti\ufb01cation. You can schedule when the noti\ufb01cation should be sent, the audience, give it an ID and much more. In the \ufb01nal step, you have the possibility to insert some optional custom data \ufb01elds: they\u2019re the payload of the noti\ufb01cation. This is what Flutter will store as Map<String, dynamic> in the callbacks you setup in the configure() method. You must use the click_action: FLUTTER_NOTIFICATION_CLICK value in order to be able to correctly receive data and react to tap events. // The \"route\" param we set earlier as payload is the \"route\" you see here Flutter Complete Reference 650",
  ". Using Firebase with Flutter // in the map. It's the landing page to be opened when the notification is // tapped. final routeName = data[\"route\"] as String; The console is very convenient but very likely you\u2019ll also need to sent push noti\ufb01cations via Flutter. That\u2019s not a problem at all because it\u2019s just a matter of making a POST request: Future<void> sendPush(String title, String message) async { final token = await FirebaseMessaging().getToken(); final jsonBody = <String, dynamic>{ \"notification\": <String, dynamic>{ \"title\": title, \"body\": message, }, \"data\": <String, dynamic>{ \"click_action\": \"FLUTTER_NOTIFICATION_CLICK\", \"route\": \"your_route_name_if_needed\", }, \"to\": token, }; await Dio().post(\"https://fcm.googleapis.com/fcm/send\", data: jsonBody, options: RequestOptions( headers: { \"Authorization\": \"key=your_fcm_key\", \"Content-Type\": \"application/json\" } ) ); } We\u2019ve kept the code simple for the sake of the example but it\u2019d be better if you moved Dio() into a static variable to cache the con\ufb01gurations. Note that the \"to\" \ufb01eld has to be assigned with getToken() in order to properly send the noti\ufb01cation. \"Authorization\": \"key=your_fcm_key\", In order to get the key, you need to open the Firebase console and go to the settings. Once there, Flutter Complete Reference 651",
  ". Using Firebase with Flutter choose the \"Cloud Messaging\" tab and copy/paste the provided key. It\u2019s used by Firebase to identify your app so that it knows where the noti\ufb01cation has to be sent. Thanks to topics, you can send push noti\ufb01cations to speci\ufb01c groups of devices or simply broadcast them to everyone. Let\u2019s make a very simple example to get the idea of how topic messaging works on Firebase . Pretend you created an app for your friends to invite them at your home parties. Future<void> sendPush(String title, String message) async { final token = await FirebaseMessaging().getToken(); final jsonBody = <String, dynamic>{ \"notification\": <String, dynamic>{ ... }, \"data\": <String, dynamic>{ ... }, \"to\": token, }; await Dio().post(...) } This is not very useful because we\u2019re using \"to\" to send the noti\ufb01cation to a speci\ufb01c device. Thanks to topic messaging, you can send a noti\ufb01cation to everyone or only to a small group of people. If you wanted to invite your best friends only to the party, the request would be a bit di\ufb00erent: Future<void> sendPush(String title, String message) async { final jsonBody = <String, dynamic>{ \"notification\": <String, dynamic>{ ... }, \"data\": <String, dynamic>{ ... }, \"condition\": \"'best_friends' in topics\", }; 11https://\ufb01rebase.google.com/docs/cloud-messaging/android/topic-messaging Flutter Complete Reference 652",
  ". Using Firebase with Flutter await Dio().post(...) } Using \"condition\" instead of \"to\" you can send a noti\ufb01cation only to a particular group of people, not to speci\ufb01c devices. Client side, your best friends\u2019 app must be registered to the \"best_friends\" FCM topic. You could make the subscription in a settings page or anywhere else: it\u2019s just a method to be awaited. await firebaseMsg.subscribeToTopic(\"best_friends\"); Calling subscribeToTopic() the device is able to receive noti\ufb01cations sent to the given topic. Devices that didn\u2019t subscribe, won\u2019t see the noti\ufb01cation. Actually, a device can subscribe to one or more topics. \"condition\": \"'best_friends' in topics && 'parents' in topics\", You can also send a noti\ufb01cation to multiple groups combining topics with && (and) or || (or). In the above example, you\u2019re inviting your best friends and your parents to the party. In sum- mary: \u2022 Using the \"to\" con\ufb01guration, push noti\ufb01cations are sent to a single device (or group of IDs). \u2022 Using the \"condition\" con\ufb01guration, push noti\ufb01cations are sent only to devices that sub- scribed to a certain topic(s). You can create the \"all\" topic to send noti\ufb01cations to everyone. \u2022 A single client can subscribe to multiple topics. Generally, the \"condition\" approach is the most \ufb02exible because it doesn\u2019t rely on ids or speci\ufb01c device-related groups. .6 Authenticating with Firebase Nowadays \"register\" and \"login\" actions are very common not only in applications, but also in websites and desktop programs. Generally you\u2019re asked to register with a valid email address to which a veri\ufb01cation code will be sent. Thanks to Firebase, you can easily do the following: \u2022 register an user with email and password; \u2022 send a veri\ufb01cation code via email to con\ufb01rm the address; \u2022 authenticate via Google account, Facebook or other providers; Flutter Complete Reference 653",
  ". Using Firebase with Flutter \u2022 send veri\ufb01cation codes via SMS, phone call and much more. We\u2019re going to show you how to create a \ufb02exible architecture that supports multiple kinds of authentication providers (actually not necessarily tied to Firebase). The example shows how to work with email and password registration/authentication. . As always, if you haven\u2019t already, follow the installation guide at the beginning of the chapter. Download the .json con\ufb01guration \ufb01les and place them in the correct folder. . Install the o\ufb03cial \"\ufb01rebase_auth\" 12 plugin and be sure to setup the Android build depen- dencies. Add the following lines at /android/build.gradle: dependencies { classpath 'com.android.tools.build:gradle:..' classpath 'com.google.gms:google-services:..' } . In order to enable email/password authentication on Firebase, we need to open the online console and navigate to the \"Authentication\" tab. From there, there\u2019s the need to enable the provider we want to use. Even if they\u2019re not shown in the above picture, you can also enable other sign-in providers such as GitHub, Facebook, Twitter, Google, Microsoft and much more. Firebase can even 12https://pub.dev/packages/\ufb01rebase_auth Flutter Complete Reference 654",
  ". Using Firebase with Flutter make a phone call for a direct phone veri\ufb01cation. . We\u2019re now going to use the \"Strategy pattern\" to create a \ufb02exible architecture. Our example is going to register users with email and password but in the future you might want to add more authentication strategies. For this reason, we create an abstract class UserRepository with basic authentication methods: // Interface abstract class UserRepository<T> { Future<T> register(); Future<T> signIn(); Future<void> signOut(); } We\u2019re now going to implement this interface in /lib/models/auth/email.dart using the Firebase authentication service. Note that AuthResult comes from the \ufb01rebase_auth pack- age. class EmailUser implements UserRepository<AuthResult> { final String email; final String password; const UserRepository({ required this.email, required this.password, }); @override Future<AuthResult> register() { final auth = await FirebaseAuth.instance .createUserWithEmailAndPassword( email: email, password: password ); // We'll deal with this later // await auth.user.sendEmailVerification(); return auth; } @override Flutter Complete Reference 655",
  ". Using Firebase with Flutter Future<void> signIn() async => await FirebaseAuth.instance .signInWithEmailAndPassword( email: email, password: password ); @override Future<void> signOut() async => await FirebaseAuth.instance.signOut(); } Only a few lines of code are required since Firebase will automatically take care of both registration and login of the user. The code is self-explanatory because the class is really small (the library does basically everything). The AuthResult class contains data about the logged user which can be accessed and modi\ufb01ed in various ways: \u2022 changing the pro\ufb01le picture, \u2022 deleting the account, \u2022 changing credentials... The registration, if successful, automatically authenticates the user so no need to call signIn() later. If the password were too weak or the email were not valid, an excep- tion would be thrown. If you plan to add more authentication providers in the future, just create new concrete implementations of UserRepository<T>: // Inside lib/models/auth/email.dart class EmailUser implements UserRepository<AuthResult> { ... } // Inside lib/models/auth/facebook.dart class FacebookUser implements UserRepository<SomeFbObj> { ... } // Inside lib/models/auth/github.dart class GithubUser implements UserRepository<SomeGitObj> { ... } With this architecture you\u2019re on the good SOLID way! Firebase takes care of creating a secure authentication process with many important features such as email veri\ufb01cation and phone codes. If you had to make all of this by yourself, you\u2019d have a lot of work to do but Firebase is just here, ready to be used and it\u2019s very well integrated with Flutter Complete Reference 656",
  ". Using Firebase with Flutter Flutter. // Usage example of the EmailUser class try { final provider = EmailUser( email: \"hello@email.com\", password: \"_my_c0mpl3x_passw0rd_\" ); final user = await provider.register(); } on FirebaseAuthException catch (e) { if (e.code == 'weak-password') { print('Error: weak password'); } if (e.code == 'email-already-in-use') { print('Error: email already in use'); } } catch (e) { print(\"Whoops, something's gone wrong :(\"); } Authentication errors are exposed via FirebaseAuthException which internally has message, a textual description of the problem, and code, an unique error code. You can use a Stream<User> to subscribe to real-time authentication state changes: FirebaseAuth.instance .authStateChanges() .listen((User user) { if (user != null) { // signed in } else { // signed out } }); Similarly, there\u2019s also the userChanges() stream but it\u2019s more \"general purpose\" as it emits events about token refreshes and more. Remember that FirebaseAuth automatically persists the user\u2019s authentication state so that it will survive page reloads and app restarts. await FirebaseAuth.instance Flutter Complete Reference 657",
  ". Using Firebase with Flutter .setPersistence(Persistence.NONE); In other words, FirebaseAuth automatically stores your authentication state so that it will be available again even if the app is closed and reopened. If you don\u2019t like this default behavior, use setPersistence() at startup to disable state persistence. ..1 Authentication features When registering users via email and password, you might want to verify the existence of the given address with a veri\ufb01cation code. Firebase can send an email to the given address with a code; the user has to correctly con\ufb01rm it to validate the account. final auth = await FirebaseAuth.instance .createUserWithEmailAndPassword( email: email, password: password ); await auth.user.sendEmailVerification(); Once the user logged, you can check whether its email has been veri\ufb01ed or not and eventually de- cide to send a validation message. Generally, you should send the email right after the registration but regardless, sendEmailVerification() can be called anywhere on a User object. final user = FirebaseAuth.instance.currentUser; if (!user.emailVerified) { await user.sendEmailVerification(); } There\u2019s no need to sign-out the user and sign-in him again to refresh his email veri\ufb01cation status. You can create a form and ask for a code, so that the user can copy/paste it from the email. The veri\ufb01cation can happen immediately in the app with this method: Future<void> validateUser(String code) async { try { await auth.checkActionCode(code); await auth.applyActionCode(code); auth.currentUser.reload(); } on FirebaseAuthException catch (e) { Flutter Complete Reference 658",
  ". Using Firebase with Flutter if (e.code == 'invalid-action-code') { // wrong code... } } } The reload() method refreshes the status of the current user, if authenticated, and thus it also updates the value of emailVerified. Other than email and password registration, there are also other kinds of authentication strategies: \u2022 Your app might not need authentication but it could still require a way to uniquely identify visitors. For this purpose you can use anonymous sign-in, whose state is persisted on the device (like it happens for \"normal\" authentication): final credentials = await FirebaseAuth.instance.signInAnonymously(); You have to enable this feature in the Firebase console as well otherwise it won\u2019t work. Simply go in the \"Authorization\" page and enable the feature under this \"Sign-in method\" tab. \u2022 You could authenticate using an external provider, such as Google. In this case, the user will be asked to access with his Google credential rather than going with the classic Firebase authentication. // Authenticate with google and get the data back Flutter Complete Reference 659",
  ". Using Firebase with Flutter final googleUser = await GoogleSignIn().signIn(); final googleAuth = await googleUser.authentication; // Creation of a credential object for Firebase final googleCredential = GoogleAuthProvider.credential( accessToken: googleAuth.accessToken, idToken: googleAuth.idToken, ); // Sign in final credentials = await FirebaseAuth.instance .signInWithCredential(googleCredential); In a very similar way, you can also access with Facebook, Twitter and GitHub. The library also exposes classes to work with generic OAuth credentials and Recaptchas. Flutter Complete Reference   | Publishing packages and apps .1 Publishing packages on pub.dev As you already know, many developers around the world can contribute to Flutter\u2019s growth writ- ing packages and publishing them at https://pub.dev. It\u2019s like a big public repository in which you can \ufb01nd many packages for any platform (web, mobile or desktop). Are you looking for something not present in pub yet? You can be the \ufb01rst to publish it! \u009f We\u2019re working with Dart .10 and Flutter .., which are the latest versions at the time of writing this book. The code we\u2019re going to write will be \ufb01ne for future versions but we can\u2019t guarantee compatibility for Dart .8 and lower. In this section we\u2019re showing a step-by-step guide on how to publish a package, from its creation up to the release on the o\ufb03cial https://pub.dev repository. The package we\u2019re creating is called fraction since it\u2019s going to be a facility to work with mathematical fractions. You already know the minimum required building blocks to get started: . pubspec.yaml: describes the package with many info such as author, version, supported platforms, dependencies and so on. . lib: contains the Dart source code of your package. That\u2019s really all you need to create a simple package but it\u2019s not enough for production because we also need to implement testing, versioning and licensing. Instead of manually creating all the required \ufb01les from scratch, the flutter command line tools can create a template for us. $ flutter create --template=package fraction Running this command inside a folder, flutter prepares all the \ufb01les and the folders you need to Flutter Complete Reference 661",
  ". Publishing packages and apps create a package. Open lib/ and start coding. ..1 Creating the package You could create a single \ufb01le inside lib/ and throw all the code in there but it\u2019s not a good idea at all. When creating packages, there is a certain structure recommended by the o\ufb03cial documentation 1 you should follow (mostly for ease of use and consistency with other people\u2019s work). That\u2019s the template the command flutter create --template produced in your \ufb01le system and you shouldn\u2019t change it. In addition to the generated contents, we\u2019ve added something new inside lib/: . a \ufb01le with the same name as the package, in this case fraction.dart, which exports the public API. This makes sure that using our library will require only a single import statement. . a src/ folder containing the actual Dart source code of the package. The lib/fraction.dart is the \"heart\" of the package because it takes the various classes, located 1https://dart.dev/guides/libraries/create-library-packages Flutter Complete Reference 662",
  ". Publishing packages and apps in di\ufb00erent \ufb01les, and exposes them to the outside. By convention, any package should contain inside lib/ a Dart \ufb01le with this structure. // contents of 'fraction.dart' library fraction; export 'src/core.dart'; export 'src/extension_num.dart'; export 'src/extension_string.dart'; It is like a \"collector\": it grabs and exposes your sources all together so that when it\u2019s time to use the library, it can simply be referenced using a single import statement... import 'package:fraction/fraction.dart'; ... rather than importing each source \ufb01le one by one import 'package:fraction/core.dart'; import 'package:fraction/extension_num.dart'; import 'package:fraction/extension_string.dart'; This fraction package is available both on GitHub 2 and pub . We\u2019ve written a pure Dart package with no Flutter dependencies but we could have easily created a FractionWidget simply by importing the material or cupertino packages, for example. example/ lib/ test/ fraction_test.dart mixed_test.dart CHANGELOG.md LICENSE README.md analysis_options.yaml pubspec.yaml Of course, we have also written a lot of tests inside test/ using the test package as we\u2019ve seen back in chapter . They\u2019ve been grouped into logical \"categories\" according to the type of feature being tested. 2https://github.com/albertodev01/fraction 3https://pub.dev/packages/fraction Flutter Complete Reference 663",
  ". Publishing packages and apps void main() { group(\"Constructors\", () { test(\"Numerator and denominator\", () { var f = Fraction(, ); expect(f.toString(), \"/\"); }); // other tests... }); group(\"Operators\", () { ... }); group(\"Methods\", () { ... }); } Packages where performance is critical might also include a benchmark/ folder with a Dart \ufb01le executing some tests. Note that this \ufb01le is not meant to test the correctness of the code but its speed, resources consumption and other metrics critical to you. benchmark/ benchmark_feature1.dart benchmark_feature2.dart lib/ test/ ..2 Documenting the code Packages apart, in general Dart code can be documented to explain how methods or classes work and how they can be used. The documentation is fundamental to know what other developers had in mind but it has to be maintained in parallel with the code: they must live together. \u009f While writing the code, you know what you\u2019re thinking and those thoughts should be properly documented for others (or for \"your future self\"). Anyone new to your code needs explanations of what and why you wrote the code in that way. Flutter Complete Reference 664",
  ". Publishing packages and apps You should always document at least you code\u2019s public API but avoid writing long wall-texts; whenever you can, try to be as concise as possible. If it\u2019s the case of a complicated method instead, don\u2019t be afraid to write a lot. It might happen that a method has more comments than actual code but that\u2019s \ufb01ne. \u009f If you look at Flutter\u2019s source \ufb01les, you\u2019ll see that in certain cases there are more comments and examples than actual code. They are useful for you to understand how something works and how it can be used. If Dart and Flutter had no documentation for their classes and methods, it would be a really big problem! Documenting code is done with triple slashes /// Doc which is di\ufb00erent from usual comments because they use double slashes // Comment . You can document classes, methods, getters, setters and so on as long as it\u2019s Dart code. /// Use triple slashes to document. /// You can also go to a new line class HttpRequest { /// Checks whether the API is available or not bool isOnline() {} } You could also document the code using only comments but that\u2019s not ideal. If you use triple slashes as we\u2019ve shown above, there\u2019s the possibility to use the dartdoc utility to generate a very nice HTML page of your documentation. In addition, the IDE can read your docs and show hints when you hover on the text. The process is very easy: . document the code with /// Triple slashes docs ; . use the dartdoc CLI on your Dart \ufb01le and it will automatically generate a series of HTML pages with the documentation. The documentation of the packages at pub.dev is generated with this tool as well so here\u2019s another reason of why you should really use triple slashes. If you use comments dartdoc won\u2019t be able to generate the pages for you. The o\ufb03cial Dart documentation 4 exposes a series of best practices for writing documentation. \u2022 Use triple slashes rather than double slashes to document your code. /// OK - Documentation // NO - Comment 4https://dart.dev/guides/language/e\ufb00ective-dart/documentation Flutter Complete Reference 665",
  ". Publishing packages and apps \u2022 Try to not document every single piece of code you\u2019ve written; document most of the public API. Of course, private members can be documented too but it\u2019s not really needed. \u2022 Don\u2019t write too much details that can be omitted; be short and direct to the point. /// Executes an asynchronous GET request with a timeout /// of 3 seconds Future<String> fetchData(); // OK /// This method executes an HTTP GET request to the API /// configured in the model class (api/mode.dart). Each request /// has a timeout of 3 seconds; in case of success, a string /// with the body of the response is returned. Future<String> fetchData(); // NO \u2022 If you\u2019re documenting a complex method, a lot of text may be needed. Avoid writing wall- texts: consider separating the paragraphs after 4 or 5 lines to make the reading less dense and concentrated. \u2022 You can also write code and dartdoc will generate a nice, formatted snippet in the resulting HTML \ufb01le. Use triple backticks fences to surround the code you want to highlight. /// Returns the longest of two strings /// /// ```dart /// var l = longest(\"abc\", \"a\"); /// ``` String longest(String a, String b) {} Inside backticks you\u2019re allowed to use markdown code to format and indent the code; it will be parsed by dartdoc and converted into HTML. For example if you want to organize the text in a bullet list, just use a dash. /// Key points of this class: /// /// - one ... /// - two ... Flutter Complete Reference 666",
  ". Publishing packages and apps ..3 Reviewing and publishing Once the code is written, tested and documented it\u2019s ready to be published on pub.dev so that other developers can start using your package. Before submitting it, you should dedicate some time to improve a few \ufb01les related to the package: \u2022 Check the LICENSE \ufb01le to be sure you are \ufb01ne with its contents. \u2022 A template for pubspec.yaml was automatically generated when you created the package and it already contains the minimal required \ufb01elds. Be sure to check out the o\ufb03cial Dart documentation 5 for an overview of any \ufb01eld you can use. \u2022 Write a detailed description of your package in the README.md \ufb01le. It will be placed in your package\u2019s home page at pub.dev so it should look good. Describe the features, use images in case of widgets, write examples and put a link to external references (if any, like your package\u2019s website). \u2022 Edit the CHANGELOG.md \ufb01le to re\ufb02ect the main changes you\u2019ve applied to the current version that is going to be published. If you want to compare the setup of the fraction package with yours, visit our o\ufb03cial GitHub repository. Once all those \ufb01les have been reviewed, it\u2019s \ufb01nally time to publish the package. Just to be sure that everything is ok, let\u2019s run this command in the terminal: flutter pub publish --dry-run It executes a \"fake publishing\" which doesn\u2019t upload your package but it just simulates what would happen if you did so. It might be useful to look for warnings or problems before moving on. If no problems are reported, make the real publishing: . Open the console, move to the root of your project and launch these commands: cd lib/ flutter format . It moves the console to the lib/ folder and uses format to format all of your Dart source code. This is also needed in order to not get penalty points on pub (more on this soon). . Publish your package: flutter pub publish 5https://dart.dev/tools/pub/pubspec Flutter Complete Reference 667",
  ". Publishing packages and apps . The console will tell you to open a link; login with your Google account to con\ufb01rm the submission. . Wait a few minutes for pub to process the \ufb01les. It will also automatically generate a nice HTML website using the documentation text you\u2019ve written with triple slashes. Nothing di\ufb03cult at all: it\u2019s just a matter of running two commands and con\ufb01rming the submission with a Google login. Keep in mind that once submitted, packages cannot be deleted so they\u2019re going to stay in the repository forever. The reason is simple: the deletion would break other people\u2019s code depending on your package. ..4 Scores and good practices Any package has a score ranging from 0 to 110 and your goal is of course trying to reach the max- imum. While you can maximize pub points following some good practices, the other statistics depend on the community. This is the current score of our fraction package at the beginning of September . There\u2019s the possibility to calculate pub points before publishing the package using the pana 6 analyis tool (pub uses it as well). Running pana locally will give you a preview of the points and 6https://pub.dev/packages/pana Flutter Complete Reference 668",
  ". Publishing packages and apps the possible suggestions you\u2019d get on the website. # Activate pana flutter pub global activate pana # Run it pub global run pana ~/path/to/package Since pana makes changes to your package, run it on a copy so that the original project won\u2019t be a\ufb00ected by modi\ufb01cations. The three only scores of a package are: \u2022 Likes. Indicates how many developers liked this package. To like a package, login with your Google account and click on the thumbs up button next to the name. You can see the packages you liked in My pub.dev > My liked packages \u2022 Pub points. This metric gives insights about the quality of the package. The criteria used to compute the \ufb01nal score are: \u2013 Follow Dart \ufb01le conventions. To pass this check, use the flutter create --template command we\u2019ve discussed earlier and carefully review pubspec.yaml and the mark- down \ufb01les. \u2013 Provide documentation. Document your code using triple slashes, following the good practices we recommended. To get the maximum score, be sure that at least % of your public API is documented. Writing a proper, complete documentation goes beyond the success on this metric: do it for quality and maintenance! \u2013 Support multiple platforms. Currently, your packages should support both native and web platforms but this isn\u2019t an issue at all. Whether you\u2019re writing a pure Dart package or a Flutter one, in both cases you won\u2019t have problems. \u2013 Pass static analysis. Static analysis determines whether your package contains warn- ings, errors or styling issues. To maximize the score of this metric, be sure to: . setup the analysis_options.yaml \ufb01le as soon as possible (right after the creation of the package template); . validate a package before publishing it with flutter analyze. For a complete and updated reference, have a look at the o\ufb03cial Dart style guide . 7https://dart.dev/guides/language/e\ufb00ective-dart/style Flutter Complete Reference 669",
  ". Publishing packages and apps \u2013 Support up-to-date dependencies. If you have any dependency declared in the pubspec \ufb01le, be sure to always use the latest version. \u2022 Popularity. Indicates how many developers are using your package in their projects. On a scale from 0 to , a high percentage indicates that a big number of apps are depending on your package. You\u2019re going to lose points if you don\u2019t provide an example/ folder at the root of the project with some runnable demos so you\u2019d better create it. You\u2019ll also get penalty points if the description in your pubspec.yaml \ufb01le is too short; it should contain  - 180 characters. ..5 Veri\ufb01ed publishers and Flutter favorite You may have noticed that certain publishers at pub.dev have a blue shield next to the name. Thanks to it you know that a package was uploaded by a publisher whose identity has been veri\ufb01ed and thus there\u2019s more authority to the product. The badge doesn\u2019t give info about the quality of the code but it\u2019s tied to the authenticity of the publisher. Being a veri\ufb01ed published isn\u2019t complicated but there are a few steps to follow. You need an active Google account which will be associated with both pub.dev and the Google Search Console. . Decide which Google account you want to use and login to the Google Search Console . . Any veri\ufb01ed publisher must have a domain to associate with his pub account. In our case, the domain is \ufb02uttercompletereference.com which also points to our website. That\u2019s not a requirement, you can simply have a valid domain without a website associated. . Type your domain in the console and then you\u2019ll be asked to verify its identity via DNS. In practice, you have to go to your domain provider settings and add a new DNS text record. Even after the veri\ufb01cation, don\u2019t remove this entry because Google periodically checks your domain. IN TXT \"google-site-verification=XXXXXXXXXXXX\" The console will give you the exact string to insert; the veri\ufb01cation might take some times due to the propagation times of the DNS entries but in 24h you should be able to do it. 8https://search.google.com/search-console/about Flutter Complete Reference 670",
  ". Publishing packages and apps There are also other ways to verify your domain, such as via HTML <meta> tag but it doesn\u2019t work with pub. You have to do the DNS way. . Once you\u2019ve managed to verify your domain with success in the console, open pub.dev and login. Go to the top-right corner and the click create publisher. Type the veri\ufb01ed domain name in the box and click \"CREATE PUBLISHER\". You\u2019ll get an error if you try to submit a domain that\u2019s not previously been veri\ufb01ed via DNS. At this point you are o\ufb03cially a veri\ufb01ed published and the blue badge will always appear next to the name. If you already had published some packages with a non-veri\ufb01ed account, just go to the Admin area of your package and transfer it to your veri\ufb01ed account. Being a veri\ufb01ed publisher is not only a matter of pride but it also gives you a chance to become eligible for the Flutter favorite program. This campaign identi\ufb01es all those top-quality packages you should \ufb01rst consider when building apps. However, don\u2019t blindly prefer them over the other alternatives. The are very good for sure but being a \ufb02utter favorite doesn\u2019t make a package perfect. Flutter Complete Reference 671",
  ". Publishing packages and apps It\u2019s very unlikely that a newly created package will become a Flutter favorite in short spans of time. There are a lot of criteria to satisfy such as feature completeness, performance, code quality, GitHub integration, being a veri\ufb01ed publisher and much more. You can see all the details about this program in the o\ufb03cial page . .2 Publishing apps on the stores At the end of the development cycle, when all the features have been implemented and the testing is done, it\u2019s time to put the app in production. When you use the emulator with the hot reload feature, Flutter is working in debug 10 mode which mainly implies a few things: \u2022 the size of the binary \ufb01le, .apk/.aab for Android or .ipa for iOS, is very large; \u2022 sometimes the app doesn\u2019t run so smoothly or certain transitions might not seem very \ufb02uid; \u2022 any assert() statement in your code will be evaluated. The emulator and the hot reload feature work only in debug mode, which is the default one when you execute the flutter run command. When it\u2019s time to deploy the app for production, switch to release mode to have: \u2022 smaller size of the binary \ufb01le; 9https://\ufb02utter.dev/docs/development/packages-and-plugins/favorites 10https://\ufb02utter.dev/docs/testing/build-modes Flutter Complete Reference 672",
  ". Publishing packages and apps \u2022 faster execution with \ufb02uid transitions, faster startup and general optimizations automati- cally made by the compiler; \u2022 assert() statements are removed. As you already know from chapter , there is also a third mode called pro\ufb01le which enables pro\ufb01ling with \"DevTools\". In the next sections we will analyze how to prepare an app for the release mode and potentially the publication on the o\ufb03cial stores. ..1 Releasing Android apps Before publishing to the Google Play store, there are some \ufb01nal steps to follow to de\ufb01ne the details of the app (the icon, the name and the assignments of security certi\ufb01cates). Be sure to check the o\ufb03cial documentation 11 for more info about deploying apps on Android devices. . You need to have Java installed on your machine because it has the keytool command line program. It\u2019s used to generate a keystore \ufb01le to be associated with the binary being built. $ keytool -genkey -v -keystore myAppKey.jks -keyalg RSA -validity  -keysize  -alias myKey -storetype JKS Keep this \ufb01le private and be sure it doesn\u2019t get lost otherwise you won\u2019t be able to publish updates for this app on the store anymore. It\u2019s used to identify you as the owner of the app. . In the IDE, go to /android/key.properties and reference the .jks \ufb01le you\u2019ve just created. The passwords it asks are the ones you\u2019ve had to type in the command line program in the previous step storePassword=store_pass keyPassword=key_pass keyAlias=myKey storeFile=location_to_the_file You can place myAppKey.jks where you want but be sure to exclude it from version control systems such as GitHub. . Now go at /android/app/build.gradle and place this code before the android {} block: def keystoreProperties = new Properties() def keystorePropertiesFile = rootProject.file('key.properties') if (keystorePropertiesFile.exists()) { 11https://\ufb02utter.dev/docs/deployment/android Flutter Complete Reference 673",
  ". Publishing packages and apps keystoreProperties.load(new FileInputStream(keystorePropertiesFile)) } In this same \ufb01le, remove the buildTypes block and add all these lines. Basically they instruct gradle to sign your app with the given keystore \ufb01le any time a build in release mode happens. signingConfigs { release { keyAlias keystoreProperties['keyAlias'] keyPassword keystoreProperties['keyPassword'] storeFile keystoreProperties['storeFile'] ? file(keystoreProperties['storeFile']) : null storePassword keystoreProperties['storePassword'] } } buildTypes { release { signingConfig signingConfigs.release } } Just to avoid possible caching problems, run flutter clean. . Now move to the manifest \ufb01le located at /android/app/src/main. In the <application> tag you can change the android:label to give your app the name (the one appearing below the icon on the home screen). <application <!-- other settings here ... --> android:label=\"App name\" /> That way, the name is hard-coded but that\u2019s not always what you\u2019re looking for. If you want to show di\ufb00erent names according to the device\u2019s language (so you want to localize the title) there\u2019s an extra step to do. <application <!-- other settings here ... --> android:label=\"@string/appname\" /> Change the value of android:label and then locate the app/src/main/values folder; create inside it a \ufb01le with this speci\ufb01c name: strings.xml. Write your app\u2019s name in the Flutter Complete Reference 674",
  ". Publishing packages and apps native language (in our case, english) following this scheme: <?xml version=\".\" encoding=\"utf-\"?> <resources> <string name=\"appname\">My app</string> </resources> Now for any new language you want to support, create a values-XX folder containing the localized string for the given locale. For instance, if we wanted to add an Italian value, we should create the /android/app/src/main/values-it folder with another strings.xml \ufb01le inside it. <?xml version=\".\" encoding=\"utf-\"?> <resources> <string name=\"appname\">La mia app</string> </resources> The name attribute is always the same (appname). Our app will be called My app in any language, because it\u2019s the default value, but when italian is set the name will be La mia app. You can add as many languages you want. . If needed, add the internet permission in the manifest \ufb01le to allow the connectivity. . Your app\u2019s icons are located inside the res/drawable-XXX folders. It\u2019s always the same im- age but with di\ufb00erent sizes because Android will automatically pick the best one according to the device\u2019s pixel density. You have to: (a) create one logo for each folder keeping the same sizes of the placeholder image that you \ufb01nd; (b) if you\u2019re using Android Studio, you can use the very convenient \"Image Asset Studio\" tool which automatically generates the icons. With the asset studio tool you can even load SVG images and it will take care of generating all the icons for each folder. It\u2019s been a long way but you\u2019ve \ufb01nally made it to the end; you can now build the binary \ufb01le in release mode. There are two possible formats to choose for the Play Store: \u2022 .apk: it is the traditional \ufb01le extension you\u2019re used to see for Android apps. Go to the console and run the following command to generate the binaries: flutter build apk --split-per-abi Flutter Complete Reference 675",
  ". Publishing packages and apps You\u2019ll \ufb01nd three apk \ufb01les at /build/app/outputs/apk/release, one for each ABI . This is the best thing to do; you could also generate a single .apk with this command... flutter build apk ... but you\u2019ll end up with a very big \ufb01le including the code compiled for each ABIs. There\u2019s no need for this because it would carry useless data for devices that don\u2019t support a speci\ufb01c architecture. You\u2019d better split the \ufb01les and pick only the binary compatible with your target device. \u2022 .aab: it\u2019s the new \ufb01le format recommended by the Android team 13 in place of apks. It should be your primary choice when it comes to production apps to be published to the store. flutter build appbundle This command generates at /build/app/outputs/bundle/release/ a single \ufb01le with .aab extension. It contains the compiled code for the supported ABIs. Check out appendix A.3 to learn about code obfuscation and a better way of using the build command. Both \ufb01le types contain the compiled code for three ABIs but they\u2019re built in di\ufb00erent ways. An app bundle is an optimized version that will be further processed by the Play Store while an apk is like a \"zip\" containing all the precompiled binaries. \u009f If you had to share your app, for example, to an internal member of your team to show how it looks, you could create an apk. It can be transferred to a device via \ufb01le manager and then the Android package installer will install it. You can drag and drop an apk in the Android emulator to install it. This is not possible with aab \ufb01les because they\u2019re made to be uploaded in the Google Play store; Android doesn\u2019t directly \"understand\" app bundles. \u009f If you want to extract an apk from an aab \ufb01le you have to use the bundletool 14 tool, which is what the Google Play store uses. An aab \ufb01le is just a better way of handling di\ufb00erent ABIs, rather than having multiple apks. It\u2019s more convenient. 12Application Binary Interfaces 13https://developer.android.com/guide/app-bundle 14https://developer.android.com/studio/command-line/bundletool Flutter Complete Reference 676",
  ". Publishing packages and apps ..2 Releasing iOS apps Before publishing to the Apple App store, there are some \ufb01nal steps to follow to de\ufb01ne the details of the app (the icon, the name and the assignments of security certi\ufb01cates). Be sure to check the o\ufb03cial documentation 15 for more info about deploying apps on iOS devices. . First of all, you need to join the \"Apple Developer Program\" in order to be able to access the \"App Store Connect\" (referenced as ASC from now on). This is important because iOS builds happen via Xcode tools which require certi\ufb01cates obtained from the ASC. Open the Apple Developer portal, click on Identi\ufb01ers and add a new \"App ID\". Go for App IDs. On the next page, type you app\u2019s name and be sure to check the Explicit App ID option. Enter an ID and pick from the list below the services you app is using, if any. Click on \"Register\" to con\ufb01rm. . Open the ASC, click \"My Apps\" and add a new one pressing on + in the top-left corner. Fill the forms with all the required information and then your application tab will appear on the screen. At the end of the process, you\u2019ll get something like this on the main page: The My Apps section of the ASC shows any ap- plication you\u2019ve uploaded to the store with a brief summary of the status. The big image is the icon you\u2019re required to upload (more on this later) while at the bottom there\u2019s a quick summary of the status: (a) Prepare for submission (b) Waiting for review (c) In review (d) Ready for sale 15https://developer.apple.com/app-store/submitting/ Flutter Complete Reference 677",
  ". Publishing packages and apps Click on the app\u2019s logo and provide the various information they need such as screenshots and descriptions. Let\u2019s now open Xcode to \ufb01nalize some other details. . Open the iOS folder of your Flutter project. Open Runner.xcworkspace and then select \"Runner\" in the Xcode project navigator. Choose \"Runner\" as target. \u2022 In the Identity section, change you app\u2019s name. \u2022 In the Signing section, make sure that automatic signing is ticked. Choose your team (the one associated to the Apple Developer account) from the dropdown menu. This is quite useful because Xcode will automatically handle pro\ufb01les, app IDs and certi\ufb01cates. \u2022 In the Deployment Info section be sure that .0 or higher is selected. . In case you\u2019re doing the \ufb01rst release, make sure that pubspec.yaml has a version code of ..0 otherwise change it accordingly. Don\u2019t manually handle versioning on XCode: for an easier maintenance across multiple platform, rely on the version: attribute of pubspec.yaml. . Add the app icon going to the Assets.xcassets folder, located inside Runner in the project navigator, and edit the assets. There\u2019s a default Flutter placeholder image. Replace it and to be sure it looks as you\u2019d expect, run the app on a Simulator (or a real device). For a quick prototyping, you can use an online asset generator to build a temporary logo for your app. It will create all the required assets so that you\u2019ll just have to download and move the images. It\u2019s \ufb01nally time to generate the native iOS binary. Close Xcode to avoid refreshing problems with the Flutter build tool and launch the following command: flutter build ios Flutter Complete Reference 678",
  ". Publishing packages and apps Once the process has completed, return to Xcode again and open the runner.xcworkspace \ufb01le. In sequence, perform the following actions on the menu bar of the IDE: \u2022 Product > Scheme > Runner; \u2022 Product > Destination > Generic iOS Device; \u2022 Project Navigator > Runner > Runner \u2022 Product > Archive Wait for the completion of the build and then a dialog similar to the one below will appear. It shows all the builds you\u2019ve done up to now (we\u2019ve removed some from the image for convenience). You should \ufb01rst click Validate App to ensure that everything is ok and then click Distribute App to upload the app on the store. This process may take several minutes. Open the App Store Connect, click on your app, select the build you\u2019ve uploaded via Xcode and wait for the review of the Apple Store team. Consider reading our appendix A.3 about Dart code obfuscation in release mode. ..3 Splash screens Some apps might not be ready as soon as they\u2019re opened due to time-consuming operations re- quired at startup. For example, they could have to check for updates, load a lot of data from the cache or exchange some data with a server. The problem could also be an old, slow device. \u009f Think about games for mobile phones. In general, as soon as they\u2019re opened, a splash screen appears telling you that the app will start very soon. It gives the feeling of fastness and responsiveness since the very beginning, which is a fundamental UX Flutter Complete Reference 679",
  ". Publishing packages and apps aspect. Animations and loading indicators make the waiting time more pleasant. Flutter may take more than a few milliseconds to start, especially if you\u2019re doing a lot of initial- ization work before calling runApp. If it\u2019s the case, you\u2019ll see a completely white screen appearing (the default splash screen) but you can of course customize it: . iOS. Very simply, open the Runner.xcworkspace \ufb01le from Xcode, select the assets folder and double click the LaunchImage image set. It\u2019s simply a PNG \ufb01le you can customize as much as you want to create a nice and user-friendly splash image. . Android. Similarly to what we\u2019ve seen for iOS, all you need to do is editing a certain pre-made template. Opening src/main/res/values/styles.xml you\u2019ll \ufb01nd the default de\ufb01nition of the splash screen, which is just a <style> element pointing to a drawable. <style name=\"LaunchTheme\" parent=\"@android:style/Theme.Black.NoTitleBar\"> <item name=\"android:windowBackground\">@drawable/launch_background</item> </style> Go to src/main/res/drawable/launch_background, which is the actual splash screen, and style it as you prefer. For example, you could create a PNG image with the logo and a small text below telling the user \"Loading...\" or something similar. <!-- The background color --> <item android:drawable=\"@android:color/white\" /> <!-- The PNG at the center of the screen --> <item> <bitmap android:gravity=\"center\" android:src=\"@drawable/my_splash_image\" /> </item> The \ufb01le my_splash_image.png has been created in the drawable/ folder. Keep in mind that even if your app has a splash screen, it shouldn\u2019t appear for more than a few seconds. In addition, try to keep it quite simple and be sure to mark the fact that the app is loading and it will be ready very soon. Have a look at the appendix B.3 to see how to gracefully execute startup initialization in Flutter. Flutter Complete Reference 680",
  ". Publishing packages and apps ..4 Doing CI/CD for Flutter In the previous sections we\u2019ve shown you how to prepare applications for production giving a proper name, setting icons and much more. Once it\u2019s done, you need to run two di\ufb00erent build commands and Flutter will take care of creating the native binaries. To sum it up, the deployment process is the following: . run tests to ensure that everything is ok; . prepare the app for the Android release (generate keys, con\ufb01gure gradle, \ufb01x the manifest and so on); . prepare the app for iOS release (setup the certi\ufb01cates, use Xcode to work on the Runner, load assets and so on); . publish the native binaries to the stores. Indeed there\u2019s a lot of manual work to do when it comes to publish a new update for the app but you can\u2019t do much about it. Icons, names and other details might not change in each new release but still there\u2019s the need to go through those four steps. Thanks to certain online services, such as Codemagic, you can automate the testing/deployment phase for your Flutter apps. Codemagic is a cloud-based CI/CD service that automatically builds, tests and deploys your Flutter native apps to the o\ufb03cial stores. When using these kind of services you just need to write the app and the tests; all the other steps (from running tests up to the publication in the o\ufb03cial store) are automatic. In particular: \u2022 for each commit to a git repository, there\u2019s the possibility to automatically run tests and make builds. For example, if you don\u2019t have a macOS and/or an iPhone, you can still successfully test, build and publish an iOS app because the CI/CD service has the hardware; \u2022 any tool is always updated to the latest version. You don\u2019t need to manually check for Flutter updates or installing heavy Xcode releases because everything is on the cloud; \u2022 you can run apps on Android emulators, iOS simulators or even real physical devices. Flutter Complete Reference 681",
  ". Publishing packages and apps All of this goodness is part of a series of processes called Continuous Integration and Continuous Delivery. We aren\u2019t going to cover CI/CD in detail because it goes beyond the scope of this book but in case you didn\u2019t know what they are, here\u2019s a description from a purely practical point of view. \u2022 CI. Developers push a new commit to a git repository (generally on GitHub or GitLab) and a \"listener\" is triggered: the newly pushed code is built and then tested. With this approach, building and testing automatically happen as soon as the new code is committed to the repository so that the team can quickly \ufb01nd bugs. \u2022 CD. It starts where CI ends. If tests ran with success and the team is happy with the current status of the product, the CD process starts. The application is packaged, signed (required for iOS and Android) and then deployed. Codemagic o\ufb00ers 500 free build minutes and two team seats for free every month. For professional developers, they o\ufb00er a post-paid billing model, which means you will get billed based on usage. Your Flutter and native mobile projects will be up and running with just a few clicks. Alterna- tively, you could use fastlane which is local to your machine and the o\ufb03cial Flutter documentation 16 also has a guide on how to use it. ...1 GitHub actions The Dart and Flutter team use GitHub to version their code. If you decide to do the same, which is what we recommend, you can easily setup CI and CD in your repository using Actions. For example, our dart_equations 17 package has a GitHub action that performs the following tasks for each push (or pull request): . install dependencies using pub get; . run dartfmt to make sure the code is well formatted; . run tests. For example, every time you make a git push the action installs the dependencies, checks the formatting and runs tests. Once completed, you can see a green tick or a red cross next to the commit telling you respectively whether the action completed with success or failed. 16https://\ufb02utter.dev/docs/deployment/cd 17https://pub.dev/packages/equations Flutter Complete Reference 682",
  ". Publishing packages and apps To create a new action, just go on your GitHub repository, click Actions and then choose \"set up a work\ufb02ow yourself\". Alternatively, create the .github/workflows/ folders and create a new YAML \ufb01le (which is what the website would do for you). In practice, an action is nothing more than a .yaml \ufb01le telling the backend which steps have to be done. name: dart_equations_ci on: push: branches: - master pull_request: branches: - master jobs: build: runs-on: ubuntu-latest container: image: google/dart:latest steps: - uses: actions/checkout@v2 - name: Install dependencies run: pub get - name: Format run: dartfmt --dry-run --set-exit-if-changed . - name: Run tests run: pub run test This is the action we have implemented for our dart_equations and fraction packages. This setup Flutter Complete Reference 683",
  ". Publishing packages and apps is good for a \"pure\" Dart application but for Flutter, you need di\ufb00erent commands: name: master_ci on: push: branches: - master jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - uses: subosito/flutter-action@v1.. - name: Install Dependencies run: flutter packages get - name: Format run: flutter format --set-exit-if-changed lib test - name: Run tests run: flutter test --no-pub In summary, if you want to quickly setup a GitHub action for your Dart or Flutter projects, just create the folders .github/workflows and place a YAML \ufb01le containing the steps to do. The action itself is a \ufb01le telling the backend what to do. A repository can run one or more actions. For each action, you get the history of the results of runs. GitHub Actions usage is free for public Flutter Complete Reference 684",
  ". Publishing packages and apps repositories and self-hosted runners. For private repositories, each GitHub account receives a certain amount of free minutes and storage, depending on the product used with the account. For more info on actions, visit the o\ufb03cial documentation . 18https://docs.github.com/en/free-pro-team@latest/actions Flutter Complete Reference   | Complete Flutter project example .1 Preparing the project In this section we\u2019re going to show in detail how to create a Flutter application in which an user can register and login using the Firebase authentication system. The project uses email address and password as authentication credentials but any other way would be \ufb01ne. Flutter Complete Reference 686",
  ". Complete Flutter project example Both buttons can be pressed; \"Register\" adds a new user to the system while \"Login\" is just authentication for already signed up people. Let\u2019s start by opening Firebase and creating a new project called LoginApp. As always, follow the installation guide in chapter 22 to correctly place the con\ufb01guration \ufb01les. Here\u2019s a summary: \u2022 Create a new Android app on Firebase with the correct package name (the same you\u2019ve used for the Flutter project) and download the google-services.json \ufb01le. \u2022 Move google-services.json in the android/app folder and setup the Gradle build \ufb01le. \u2022 Create a new iOS app on Firebase with the correct package name (the same you\u2019ve used for the Flutter project) and download the GoogleServices-Info.json \ufb01le. \u2022 Move GoogleServices-Info.json in the ios/Runner folder. On the home page of your Firebase project, click on \"Authentication\" on the left sidebar, then choose \"Sign-in methods\" and enable the email/password login provider. Even before opening the IDE, do a git init and version your code! ..1 Folder structures and basic setup As you already know, managing the state of an app with setState() and InheritedWidget is di\ufb03cult and requires too much boilerplate code. For this reason, we\u2019re working with the \ufb02utter_bloc library. We also want to localize the contents and split the UI in multiple reusable widgets so a good folder structure is essential. lib/ blocs/ localization/ repository/ routes/ widgets/ main.dart routes.dart test/ analysis_options.yaml pubspec.yaml Following good coding practices is very important for our code\u2019s health and thus we immediately create the analysis_options.yaml \ufb01le. You can \ufb01nd its de\ufb01nition in the Resources section of our website. Inside lib/localization create the localization delegate and class AppLocalization Flutter Complete Reference 687",
  ". Complete Flutter project example (see chapter ), choosing between \"manual\" or intl approach. // main.dart void main() => runApp(const LoginApp()); class LoginApp extends StatelessWidget { const LoginApp(); @override Widget build(BuildContext context) { return BlocProvider<AuthenticationBloc>( create: (context) { // More on blocs in the next section... return AuthenticationBloc(repository); }, child: MaterialApp( initialRoute: RouteGenerator.homePage, onGenerateRoute: RouteGenerator.generateRoute, localizationsDelegates: [ const AppLocalizationDelegate(), GlobalMaterialLocalizations.delegate, GlobalCupertinoLocalizations.delegate, GlobalWidgetsLocalizations.delegate, ], supportedLocales: [ Locale.fromSubtags(languageCode: \"en\"), Locale.fromSubtags(languageCode: \"it\"), ], onGenerateTitle: (context) => context.localize(\"title\"), debugShowCheckedModeBanner: false, ), ); } } Routes are going to be managed inside the routes.dart \ufb01le to keep the navigation logic in a separated \ufb01le, as we\u2019ve covered in chapter . For safety, we\u2019ve decided to create a custom Flutter Complete Reference 688",
  ". Complete Flutter project example exception type in case the route name were invalid but it won\u2019t happen. Since we rely on hard- coded static constants, there cannot be typos in the name of the route. /// Routing handler for the app class RouteGenerator { const RouteGenerator._(); static Route<dynamic> generateRoute(RouteSettings settings) { switch (settings.name) { case homePage: // We will create 'HomePage' later return MaterialPageRoute<HomePage>( builder: (_) => const HomePage(), ); default: throw RouteException(\"Route not found\"); } } static const homePage = '/'; } /// Exception thrown when a given route doesn't exist class RouteException implements Exception { final String message; const RouteException( this.message); } A switch statement with a single case doesn\u2019t make much sense but we\u2019re assuming that the app will have many routes. Our example only has the home page but in reality you\u2019ll have more than a single route. .2 State management and model classes In order to easily manage user\u2019s data, we\u2019re going to create an architecture that takes care of authentication tasks. In a more complex scenario, it might also handle authentication tokens or the retrieval from a secured storage of cached username and password. Flutter Complete Reference 689",
  ". Complete Flutter project example // Inside 'repository/user_repository.dart' abstract class UserRepository { /// Creates the repository for authenticating an user const UserRepository(); /// Email of the signed user String get signedEmail; /// Login with username and password Future<bool> authenticate(String username, String password); /// Registration with username and password Future<bool> register(String username, String password); /// Logout Future<void> logOut(); } This class has to be implemented in order to create a login provider, such as the Firebase one we\u2019re going to show in a moment. This way of modelling classes is known as Strategy pattern, a famous design pattern from the Gang of Four (GOF). Note that we\u2019re always documenting public methods: // Inside 'repository/user_repository/firebase_repository.dart' class FirebaseUserRepository extends UserRepository { /// Firebase authentication repository const FirebaseUserRepository(); @override String get signedEmail => FirebaseAuth.instance .currentUser .email ?? \"-\"; @override Future<bool> authenticate(String username, String password) async { try { await FirebaseAuth.instance .signInWithEmailAndPassword( Flutter Complete Reference 690",
  ". Complete Flutter project example email: username, password: password ); return true; } on FirebaseAuthException catch (e) { debugPrint(e.message); return false; } } @override Future<bool> register(String username, String password) async { try { await FirebaseAuth.instance .createUserWithEmailAndPassword( email: username, password: password, ); return true; } on FirebaseAuthException catch (e) { debugPrint(e.message); return false; } } @override Future<void> logOut() => FirebaseAuth.instance.signOut(); } Note that in case of a failed authentication or registration a FirebaseAuthException is thrown but it will be handled later in the bloc. In both cases, the result variable is of type AuthResult which contains many data about the user such as his email, the avatar image, whether the email has been veri\ufb01ed or not and much more. // Inside 'repository/user_repository/test_repository.dart' class TestUserRepository extends UserRepository { /// The email of the user Flutter Complete Reference 691",
  ". Complete Flutter project example final String fakeEmail; /// Determines whether the methods will fail or not final bool succ; /// Mock authentication repository (for testing) const TestUserRepository({ required this.fakeEmail, required this.succ, }); @override Future<bool> authenticate(String username, String password) { return Future<bool>.delayed(const Duration(seconds: ), () => succ); } @override Future<bool> register(String username, String password) { return Future<bool>.delayed(const Duration(seconds: ), () => succ); } @override Future<void> logOut() => Future.delayed(const Duration(seconds: )); @override String get signedEmail => fakeEmail; } We\u2019ve also created the TestUserRepository which will be used in unit tests and widget tests. It\u2019s a convenient mock for the Firebase authentication process which requires no internet con- nection or platform setup. Thanks to the usage of the strategy pattern, you can easily add more authentication providers to your application. In the future, if you wanted to also login with Facebook Twitter or Google, you\u2019ll just have to implement the interface: // Inside 'repository/user_repository/twitter_repository.dart' class TwitterUserRepository extends UserRepository {} // Inside 'repository/user_repository/google_repository.dart' class GoogleUserRepository extends UserRepository {} Flutter Complete Reference 692",
  ". Complete Flutter project example // Inside 'repository/user_repository/facebook_repository.dart' class FacebookUserRepository extends UserRepository {} It\u2019s also a very good way of respecting the SOLID principles. You should end up with the following contents inside the repository/ folder: repository/ user_repository.dart user_repository/ firebase_repository.dart test_repository.dart ..1 Authentication bloc The AuthenticationBloc bloc determines whether the user is authenticated or not. In other words, it\u2019s used to decide if the login form has to be displayed or not, according to the cur- rent authentication status. Inside blocs/authentication_bloc/events.dart we\u2019re creating the events: /// Events for the [AuthenticationBloc] bloc abstract class AuthenticationEvent extends Equatable { /// Base class for events fired by [AuthenticationBloc] const AuthenticationEvent(); @override List<Object> get props => []; } /// User has logged with success class LoggedIn extends AuthenticationEvent { const LoggedIn(); } /// User requested to logout class LoggedOut extends AuthenticationEvent { const LoggedOut(); } When the LoggedIn event is \ufb01red, the login form disappears and the actual home page is shown. Flutter Complete Reference 693",
  ". Complete Flutter project example When LoggedOut is \ufb01red, the currently visible route disappears and the login form is shown because the user logged out. Notice how we try to use const constructors as much as possible. Here\u2019s the states: /// States emitted by [AuthenticationBloc] abstract class AuthenticationState extends Equatable { /// Base class for states emitted by [AuthenticationBloc] const AuthenticationState(); @override List<Object> get props => []; } /// App just opened, login or register actions required class AuthenticationInit extends AuthenticationState { const AuthenticationInit(); } /// Login made with success class AuthenticationSuccess extends AuthenticationState { const AuthenticationSuccess(); } /// Logout class AuthenticationRevoked extends AuthenticationState { const AuthenticationRevoked(); } /// Loading (awaiting for registration or authentication) class AuthenticationLoading extends AuthenticationState { const AuthenticationLoading(); } In case of AuthenticationLoading() a loading indicator appears on the UI indicating that the app is awaiting for Firebase to return a response. It\u2019s now time to create the bloc itself to actually manage our app\u2019s authentication state: /// Manages the authentication state of the app class AuthenticationBloc Flutter Complete Reference 694",
  ". Complete Flutter project example extends Bloc<AuthenticationEvent, AuthenticationState> { final UserRepository userRepository; AuthenticationBloc(this.userRepository) : super(const AuthenticationInit()); @override Stream<AuthenticationState> mapEventToState(AuthenticationEvent e) async*{ if (e is LoggedIn) { yield const AuthenticationSuccess(); } if (e is LoggedOut) { yield const AuthenticationLoading(); await userRepository.logOut(); yield const AuthenticationRevoked(); } } } As you can see, when the LoggedIn event is \ufb01red AuthenticationSuccess is emitted by the bloc so that the app knows to change page (move from the login page to the actual home page). Tapping on the login button triggers the login bloc (see next sections) which, in case of success, will \ufb01re a LoggedIn event causing the actual home page to appear. Flutter Complete Reference 695",
  ". Complete Flutter project example Your code is surely going to reference the bloc \ufb01le in an import statement but state and event \ufb01les are also required. In some cases you might end up having to import a lot of libraries, especially if multiple blocs are needed by a single class. import 'package:flutter_app/blocs/authentication_bloc/bloc.dart'; import 'package:flutter_app/blocs/authentication_bloc/events.dart'; import 'package:flutter_app/blocs/authentication_bloc/states.dart'; import 'package:flutter_app/blocs/credentials_bloc/bloc.dart'; import 'package:flutter_app/blocs/credentials_bloc/events.dart'; import 'package:flutter_app/blocs/credentials_bloc/states.dart'; As you already know from chapter , we can use the library keyword to group multiple import statements in a single one. In other words, each bloc is a \"mini library\" which can easily be referenced by a single statement. // contents of '/lib/blocs/authentication_bloc.dart' library authentication_bloc; export 'authentication_bloc/bloc.dart'; export 'authentication_bloc/events.dart'; export 'authentication_bloc/states.dart'; This is very useful because with a single import statement we can reference the bloc, its events and its states all together. Maintenance will also bene\ufb01t from this so you should really use this approach when creating blocs. import 'package:flutter_app/blocs/authentication_bloc.dart.dart'; import 'package:flutter_app/blocs/credentials_bloc.dart'; In the next section we\u2019re creating the CredentialsBloc class, which handles the login and \ufb01res the LoggedIn event in case of successful authentication or authorization. ..2 Credentials bloc While AuthenticationBloc is used to move between the login and home page, CredentialsBloc is taking care of communicating with Firebase to authenticate and/or register an user. Two events are required, one for the Login button and the other for the Register button: /// Events for the [CredentialsBloc] bloc abstract class CredentialsEvent extends Equatable { /// The username Flutter Complete Reference 696",
  ". Complete Flutter project example final String username; /// The password final String password; /// Events fired by [CredentialsBloc] when a button is pressed. It /// provides information taken from the form. const CredentialsEvent(this.username, this.password); @override List<Object> get props => [username, password]; } /// Event fired when the login button is tapped class LoginButtonPressed extends CredentialsEvent { const LoginButtonPressed({ required String username, required String password }) : super(username, password); } /// Event fired when the register button is tapped class RegisterButtonPressed extends CredentialsEvent { const RegisterButtonPressed({ required String username, required String paxssword }) : super(username, password); } The bloc is going to use UserRepository to make the actual registration or authentication but it also has to handle the waiting time and the errors. The following states are required: /// States emitted by [CredentialsBloc] abstract class CredentialsState extends Equatable { /// State emitted by [CredentialsBloc] when the form is created const CredentialsState(); @override List<Object> get props => []; Flutter Complete Reference 697",
  ". Complete Flutter project example } /// Action required (authentication or registration) class CredentialsInitial extends CredentialsState { const CredentialsInitial(); } /// Login request awaiting for response class CredentialsLoginLoading extends CredentialsState { const CredentialsLoginLoading(); } /// Registration request awaiting for response class CredentialsRegisterLoading extends CredentialsState { const CredentialsRegisterLoading(); } /// Invalid authentication credentials class CredentialsLoginFailure extends CredentialsState { const CredentialsLoginFailure(); } /// Weak password or invalid email class CredentialsRegisterFailure extends CredentialsState { const CredentialsRegisterFailure(); } Failure states are used to represent errors while trying to authenticate, due to wrong credentials, or register, due to problems with the email. In case of errors, a generic PlatformException with many di\ufb00erent codes you can \ufb01nd in the source code . In order to not make the example too complicated, we\u2019ve decided to simply handle exceptions with a single error message indicating to try a di\ufb00erent email. /// Manages the login state of the app class CredentialsBloc extends Bloc<CredentialsEvent, CredentialsState> { /// Data about the user final UserRepository userRepository; 1https://github.com/FirebaseExtended/\ufb02utter\ufb01re/tree/master/packages/\ufb01rebase_auth Flutter Complete Reference 698",
  ". Complete Flutter project example /// The [AuthenticationBloc] taking care of changing pages final AuthenticationBloc authenticationBloc; /// Creates a Bloc taking care of managing the login state of the app. CredentialsBloc({ required this.authenticationBloc, required this.userRepository, }) : super(const CredentialsInitial()); @override Stream<CredentialsState> mapEventToState(CredentialsEvent e) async* { if (event is LoginButtonPressed) { yield* _loginPressed(event); } if (event is RegisterButtonPressed) { yield* _registerPressed(event); } } Stream<CredentialsState> _loginPressed(CredentialsEvent e) async* {} Stream<CredentialsState> _registerPressed(CredentialsEvent e) async* {} } We\u2019ve decided to split the body of mapEventToState() into multiple functions in order to keep the code readable. If the authentication fails because of a wrong combination of username and password, an exception of type PlatformException is thrown. Stream<CredentialsState> _loginPressed(CredentialsEvent event) async* { yield const CredentialsLoginLoading(); try { await userRepository.authenticate( event.username, event.password, ); authenticationBloc.add(LoggedIn()); Flutter Complete Reference 699",
  ". Complete Flutter project example yield const CredentialsInitial(); } on PlatformException { yield const CredentialsLoginFailure(); } } Stream<CredentialsState> _registerPressed(CredentialsEvent event) async* { yield CredentialsRegisterLoading(); try { await userRepository.register( event.username, event.password, ); authenticationBloc.add(LoggedIn()); yield const CredentialsInitial(); } on PlatformException { yield const CredentialsRegisterFailure(); } } Note that authenticationBloc.add(LoggedIn()); tells the authentication bloc to move from the login page to the home page because the login happened with success. We\u2019ve done the same thing in the registration method too, but that\u2019s not always desired. If you need to con\ufb01rm the email address before being able to authenticate for example, remove the line so that a successful registration will not move to the home page. // contents of '/lib/blocs/credentials_bloc.dart' library credentials_bloc; export 'credentials_bloc/bloc.dart'; export 'credentials_bloc/events.dart'; export 'credentials_bloc/states.dart'; Like we did before with AuthenticationBloc, we\u2019re creating a library here as well in order to minimize the number of import in our \ufb01les. Flutter Complete Reference 700",
  ". Complete Flutter project example ..3 Localization \ufb01les We\u2019re going to localize our application using the \"manual\" approach described in chapter .2 because we don\u2019t have much content to internationalize. Since you\u2019re probably going to use this authentication example in a larger application, you could stick with intl instead because there might be a lot of content to localize. /// Localization delegate that builds an [AppLocalization] instance class AppLocalizationDelegate extends LocalizationsDelegate<AppLocalization> { /// Localization delegte of the app const AppLocalizationDelegate(); @override bool isSupported(Locale locale) => ['en','it'].contains(locale.languageCode); @override Future<AppLocalization> load(Locale locale) => SynchronousFuture<AppLocalization>(AppLocalization(locale)); @override bool shouldReload(LocalizationsDelegate<AppLocalization> old) => false; } This is the classic setup for a localization delegate. AppLocalization is created following the same structure we described in .., along with the extension method. /// Adds an useful localization method on a [BuildContext] extension LocalizationExt on BuildContext { String localize(String value) { final code = AppLocalization.of(this)?.locale.languageCode ?? \"en\"; final database = AppLocalization._localizedValues; if (database.containsKey(code)) { return database[code]?[value] ?? \"-\"; } else { return database[\"en\"]?[value] ?? \"-\"; } Flutter Complete Reference 701",
  ". Complete Flutter project example } } /// This class is responsible of translating strings into a certain /// languages defined by the [Locale] passed in the constructor. class AppLocalization { final Locale locale; const AppLocalization(this.locale); static AppLocalization? of(BuildContext context) => Localizations.of<AppLocalization>(context, AppLocalization); static final Map<String, Map<String, String>> _localizedValues = { \"en\": { \"title\": \"Login app\", \"login\": \"Login\", ... }, \"it\": { \"title\": \"Login app\", \"login\": \"Entra\", ... }, }; } Have a look at out GitHub repository to see the complete code. .3 Building the UI The UserRepository model is required by two blocs to authenticate the user and only a single instance of it is required. We could cache the repository using Provider so that, in the future, if we wanted to change the authentication provider, we\u2019d just need to make a small change in the void main() method. void main() => runApp( Provider<UserRepository>( create: (_) => FirebaseUserRepository(), Flutter Complete Reference 702",
  ". Complete Flutter project example child: const LoginApp(), ), ); class LoginApp extends StatelessWidget { const LoginApp(); @override Widget build(BuildContext context) { final repository = context.select((FirebaseUserRepository r) => r); return BlocProvider<AuthenticationBloc>( create: (_) => AuthenticationBloc(repository), child: MaterialApp(...), ); } } Create a new \ufb01le called routes/home_page.dart which is going to be the \ufb01rst route to appear in the UI when the app loads. It\u2019s a single widget with two children: the login form widget and the welcome page widget. When the authentication successfully happens, there is a sliding transition to the left which brings the user to the welcome page: Flutter Complete Reference 703",
  ". Complete Flutter project example This kind of animation is easy to obtain with a simple trick: we just need to create a TabBarView with no tabs at the top and the removal of the swiping gesture. In this way, we can use a controller to programmatically swipe the pages to the left/right on successful login/logout. return TabBarView( physics: const NeverScrollableScrollPhysics(), controller: tabController, children: const [ _LoginPage(), _WelcomePage(), ], ); In order to move tabs programmatically (moving tabs using the code rather than the \ufb01nger) we need to use a TabController. Thanks to the animateTo method we can obtain the traditional sliding transition for tabs using code rather than a swiping gesture. class HomePage extends StatefulWidget{ const HomePage(); @override _HomePageState createState() => _HomePageState(); } class _HomePageState extends State<HomePage> with SingleTickerProviderStateMixin { late final TabController tabController; @override void initState() { super.initState(); tabController = TabController( vsync: this, length: , ); } @override void dispose() { Flutter Complete Reference 704",
  ". Complete Flutter project example tabController.dispose(); super.dispose(); } /// Sliding animation to show the welcome page void loginTransition() { if (tabController.index != ) tabController.animateTo(); } /// Sliding animation to show the login page void logoutTransition() { if (tabController.index != ) tabController.animateTo(); } @override Widget build(BuildContext context) {...} } When calling loginTransition() the welcome page appears because the TabBarView widget is showing the second page, since authentication successfully executed. With logoutTransition() instead, the login form is shown because the user requested to logout. Those two methods are called by the bloc according to the emitted state: @override Widget build(BuildContext context) { return BlocBuilder<AuthenticationBloc, AuthenticationState>( builder: (context, state) { // This state is emitted on successful authentication if (state is AuthenticationSuccess) { loginTransition(); } // This state is emitted on logout if (state is AuthenticationRevoked) { logoutTransition(); } Flutter Complete Reference 705",
  ". Complete Flutter project example return TabBarView( physics: const NeverScrollableScrollPhysics(), controller: tabController, children: const [ _LoginPage(), _WelcomePage(), ], ); } ); } Thanks to BlocBuilder we can \"catch\" the incoming states and login/logout the user in both the backend (Firebase) and the frontend (moving from welcome page to the login page and vice versa). Since a const constructor cannot be directly applied to a Scaffold because not all of its contents are constant, we have created (in the same \ufb01le) two private classes. We\u2019re going to analyze them in the next section. \u009f This is a quite common strategy which can be used in all those cases where a \"root\" widget cannot be constant. For example, in this case there\u2019s no way to use a constant constructor because certain classes doesn\u2019t have one: children: const [ // NOT possible. Scaffold( appBar: AppBar(...), // AppBar doesn't have a const constructor body: BlocProvider(...), ), ] If we created a stateless widget dedicated to only contain the Scaffold with its content, we could then de\ufb01ne a constant constructor. You could place it in a separated \ufb01le but since the code is quite short and the Scaffold is logically a \"core\" part of the containing widget, we can make a class in the same \ufb01le. It should be private though, because it\u2019s not a public reusable widget: it\u2019s an internal part of a widget that\u2019s been moved outside for optimization purposes. // create this at the bottom.... class _LoginPage extends StatelessWidget { const _LoginPage(); Flutter Complete Reference 706",
  ". Complete Flutter project example @override Widget build(BuildContext context) => Scaffold(...); } // and then in the tab we can use... children: const [ //OK now it's possible _LoginPage(), ] If the widget can be reused by other widgets, put it in a separated \ufb01le and use a const constructor. If the widget is used only by a single widget because it\u2019s part of its \"internals\", put it in the same \ufb01le as a private class and use a const constructor. However, consider splitting classes into multiple \ufb01les if the code gets too long and logically you prefer keeping them separated. Actually it\u2019s not so important placing multiple widgets in the same place (with private classes) or splitted in various \ufb01les. It\u2019s up to you deciding what\u2019s better, no golden rules to apply: what\u2019s fundamental instead is that you try to use const as much as possible. ..1 Creating the login form It\u2019s our app\u2019s \ufb01rst widget appearing since authentication is required. As you\u2019ve just seen, we\u2019ve moved it into a separated class in order to have a useful constant constructor. class _LoginPage extends StatelessWidget { const _LoginPage(); @override Widget build(BuildContext context) { final repository = context.select((FirebaseUserRepository r) => r); final authBloc = context.bloc<AuthenticationBloc>(); return Scaffold( appBar: AppBar(...), body: BlocProvider( child: const LoginForm(), create: (context) => CredentialsBloc( userRepository: repository, Flutter Complete Reference 707",
  ". Complete Flutter project example authenticationBloc: authBloc, ), ), ); } } We\u2019ve placed the actual Form in a separated widget in order to have the possibility to de- clare a const constructor in the provider of the bloc. It could have been put in the same \ufb01le as a private widget but the code is quite long and thus we preferred moving it inside widgets/home_page/login_form.dart for a better logical order. Text controllers, disposals and form keys are not shown for brevity. class LoginForm extends StatefulWidget { const LoginForm(); @override _LoginFormState createState() => _LoginFormState(); } class _LoginFormState extends State<LoginForm> { // controllers, form key, call to 'dispose' here... @override Widget build(BuildContext context) { return LayoutBuilder( builder: (context, data) { var baseWidth = .; // For wider screen, such as tablets if (data.maxWidth >= baseWidth) { baseWidth = data.maxWidth / .; } return Column( mainAxisAlignment: MainAxisAlignment.center, children: [ SvgPicture.asset(\"assets/flutter_logo.svg\", width: baseWidth, Flutter Complete Reference 708",
  ". Complete Flutter project example ), ... ] ); } ); } } In order to make the app responsive, we\u2019ve used a LayoutBuilder to de\ufb01ne the width of the logo. It\u2019s \ufb01xed by default but if the screen gets bigger, the image changes dimensions according to the available space. In the same way, the baseWidth variable is used to determine the width of the TextEditingControllers of the form. Form( key: _formKey, child: Wrap( children: <Widget>[ SizedBox( width: baseWidth - , child: TextFormField(...), ), SizedBox( width: baseWidth - , child: TextFormField(...), ), ], ), ), Now that the logo and the form are setup, we need to take care of the Login and Register buttons. They\u2019re visible by default but, when tapped, a circular indicator must appear to indicate that a communication with the server is happening. This is quite easy to do with a BlocConsumer widget: BlocConsumer<CredentialsBloc, CredentialsState>( listener: (context, state) { if (state is CredentialsLoginFailure) { Flutter Complete Reference 709",
  ". Complete Flutter project example // Show a snackbar or a dialog to notify the failure } }, builder: (context, state) { if (state is CredentialsLoginLoading) { return const CircularProgressIndicator(); } return RaisedButton( child: Text(context.localize(\"login\")), onPressed: () { final state = formKey.currentState; if (state?.validate() ?? false) { _loginButtonPressed(context); } }, ); }, ), The listener is used to show a message dialog in response of an error state, which is very handy. In the builder instead we swap between a circular indicator and the login button according to the state emitted by the bloc. Note how we\u2019ve localized the text of the button and used a constant constructor. Of course the action should be performed only if the form has been properly \ufb01lled: void _loginButtonPressed(BuildContext context) { BlocProvider.of<CredentialsBloc>(context).add( LoginButtonPressed( username: _emailController.text, password: _passwordController.text ) ); } There\u2019s another BlocConsumer for the registration button which is basically identical with ex- ception for the name displayed in Text and the di\ufb00erent callback which \ufb01res an event of type RegisterButtonPressed. Flutter Complete Reference 710",
  ". Complete Flutter project example ..2 Creating the welcome page When the authentication successfully executes, the user can see the welcome page and thus start actually using our application. This widget is the starting point from which you can open new routes using a drawer, using action buttons and much more. We\u2019ve provided a logout button at the top-right corner of the app, in the Scaffold. class _WelcomePage extends StatelessWidget { const _WelcomePage(); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( centerTitle: true, title: const Text(\"LoginApp\"), actions: <Widget>[ IconButton( icon: const Icon(Icons.exit_to_app), onPressed: () => BlocProvider .of<AuthenticationBloc>(context) .add(LoggedOut()), ), ], ), drawer: const Drawer(), body: const Center( child: Text(\"You're logged in\"), ), ); } } Sending a LoggedOut event to the authentication bloc causes the TabBarView to swipe to the right and show the login form (in other words, we\u2019ve made a logout from the app). The bloc emits a state of type AuthenticationRevoked which is the actual logout from Firebase and a call to the tab controller in the UI: // Body of the 'HomePage' widget, inside the 'BlocBuilder' if (state is AuthenticationRevoked) { Flutter Complete Reference 711",
  ". Complete Flutter project example logoutTransition(); } .4 Testing the code Even if the testing section is at the bottom of the chapter, tests shouldn\u2019t be written and executed at the end of the development cycle. For example, as soon as the AuthenticationBloc is ready to be used in the UI you should also write tests for it. We recommend the usage of this kind of folder structure: test/ unit/ authentication_bloc_test.dart credentials_bloc_test.dart widget/ login_form_test.dart integration/ Create one folder for each testing strategy and then organize the \ufb01les inside as you prefer. It\u2019s an intuitive way to logically group entities together for a quicker search and a better mental order. ..1 Unit tests Create test/unit/authentication_bloc_test.dart which will test AuthenticationBloc, us- ing the bloc_test package. Here\u2019s where the fake user repository we created is very useful because it can be easily used as a mock for an authentication provider: void main() { final authenticationRepository = const TestUserRepository( fakeEmail: \"alberto@miola.it\", success: true, ); blocTest<AuthenticationBloc, AuthenticationEvent, AuthenticationState>( 'Authentication successful', build: () async => AuthenticationBloc(authenticationRepository), act: (bloc) async => bloc.add(LoggedIn()), expect: <AuthenticationState>[ Flutter Complete Reference 712",
  ". Complete Flutter project example AuthenticationSuccess(), ], ); blocTest<AuthenticationBloc, AuthenticationEvent, AuthenticationState>( 'Authentication failed', build: () async => AuthenticationBloc(authenticationRepository), act: (bloc) async => bloc.add(LoggedOut()), expect: <AuthenticationState>[ AuthenticationLoading(), AuthenticationRevoked(), ], ); } In the same way, inside test/unit/login_bloc_test.dart we\u2019re writing the code to test the login bloc. Again, thanks to the fake repository we\u2019re able to easily emulate the success or failure of the authentication just by changing the value of loginResult. void main() { final successRepository = const TestUserRepository( fakeEmail: \"alberto@goodtest.it\", success: true, ); final failedRepository = const TestUserRepository( fakeEmail: \"alberto@failtest.it\", success: false, ); blocTest<CredentialsBloc, CredentialsEvent, CredentialsState>( 'Successful login', build: () async => CredentialsBloc( authenticationBloc: AuthenticationBloc(successRepository), userRepository: successRepository ), act: (bloc) async => bloc.add(LoginButtonPressed()), expect: <CredentialsState>[ CredentialsLoginLoading(), Flutter Complete Reference 713",
  ". Complete Flutter project example CredentialsInitial(), ] ); blocTest<CredentialsBloc, CredentialsEvent, CredentialsState>( 'Registration failed', build: () async => CredentialsBloc( authenticationBloc: AuthenticationBloc(failedRepository), userRepository: failedRepository ), act: (bloc) async => bloc.add(RegisterButtonPressed()), expect: <CredentialsState>[ CredentialsRegisterLoading(), CredentialsRegisterFailure(), ] ); // more tests... } Any other model class you will create should be properly tested in a dedicated \ufb01le. You should write tests for a class as soon as it\u2019s ready to be used in the code so that you maintain the actual implementation and the testing in parallel. ..2 Widget tests Widget testing is also very important and the bloc_test package is essential when it comes to testing blocs. We\u2019re \ufb01rst going to create inside test/widget/mock_material.dart a reusable mock for a MaterialApp which will be very handy. class MockMaterialApp extends StatelessWidget { final Widget child; const MockMaterialApp({ required this.child }); @override Widget build(BuildContext context) { return MaterialApp( Flutter Complete Reference 714",
  ". Complete Flutter project example localizationsDelegates: [ const AppLocalizationDelegate(), GlobalMaterialLocalizations.delegate, GlobalCupertinoLocalizations.delegate, GlobalWidgetsLocalizations.delegate, ], supportedLocales: [ Locale.fromSubtags(languageCode: \"en\"), Locale.fromSubtags(languageCode: \"it\"), ], home: child, ); } } You\u2019d have done the same if the project worked with a CupertinoApp. Having a MaterialApp widget is important because, for example, localization delegates are required in order to test certain widgets relying on context.localize(\"my_value\"). Mocking blocs is no di\ufb00erent from what we\u2019ve seen in .: class MockAuthenticationBloc extends MockBloc<AuthenticationState> implements AuthenticationBloc {} void main() { final authBloc = MockAuthenticationBloc(); whenListen<AuthenticationState>( authBloc, Stream.fromIterable(<AuthenticationState>[ AuthenticationLoading(), AuthenticationSuccess(), ]) ); testWidgets(\"Testing how the authentication behaves\", (tester) async { await tester.pumpWidget( BlocProvider<AuthenticationBloc>.value( value: authBloc, child: MockMaterialApp( Flutter Complete Reference 715",
  ". Complete Flutter project example child: const WelcomePage(), ), ) ); final key = Key(\"HomeMessage\"); expect(find.byKey(key), findsOneWidget); }); } Again, mind a good folder structure to not mix di\ufb00erent types of tests in the same \ufb01le. For example, like it happens with unit test, each bloc should be tested in a separated \ufb01le for a better organization of the code. Flutter Complete Reference 716 A | Dart Appendix A.1 The I/O library The \"dart:io\" library is used to work with \ufb01les, directories, WebSockets, HTTP clients and processes. Almost any I/O operation in Dart is executed asynchronously to avoid blocking the application so results are returned either via Future<T> or Stream<T>. A..1 Files In Dart you can read a \ufb01le in two ways: all at once or lazily. Reading a \ufb01le entirely requires having enough memory. Note that Uint8List is basically a List<int> so its contents can be traversed regularly like if they were items of a list. final myFile = File('data.json'); // The entire content of 'data.txt' is read final String content = await myFile.readAsString(); // Each line of the files is represented by a String final List<String> contents = await myFile.readAsLines(); // Reads the file as a sequence of bytes (raw bytes) final Uint8List data = await myFile.readAsBytes(); Consider using the above approaches when the \ufb01le is not too big because it\u2019s entirely loaded in memory. In mobile apps you generally don\u2019t store big text \ufb01les so calling File.readAsString() in Flutter is not a problem. With larger \ufb01les, you probably should lazily read the contents using a stream. final myFile = File('data.json'); Flutter Complete Reference 717 Appendix A. Dart Appendix final Stream<List<int>> stream = myFile.openRead(); final fileLines = utf8.decoder .bind(stream) .transform(LineSplitter()); try { await for (var line in fileLines) {...} } catch (e) { print(e); } The \ufb01le is closed as soon as the await for terminates. The utf8 variable is a constant part of the dart:convert library. Writing to a \ufb01le can easily be done using the File class: File('something.txt').writeAsString(\"hello\"); File('another.abc').writeAsBytes([0x3, 0xA2]); When creating a File object you can also decide the mode, which can be one of the follow- ing: \u2022 FileMode.append: Read and write at the end of the \ufb01le (which is created if it doesn\u2019t exist) \u2022 FileMode.read: File can only be read \u2022 FileMode.write (default): Used to read and write the \ufb01le (which is overwritten if it already exists or created if it doesn\u2019t exist). \u2022 FileMode.writeOnly: the same as write but there\u2019s no possibility to read the contents. By default File is in write mode but if you don\u2019t want, for example, overriding the \ufb01le every time, just create it with the append mode. A..2 Directories Working with directories is quite easy thanks to class Directory which exposes many useful methods. An object of type Directory must contain a path on which operations are executed and it can be absolute or relative. \u009f In Flutter you should avoid using this class directly. Instead, prefer using the path_provider package which can be seen as the cross-platform version of Directory. Flutter Complete Reference 718 Appendix A. Dart Appendix It automatically resolves the correct paths to the various system folders. Like it happened with \ufb01les, most of the operations are asynchronous (or streams) so that the main application is not blocked by I/O operations. final dir = await Directory('folder1/folder2') .create(recursive: true); Thanks to recursive: true you\u2019re sure that the target directory (folder2) is created together with its parents (folder1) if they don\u2019t exist. There are a series of \"classic\" methods you\u2019d expect to be able to use on this kind of object: \u2022 createTemp(): creates a temporary directory in the given directory; \u2022 rename(): renames a directory; \u2022 exists(): used to determine whether a directory exists or not; \u2022 delete(): deletes a directory; \u2022 list(): lists all the sub-directories and \ufb01les There\u2019s also the possibility to use a Stream<FileSystemEvent> watch() to listen for actions happening in the directory such as insertions or deletions. A..3 Server side Dart With Dart you can easily setup an HTTP server using HttpServer, which heavily relies on Future<T> and Stream<T>, just by providing an IP address and a speci\ufb01c port. Thanks to its asynchronous nature, it can listen for requests and handle more than one at the same time: import 'dart:io'; Future<void> main() async { // Start server on localhost:8075 var server = await HttpServer.bind( InternetAddress.loopbackIPv4,  ); // Asynchronously handle incoming requests await for (HttpRequest request in server) { request.response.write(\"\"\"<html><body> Flutter Complete Reference 719 Appendix A. Dart Appendix <p>Hello client!</p> </body></html>\"\"\"); await request.response.close(); } } The class HttpRequest is a server-side object containing information about the received HTTP request. Of course you can have more control on the incoming requests but the approach is quite \"low level\" as you manually have to handle the entire response lifecylce. This is a more elaborate example: void main() { var server = await HttpServer.bind( InternetAddress.loopbackIPv4,  ); await for (HttpRequest request in server) { handle(request); } } void handle(HttpRequest request) { if (request.method == 'GET') { handleGet(request); } else { if (request.method == 'POST') { handlePost(request); } else { request.response ..statusCode = HttpStatus.methodNotAllowed ..write('${request.method} not handled') ..close(); } } } You can also run an HTTPS server using bindSecure() rather than bind(). For a complete Flutter Complete Reference 720 Appendix A. Dart Appendix tutorial about writing HTTP servers with Dart, refer to the o\ufb03cial documentation . You can \ufb01nd on https://pub.dev a very convenient package called http_server, a higher level way of building HTTP servers with Dart. It\u2019s easier to use: Future<void> main() async { var htmlPages = VirtualDirectory('www_root'); htmlPages.directoryHandler = (directory, request) { final homePath = Uri.file(directory.path).resolve('index.html'); final homePage = File(homePath.toFilePath()); htmlPages.serveFile(homePage, request); }; final server = await HttpServer.bind( InternetAddress.loopbackIPv4,  ); await server.forEach(htmlPages.serveRequest); } The VirtualDirectory class is a secure way to serve \ufb01les and directories in response to HTTP requests. It can be used to return HTML pages together with mime-types, potential error codes and so on. Be sure to check out the o\ufb03cial package documentation 2 to get more info. A.2 Date and time In Dart the Duration class is used to represent time spans and making conversions from one unit to another. It\u2019s used to represent the di\ufb00erence between two moments, which can be negative in case the di\ufb00erence were from a later time to an earlier one. // It also has 'days', 'milliseconds' and 'microseconds' final myWorkToday = Duration( hours: , minutes: , seconds: , ); 1https://dart.dev/tutorials/server/httpserver 2https://pub.dev/documentation/http_server/latest/http_server/http_server-library.html Flutter Complete Reference 721 Appendix A. Dart Appendix The above time span can be converted into seconds, for example, using the inSeconds getter which will return the total converted value of the interval. Look at this example to better understand how it works: final total = Duration( hours: , minutes: , seconds:  ); // 9 hours, 11 minutes and 37 seconds are equivalent to 33097 TOTAL seconds: //  *  +  *  +  = 33097 print(\"${total.inSeconds}\"); // prints  // Returns the remainder of the division of the duration by . In fact //  %  = 37 print(\"${total.inSeconds.remainder()}\"); // prints 37 In practice, inSeconds returns the representation of the entire duration in seconds. If you want to only extract the seconds parameter of Duration, you need to make a division. The same gist also applies to other getters such as inMinutes. final d1 = const Duration(minutes: ); final d2 = const Duration(seconds: ); final d3 = (d1 < d2) ? d1 + d2 : d1 - d2; Thanks to operator overloads you can easily compare objects and add/subtract values. If you want to represent a point in the time, use the DateTime class instead, which is also part of dart:core. Instances are generally created with one of the following constructors: final d1 = DateTime.now(); final d2 = DateTime(, , ); // May , 1997 final d3 = DateTime.utc(, DateTime.may, ); // uses the UTC timezone final d4 = DateTime.parse(\"-- ::10Z\"); Unless the utc() named constructor is used, the object is tied to the current device\u2019s date and time. Use a DateTime in conjunction with the \"intl\" package 3 to localize date and times. As always, be sure to check out the o\ufb03cial documentation for a complete overview of the numerous 3See chapter 13 Flutter Complete Reference 722 Appendix A. Dart Appendix available getters . final today = new DateTime.now(); final tomorrow = today.add(const Duration(day: )); A DateTime object doesn\u2019t change once created and has no operator overloads. Use the Stopwatch class if you\u2019re looking for a precise tool to measure the elapsed time between one or more calls. The two main methods you\u2019ll almost always use are start() and stop(): final sw = Stopwatch(); print(\"Startng...\"); sw.start(); await executeSomething(); sw.stop(); print(\"Elapsed = ${sw.elapsedMilliseconds}\"); print(\"Elapsed = ${sw.isRunning}\"); // false Enclose the parts of code you want to \"benchmark\" between start() and stop() to retrieve the elapsed milliseconds or microseconds. Note that reset() doesn\u2019t start or stop the timer: it just sets the counter back to . sw.start(); await Future.delayed(const Duration(seconds: )); sw.reset(); await Future.delayed(const Duration(seconds: )); sw.stop(); print(\"Elapsed = ${sw.elapsedMilliseconds}\"); // Elapsed = 1000 sw.start(); await Future.delayed(const Duration(seconds: )); await Future.delayed(const Duration(seconds: )); sw.stop(); print(\"Elapsed = ${sw.elapsedMilliseconds}\"); // Elapsed = 3000 Be sure to call reset() whenever you want to reset the timer. If you wish to convert the results in other time units, just wrap the total microseconds (or milliseconds) in a Duration object. // Measure 4https://api.dart.dev/stable/../dart-core/DateTime-class.html Flutter Complete Reference 723 Appendix A. Dart Appendix sw.start(); await Future.delayed(const Duration( seconds: , milliseconds:  )); sw.stop(); // Wrap the time in a convenient object final duration = Duration( microseconds: sw.elapsedMicroseconds ); print(duration); A.3 Obfuscating Dart code After you\u2019ve published a new project to the o\ufb03cial stores, someone could download your Flutter app\u2019s binary and use some tools to see the internals (including assets and source code). This process is always doable and it\u2019s called reverse engineering. You can use code obfuscation to make the binary harder for humans to understand. \u009f Note that code obfuscation does not encrypt your Dart \ufb01les: it just makes them harder for a human to read. In this way, the attacker will have harder times trying to \ufb01gure out the actual logic but data is still visible. In order to obfuscate a Flutter app, you need to make a build in release mode and append the --obfuscate \ufb02ag at the end of the command. In addition, there should be --split-debug-info to tell Flutter where output \ufb01les has to be written. flutter build appbundle --obfuscate --split-debug-info=/path/to/a/folder/ flutter build apk --obfuscate --split-debug-info=/path/to/a/folder/ flutter build ios --obfuscate --split-debug-info=/path/to/a/folder/ Files generated at the path speci\ufb01ed by --split-debug-info are needed if you want to de- obfuscate the binary in a second moment. Keep them in a secure place. We strongly recommend you to obfuscate your binary before publishing it to the o\ufb03cial stores. Flutter Complete Reference 724 Appendix A. Dart Appendix \u009f The usage of --split-debug-info could drastically reduce the code size so you should really use it. It also works without --obfuscate but you\u2019d better go for ob- fuscation + splitting. Code obfuscation doesn\u2019t work for web apps simply because there\u2019s no need for it (web apps are mini\ufb01ed, not obfuscated). Flutter Complete Reference 725 Appendix A. Dart Appendix Flutter Complete Reference 726 B | Flutter Appendix B.1 Riverpod Riverpod is a new state management library created by R\u00e9mi Rousselet, the technical reviewer of this book, which tries to \ufb01x some common problems a\ufb00ecting his provider package. It\u2019s basically \"provider on steroids\" that doesn\u2019t depend on Flutter and has many interesting features. Before describing it, there are a few points to clarify: . At the time of writing this book, Riverpod is a beta rewrite of Provider. As such, you can explore and test the library making demo projects but be aware that it\u2019s not ready yet to be used for production. Currently, the latest Riverpod version is ... . Provider is built on top of InheritedWidget to make it easier to use. Riverpod instead is a complete rewrite of InheritedWidget from scratch. . Riverpod won\u2019t be merged with Provider because they have core di\ufb00erences (see the above point). . Riverpod could replace Provider in the future but it\u2019s not sure. . If Riverpod will be proven to be a better alternative to Provider, then it might be a re- placement. Until that time, if it will ever come, continue using Provider which is stable and highly popular. As you may have guessed, at the moment Provider should still be your primary choice: Riverpod is currently a beta project that requires more testing and validations by the community. It\u2019s born to inherit all the bene\ufb01ts of Provider plus more: . Riverpod doesn\u2019t depend on InheritedWidget so Flutter is not a requirement anymore: this library can also be used with Dart! . In general, you can just use a ProviderScope as root widget (see the example below) Flutter Complete Reference 727 Appendix B. Flutter Appendix and you won\u2019t have to worry about runtime exceptions. No more surprises caused by a Provider<T> not being located at a certain level of the widget tree. It\u2019s a compile-safe solution. . With Riverpod you can have multiple providers of the same type. States can be disposed when not needed anymore. . Last but not least... \"riverpod\" is the anagram of \"provider\"! Riverpod comes in three \ufb02avors: riverpod (Dart), \ufb02utter_riverpod (Flutter) or hooks_riverpod (Flutter + the hooks package). For Flutter applications, if you don\u2019t use the hooks 1 package, just go for \ufb02utter_riverpod. B..1 Usage In Riverpod, a \"provider\" is the same concept you\u2019ve been used to see up to now: it exposes a value that can be shared by one or more widgets in the subtree. We\u2019re now showing how to create the simple famous \"Flutter counter app\", which just does a +1 each time a button is pressed. Let\u2019s start with the basics: void main() { runApp( const ProviderScope( child: CounterApp(), ), ); } You can decide to not place ProviderScope right after runApp() but then, be aware it has to be put one level above the values you\u2019re trying to access. The ProviderScope class enables Riverpod for the entire project and it should really be placed at the root of the tree. Providers can be declared as global variables but since we don\u2019t really like them, an equivalent but better looking solution is the following: // Create this in a file called lib/providers/counter.dart abstract class CounterProvider { static final provider = StateProvider<int>((ref) => ); } 1See ..1 to read about \"Flutter Hooks\" Flutter Complete Reference 728 Appendix B. Flutter Appendix We prefer creating a dedicated class called CounterProvider which encloses a static reference of the provider our app is going to use. We also recommend creating a providers/ folder with all the providers you use (one per \ufb01le). A StateProvider<T> is a provider able to react to state changes, similarly to what a ChangeNotifierProvider does. We now have two ways to read the value: . A ConsumerWidget is basically a StatelessWidget with the ability to listen to changes on providers. Under the hood, it extends StatefulWidget so it can be put in the widget tree as usual. class CounterApp extends ConsumerWidget { const CounterApp(); void _buttonPressed(BuildContext context) { ... } @override Widget build(BuildContext context, ScopedReader watch) { final value = watch(CounterProvider.provider).state; return Scaffold( body: Center( child: Text(\"$value\"), ), floatingActionButton: FloatingActionButton( onPressed: () => _buttonPressed(context), child: const Icon(Icons.add), ), ); } } Rather than extending StatelessWidget, we use ConsumerWidget which exposes a very useful watch parameter. It\u2019s used to trigger a rebuild whenever the state of the listened provider changes (so the Scaffold will be rebuild along with its children). . Alternatively, you can use the classic Consumer widget inside a StatelessWidget to obtain the same result. However, in this case you can optimize performance by rebuilding only widgets that actually depend on a provider. It\u2019s a better approach. class CounterApp extends StatelessWidget { Flutter Complete Reference 729 Appendix B. Flutter Appendix const CounterApp(); void _buttonPressed(BuildContext context) { ... } @override Widget build(BuildContext context) { return Scaffold( body: Center( child: Consumer( builder: (context, watch, child) { final count = watch(CounterProvider.provider); return Text('${count.state}'); } ), ), floatingActionButton: FloatingActionButton( onPressed: () => _buttonPressed(context), child: const Icon(Icons.add), ), ); } } In this case, only the Text widget is rebuilt and not only the entire subtree. In case you had a nested widget, use the child parameter to \"cache\" what doesn\u2019t depend on a provider. Center( child: Consumer( builder: (context, watch, child) { final count = watch(CounterProvider.provider).state; return Column( children: [ child, Text('$count') ] ); }, child: Container(...), ), Flutter Complete Reference 730 Appendix B. Flutter Appendix ), In this way, the Container (along with its children) is cached. Changes on the state will only a\ufb00ect Column and Text. Both ways are \ufb01ne: you have more control on rebuilds (and thus performance) with Consumer so it\u2019s generally a better choice but it reduces the readability of the code. We still need to implement the actual increasing of the counter, which happens using read(): void _buttonPressed(BuildContext context) => context.read(CounterProvider.provider).state++; Riverpod\u2019s read() is the equivalent of Provider\u2019s read<T>(): it simply reads the value of a provider without listening to it. When outside of the widget tree, like in this case, it\u2019s the only way you have to access the state of a provider. The library has then two ways to access the state: \u2022 use watch() inside a ConsumerWidget or Consumer to listen to changes. Rebuilds will happen whenever the state changes. It can be used only inside the widget tree. \u2022 use read() when you need to simply read the state of a provider without listening to it. It has to be used when accessing the state of a provider outside of the widget tree. Note that context.read() can be used both inside and outside of the widget tree. When you need to listen to changes, consider using Consumer to avoid unnecessary rebuilds. Here\u2019s the kind of providers you can use: \u2022 Provider<T>. It exposes a read-only value. It\u2019s the most simple kind of provider, commonly used as a \"cache\" to share data (model classes) among widgets. You could use it in the following way: abstract class UserDataProvider { static final provider = Provider<UserData>((ref) => UserData()); } class UserData { var name = ''; var surname = ''; var age = ; } Any UI widget can get access to data about the user regardless their position in the tree. We will see later how the ref parameter can be useful. Flutter Complete Reference 731 Appendix B. Flutter Appendix \u2022 StateProvider<T>. It exposes a value to the outside so that it can be modi\ufb01ed and listened/read from. You\u2019ve already seen an example in the above \"counter\" app ex- ample where the exposed value can be read or listened: it is something similar to the ChangeNotifierProvider of the provider package. \u2022 FutureProvider<T>. Kind of provider that asynchronously creates a value: it can be seen as a combination of Provider<T> and FutureBuilder<T>. For example, let\u2019s see how you can easily make a GET request and synchronously return data to the UI. abstract class RequestProvider { static final provider = FutureProvider<UserInfo>((ref) async { final url = \"https://website.com/api/json/something\"; final response = await dio.get<String>(url); return UserInfo.fromJson(response.data); }); } // Exposes some getters such as nickname, age and birthday class UserInfo { ... } There\u2019s no need for the classic FutureBuilder<T> setup because Riverpod will take care of everything for you. The syntax couldn\u2019t be more expressive than this: @override Widget build(BuildContext context, ScopedReader watch) { final AsyncValue<UserInfo> jsonString = watch(RequestProvider.provider).state; return jsonString.when( loading: () => const CircularProgressIndicator(), error: (err, stackTrace) => const SomeErrorWidget(), data: (userInfo) => SomeInfoWidget( nickname: userInfo.nickname, age: userInfo.age, birthday: userInfo.birthday, ), ); } Flutter Complete Reference 732 Appendix B. Flutter Appendix A FutureProvider<T> returns a very useful object called AsyncValue<T> which is used to safely handle asynchronous data. With this setup, the UI is automatically rebuild when the data is ready. \u2022 StreamProvider<T>. It works exactly as a FutureProvider<T> with the only di\ufb00erence that the created value is a Stream<T> rather than a Future<T>. In particular, when you have one or more resources to be disposed, be sure to use the autoDispose() named constructor: abstract class ExampleProvider { static final provider = StreamProvider.autoDispose<String>((ref) async* { final source = SomeStreamSource(); // You can also perform cleanup operations ref.onDispose(() => source.close()); await for (final event in source.stream) { yield \"$event\"; } }); } The ref parameter is a reference to the current StreamProvider<T> object and it can be used to dispose resources via onDispose(). The provider returns a AsyncValue<T> so the syntax is the same as before: Consumer( builder: (context, watch, _) { final msgStream = watch(ExampleProvider.provider).state; return msgStream.when( loading: () { ... }, error: (err, stackTrace) { ... }, data: (eventData) { ... }, ); } ); You can also use FutureProvider.autoDispose() to have more control on asynchronous re- Flutter Complete Reference 733 Appendix B. Flutter Appendix quests. In the o\ufb03cial documentation 2 there\u2019s an article showing how easy it is to cancel HTTP requests when no-longer needed. Even if Riverpod is a complete rewrite of the Provider package, there are still many similarities in the names and usages. B..2 Combining providers In Riverpod, the constructor of any provider always exposes a ref parameter. Very simply, it\u2019s just a reference to the \"current\" provider object on which you\u2019re working. You\u2019ve already seen it in action: StreamProvider.autoDispose<String>((ref) async* { ref.onDispose(() { ... }); }); In this case, ref is a reference to the current StreamProvider<T> instance in which you\u2019re working. Other than being useful to call onDispose(), it\u2019s also great when it comes to combining two or more providers (potentially, in\ufb01nite providers!): abstract class YearProvider { static final provider = StateProvider<int>((_) => ); } abstract class EventProvider { static final provider = FutureProvider<List<Event>>((ref) async { final year = ref.watch(YearProvider.provider); return downloadEvents(year); }); } In this example, EventProvider depends on another provider because it\u2019s listening to changes. In particular, ref is a reference to the current EventProvider object which makes possible watching (or also reading) another source. // Don't listen, just read final year = ref.read(YearProvider.provider); This would have worked anyway. In the Provider package you cannot declare two providers of the same type but in Riverpod there isn\u2019t this restriction. There can be two providers exposing a variable of the same type (even the same object) without any problem: 2https://riverpod.dev/docs/concepts/modi\ufb01ers/auto_dispose#example-cancelling-http-requests-when-no- longer-used Flutter Complete Reference 734 Appendix B. Flutter Appendix \u2022 Provider. The following code compiles but you\u2019ll get a runtime error because there are two providers holding the same type. The Consumer<T> doesn\u2019t know which provider has to be taken into account. MultiProvider( providers: [ Provider<MyModel>(create: (_) => const MyModel()), Provider<MyModel>(create: (_) => const MyModel()), ], child: Consumer<MyModel>( builder: (context, model, _) => Text(\"$model\"), }, ); \u2022 Riverpod. No runtime errors because there\u2019s no dependency on the widget tree. We\u2019re using abstract classes for providers so Flutter doesn\u2019t care about the types of the models. abstract class AlbertoProvider { static final provider = StateProvider<String>((_) => \"Alberto\"); } abstract class RemiProvider { static final provider = StateProvider<String>((_) => \"R\u00e9mi\"); } // somewhere in the widget tree Consumer( builder: (context, watch, _) { final alberto = watch(AlbertoProvider.provider).state; final remi = watch(RemiProvider.provider).state; return Text(\"$alberto $remi\"); } ) Riverpod doesn\u2019t rely on the widget tree so errors like \"Could not \ufb01nd the correct provider above...\" can never happen. Flutter Complete Reference 735 Appendix B. Flutter Appendix B..3 Testing Testing an application is very straightforward and you don\u2019t even need to use particular libraries. Riverpod can be tested in pure Dart applications (Flutter isn\u2019t a dependency) along with the usual test and mockito packages. Here\u2019s how you\u2019d setup tests for the counter app. // counter_provider_test.dart abstract class CounterProvider { static final provider = StateProvider<int>((_) => ); } class Listener extends Mock { void call(int value); } For simplicity, we directly create the CounterProvider in the same \ufb01le but actually it should be placed somewhere else, inside a good folders structure. Listener is a convenient callable class 3 we\u2019ve created to keep tracks of signals sent by the provider to listeners. // still inside counter_provider_test.dart void main() { test('Notifies listeners when the state changes', () { final container = ProviderContainer(); final listener = Listener(); // \"Catch\" changes emitted from the provider and forward // them to our listener CounterProvider.provider.watchOwner(container, (value) => listener(value.state) ); // Make sure the initial state is 0 verify(listener()).called(); verifyNoMoreInteractions(listener); // Increment by 1 container.read(counterProvider).state++; 3See: ..1 callable classes Flutter Complete Reference 736 Appendix B. Flutter Appendix // Make sure the state is 1 verify(listener()).called(); verifyNoMoreInteractions(listener); }); } In Flutter, ProviderContainer is internally used by Riverpod so you don\u2019t need to care about it. It\u2019s a very important class used to store the state of a provider. The actual testing is done with verify() from the mockito package. . We make sure the initial state is really . verify(listener()).called(); The called() call makes sure that the method has been called exactly 1 time . We make sure that nothing more has happened with verifyNoMoreInteractions(). When it comes to widget testing, you just need to wrap the subtree in a ProviderScope and you\u2019re already good to go. There\u2019s nothing more to setup because it\u2019s really a \"normal\" widget test process. void main() { testWidgets('Counter increment', (tester) async { await tester.pumpWidget( const ProviderScope( child: CounterApp() ) ); // Counter must start at 0 expect(find.text(''), findsOneWidget); // Tap the FAB and trigger a rebuild await tester.tap(find.byIcon(Icons.add)); await tester.pump(); // Counter now has to be 1 expect(find.text(''), findsOneWidget); }); } Flutter Complete Reference 737 Appendix B. Flutter Appendix Be sure to have a look at the o\ufb03cial documentation . It\u2019s rich of examples and it is guaranteed to be a growing source of information about this new state management library. Be sure to keep an eye on their o\ufb03cial website to stay updated on the latest changes. B.2 Local databases It\u2019s very common nowadays deferring data storage and processing to the server so that the mobile device doesn\u2019t have any heavy computing to execute. In particular, databases are hosted on a server which exposes the contents to the outside with a REST API or an SDK (like it happens with Firebase). This is quite useful: . the user can access data from di\ufb00erent devices (so no hardware dependencies); . no internal memory occupied by databases or other kind of \ufb01les; . no I/O disk operations since everything happens via internet. You might have guessed that relying on a local data storage is not a good idea. What is absolutely \ufb01ne instead (and it\u2019s also very common) is caching some data on the device using a database. It may be useful for: \u2022 storing user\u2019s preferences (settings, values, \ufb02ags...); \u2022 caching data so that certain features of your app can be used even when there\u2019s no internet connection. We\u2019ve already seen in chapter 20 the shared_preferences package but it\u2019s only good for simple key- value data. If you\u2019re looking for a better way to persist information on the device, we recommend the usage of one of the following packages. B..1 Hive (NoSQL) Hive 5 is a fast, lightweight and secure NoSQL database for both Dart and Flutter with built-in encryption. It can be initialized whenever you want but you should really do it at startup, at the very \ufb01rst line of the main() method: // For Dart apps void main() async { Hive.init(\"/valid/path/on/filesystem/\"); 4https://riverpod.dev 5https://pub.dev/packages/hive Flutter Complete Reference 738 Appendix B. Flutter Appendix await Hive.openBox(\"my_data\"); } // For Flutter apps void main() async { await Hive.initFlutter(); await Hive.openBox(\"my_data\"); runApp(const MyFlutterApp()); } Data are stored inside \"boxes\" which are automatically encrypted. You could, for example, create two di\ufb00erent boxes called \"app_settings\" and \"cached_contents\" to store di\ufb00erent values of your app. Once the box has been opened, reading and writing data is straightforward: // Get a reference to the box containing the data final data = Hive.box(\"my_data\"); // Store a value data.put(\"name\", \"Alberto\"); // Retrieve a value final name = data.get<String>(\"name\", defaultValue: \"-\"); Don\u2019t try to open a box more than once otherwise an exception will be thrown. This might be another reason to open boxes as soon as possible when the app launches (you won\u2019t have to call bool isBoxOpen(String name) repeatedly). It would be better if you created a separated \ufb01le only containing the database\u2019s keys, such as: // 'hive_keys.dart' class HiveKeys { const HiveKeys._(); static const name = \"name\"; static const password = \"passwd\"; } In this way you can later use HiveKeys.name rather than a plain \"name\" string, which is less error-prone and better in terms of maintenance. Of course you can also store complex objects, not only primitive types such as double, DateTime, lists and maps. This \ufb01le represents data Flutter Complete Reference 739 Appendix B. Flutter Appendix about a particular device con\ufb01guration: @HiveType() class Settings extends HiveObject { // Every field has to be annotated with 'HiveField' and an integer // ascending value for subsequent members (, , ...) @HiveField() String deviceName; } class SettingsAdapter extends TypeAdapter<Settings> { @override final typeId = ; @override Settings read(BinaryReader reader) { return Settings() ..deviceName = reader.read(); } @override void write(BinaryWriter writer, Settings settings) { writer.write(settings.deviceName); } } In this example, Settings is the model class we\u2019re going to store and it has to be marked with the HiveType annotation. The adapter can be automatically generated using hive_generator, which is recommended, but for this simple example we\u2019ve written it by hand. \u009f The documentation is very detailed and rich of interactive examples, so you should de\ufb01nitely have a look at it for more info: https://docs.hivedb.dev.. Flutter Complete Reference 740 Appendix B. Flutter Appendix B..2 SQLite (SQL) There\u2019s a very popular SQLite package called \"sq\ufb02ite\" , which is also covered in the o\ufb03cial Flutter documentation. SQL databases cannot run on mobile devices because there is no server installed; for this reason, .sqlite \ufb01les are an alternative way to go. The sq\ufb02ite package can easily be initialized in this way: import 'package:path/path.dart' as path; import 'package:sqflite/sqflite.dart'; void main() async { WidgetsFlutterBinding.ensureInitialized(); // Automatically get the database folder according to the current OS final dbPath = await getDatabasesPath(); // Use 'join' to correctly build the path to the database file final dbName = path.join(dbPath, 'settings.db'); final database = openDatabase(dbName); // Maybe expose the reference to the database using Provider runApp(const FlutterApp()); } path is the cross-platform way to work with \ufb01lesystem\u2019s paths. The above setup is only required if the database is going to be used across the entire app. If you plan to use it only in particular areas of your app (like storing settings), avoid working in main() an prefer creating a Future<T> which can be simply awaited by a FutureBuilder<T>: Future<Database> initialize() async { final dbPath = await getDatabasesPath(); final dbName = path.join(dbPath, 'settings.db'); return openDatabase(dbName); } In the openDatabase() method there\u2019s also the possibility to specify the version using an integer value. It\u2019s generally used together with onCreate, onUpgrade or onDowngrade callbacks to specify actions to perform when a migration of the database is required. 6https://pub.dev/packages/sq\ufb02ite Flutter Complete Reference 741 Appendix B. Flutter Appendix openDatabase(dbName, // Called if the database doesn't exist prior to calling 'openDatabase' onCreate: (db, version) {...}, // Called if there is no 'onCreate' callback OR 'version' has changed // and it's higher than the previous value onUpgrade: (db, version) {...}, // Called when 'version' is lower than the previous value onDowngrade: (db, version) {...}, version:  ); In practice, you should always start with version: 1 and de\ufb01ne (if needed) an onCreate callback to execute initialization queries on the database for the \ufb01rst time it\u2019s created. Use onUpgrade when a new version is available to make a migration to the new con\ufb01guration. Remember that changing the version number triggers the upgrade or downgrade callbacks. openDatabase(dbName, onCreate: (db, version) { return db.execute( \"CREATE TABLE something (id INTEGER PRIMARY KEY, descr TEXT)\", ); } ); Queries should be placed in a dedicated \ufb01le: we put a CREATE statement directly in the method just to keep the example easy. Rather than manually writing queries, the library exposes a series of useful methods: \u2022 INSERT: returns the internal id of the record. final id = await db.insert('table_name', { 'id': '', 'descr': 'custom text', }); \u2022 UPDATE: the jolly (?) placeholder can be used but it requires a non-empty arguments list. It returns the number of updated rows. final count = await db.update('table_name', {'descr': 'some text here'}, where: 'id = ?' Flutter Complete Reference 742 Appendix B. Flutter Appendix whereArgs: [''], ); \u2022 DELETE: returns the number or deleted records. final count = await db.delete('table_name', where: 'id = ?', whereArgs: [''] ); \u2022 SELECT: returns a list of maps. final list = db.query('table_name', columns: ['name', 'type']); If you used one or more placeholders in a query, the arguments are required otherwise the engine wouldn\u2019t know how to handle the symbol. Visit the o\ufb03cial documentation to learn more about this package, which also supports transactions and many other common SQL commands (such as LIKE in combination with wildcards). B.3 Initializing data at startup We have seen multiple times that certain packages, such as hive or hydrated_bloc, require an immediate initialization (even before calling runApp(). The main() is a good place to perform this kind of setup but it might become a problem: void main() async { // Hydrated bloc HydratedBloc.storage = await HydratedStorage.build(); // Firebase await Firebase.initializeApp(); await FirebaseFirestore.instance.clearPersistence(); await FirebaseAdMob.instance.initialize(appId: \"...\"); await FirebaseMessaging().requestNotificationPermissions(); // Something else await LibraryA.initialize(); await LibraryB.initialize(); // Finally, start the app Flutter Complete Reference 743 Appendix B. Flutter Appendix runApp(const MyFlutterApp()); } As you can see, in some cases there might be too much initialization to do before calling runApp(). Waiting for the setup of a single component could be \ufb01ne but when there is a series of await (like above) the situation is di\ufb00erent. The approach must change: start the app as soon as possible and wait for initialization directly in the UI. . Create a model class used to gather all the startup methods required by your app. It should really return a Future<T> so that it can be awaited in the home page as we\u2019re going to show in a moment: // app_startup.dart abstract class AppStartup { static Future<void> setup() async { // Hydrated bloc BlocSupervisor.delegate = await HydratedBlocDelegate.build(); // Firebase await Firebase.initializeApp(); await FirebaseFirestore.instance.clearPersistence(); await FirebaseAdMob.instance.initialize(appId: \"...\"); await FirebaseMessaging().requestNotificationPermissions(); // Something else await LibraryA.initialize(); await LibraryB.initialize(); } } Since we don\u2019t like global functions (and global variables) at all, we\u2019ve created AppStartup which just exposes the setup() method. The class is abstract because it doesn\u2019t need to be instantiated (you could have also created a regular class with a private constructor). . In your app\u2019s home widget, use the FutureBuilder<T> pattern to await for the completion of the initialization. As usual, startupFuture is a variable initialized inside the initState method as we\u2019ve explained in detail in chapter . FutureBuilder<void>( future: startupFuture, builder: (context, snapshot) { Flutter Complete Reference 744 Appendix B. Flutter Appendix if (snapshot.connectionState == ConnectionState.done) { return const HomePage(); } return const SplashScreen(); } ) In this way, a splash screen appears (or anything else) while packages and plugins are executing their initialization phases. Once ready, the actual contents of the home page appear. This is a nice way to gracefully initialize data in your app rather than using a bunch of asyn- chronous calls directly inside the main() method. We recommend you to follow this guide- line: \u2022 If you have only one or two initialization methods to call (and they execute quickly), there\u2019s no need for a splash screen. Just put them before runApp() and you\u2019ll be \ufb01ne. \u2022 If you have a lot of initialization methods to call (and they require time), there\u2019s the need for a splash screen. It lets the user know that something is loading but the app is still responsive! Use this approach if you also need to use an internet connection on startup. In order to decide if initialization methods are \"slow\" or \"quick\" run many tests and measure, on average, how much time they take. It\u2019s up to you deciding if they are fast or if there\u2019s the need for a splash. However, if you want to stay safe, always go for a graceful initialization with a FutureBuilder<T>. B.4 Accessibility An application is accessible when it can be used by a broad range of people without creating barriers for users of any age. For example, someone might need the help of a screen reader to interact with the device or simply a stronger color contrast to be more comfortable. Flutter has some built-in facilities to increase your app\u2019s accessibility level: \u2022 Screen readers for Android and iOS are very good at understanding what\u2019s being displayed in the UI but they aren\u2019t always accurate. You can help them making the user experience even more pleasant with the Semantic 7 widget: 7https://api.\ufb02utter.dev/\ufb02utter/widgets/Semantics-class.html Flutter Complete Reference 745 Appendix B. Flutter Appendix const Semantics.fromProperties( child: SomeButtonWidget( child: Text(\"Play\") ), properties: SemanticsProperties( label: \"Play music button\", hint: \"Tap to play music\", button: true, enabled: true, value: \"Play\" ) ) The Semantics widget is used to describe what a piece of UI means. It\u2019s very helpful for screen readers because they get a more accurate idea of what\u2019s being displayed. In the above example, you can see how we\u2019ve used Semantics to describe a \"Play\" button widget. // No constant constructor for the default 'Semantics()' Semantics( child: SomeButtonWidget( child: Text(\"Play\") ), label: \"Play music button\", ) You should create new instances using the fromProperties() named constructor since it can be constant. Regardless, in both cases there are more than 50 parameters you can set so be sure to visit the documentation for a detailed overview. \u2022 A natural physical factor is the loss of focus by the eyes when a human gets older so smaller fonts become harder to read. Flutter automatically determines the size of the text according to the hardware of the device but you can manually change the setting: // By default this is .0 Text(\"Some text\", textScaleFactor: ., ), In this way, the text is % of the normal size. It might be a good idea, for exam- ple, using hydrated_bloc to store user\u2019s settings and among them de\ufb01ning a value for the textScaleFactor. Flutter Complete Reference 746 Appendix B. Flutter Appendix \u2022 Don\u2019t make \"tappable\" items too small as they might become a di\ufb03cult target. The minimum recommended size is 48x48 8 but you could raise this lower limit to 56x56 to be even more safe. \u2022 Make sure that buttons always \"do something\" and in general, any widget that requires interaction should trigger a visual response. For example, if a button is disabled it shouldn\u2019t simply ignore the \ufb01nger tap. Instead, open an dialog or notify the user about why the button is disabled. // Don't do this IgnorePointer( ignoring: true, child: RaisedButton(...) ) Whereas GestureDetector is used to add tap callbacks to widgets, IgnorePointer does the opposite: it disables any kind of interaction on the children. In the above example, the button cannot be pressed and it doesn\u2019t provide animations or visual feedbacks (looks like it\u2019s \"freezed\"). Avoid this pattern and prefer something else, like this: RaisedButton( child: const Text(\"Go!\"), onPressed: () => _showSnackBar(\"Cannot press this because...\"), ) The button can still be pressed, which is what the user expects, but you give a reason of why it doesn\u2019t perform a certain action. \u2022 Background and foreground should be easily distinguishable thanks to e\ufb03cient color con- trasts. For example, you shouldn\u2019t use white text on a light grey background since the contrast is not strong enough to clearly recognize the text. Eyes shouldn\u2019t be stressed to much. Other than the usual three trees maintained by Flutter, the usage of Semantics creates a fourth tree called \"semantic tree\" and this is used by screen readers. These tools traverse it to get information about widgets but the accuracy depends on you: the more parameters you de\ufb01ne in Semantics the better the help to the users will be. 8https://\ufb02utter.dev/docs/development/accessibility-and-localization/accessibility#accessibility-release- checklist Flutter Complete Reference 747 Appendix B. Flutter Appendix B.5 The Flutter community If you want to get involved in the community, along with millions of developers around the world sharing your passion for Flutter, we\u2019ve good news for you. You can attend conferences, watch video tutorials, follow online courses and stay in touch with many developers via Discord, Twitter or Reddit. \u2022 Flutter Europe - https://\ufb02uttereurope.dev It\u2019s the biggest Flutter conference in Europe which took place for the \ufb01rst time in Poland, at the end of January . People from all over the world gather together to attend the talks made by people from the Google team and open source maintainers. In case you missed the event, check out their o\ufb03cial YouTube channel to see the replays. The various talks are held during the day and in the evenings there usually is a party. \u2022 Flutter Community - https://medium.com/\ufb02utter-community/ The \"Flutter Community\" is an organization aimed at providing a central place for com- munity made Flutter packages and content. They write a lot of articles on Medium and develop popular Flutter packages for https://pub.dev , such as: . RxDart, which makes Dart\u2019s streams and controllers even better; . get_it, a simple service locator for Dart and Flutter; . \ufb02utter_webview_plugin, a native way to communicate with WebView; . sticky_headers, headers for scrollable contents; . workmanager, to schedule background tasks on Android and iOS; . and much more... 9https://pub.dev/publishers/\ufb02uttercommunity.dev/packages Flutter Complete Reference 748 Appendix B. Flutter Appendix You can get in touch with many passionate developers also on Reddit, at r/FlutterDev, and via Discord, which is the o\ufb03cial channel of the Reddit page. \u2022 Code with Andrea - https://codewithandrea.com Code with Andrea is a website about learning Flutter by Andrea Bizzotto. This includes a growing collection of over 50 weekly video tutorials and articles; courses are also on o\ufb00er for students looking for a more structured approach. The \ufb01rst part of our book, about Dart, is used by courses at codewithandrea.com to in- troduce the language to students! There\u2019s also a YouTube channel with some free courses, such as the ones about REST APIs, state management and Flutter widgets. \u2022 Reso Coder - https://resocoder.com Learn Flutter app development with tutorials built to make the new concepts stick thanks to the Reso Coder YouTube channel. It\u2019s a very popular source of informative contents from the Dart / Flutter world which provides both video tutorials and written articles. Flutter Complete Reference 749 Appendix B. Flutter Appendix The channel is very popular for its TDD and DDD complete courses: a series of + videos about Flutter best practices following speci\ufb01c development designs. \u2022\u2022 Fireship - https://\ufb01reship.io Fireship is a project created by Je\ufb00Delaney which o\ufb00ers a series of videos and courses about Flutter, ranging from state management to best practices and UI tutorials. The main strength of Fireship are courses and tutorials about Firebase, with a notable series called Flutter Firebase - The Full Course. If you\u2019re looking for a more direct and \"daily\" approach to the community, you can join the Discord server or reach the o\ufb03cial Reddit channel. You can \ufb01nd every link in the \"Community\" section of the o\ufb03cial Flutter website . In particular, we recommend you to keep an eye on: \u2022 the o\ufb03cial Flutter YoubTube Channel. It\u2019s full of interesting contents such as the \"Boring show\" and the \"Widget of the week\" series; \u2022 https://twitter.com/FlutterDev and https://twitter.com/dart_lang to stay updated on the 10https://\ufb02utter.dev/community Flutter Complete Reference 750 Appendix B. Flutter Appendix latest changes and news on the Flutter and Dart world; \u2022 the o\ufb03cial GitHub repositories of both Dart and Flutter in which you can \ufb01nd spoilers about the upcoming new features, join the conversations and contributing by opening new issues. B.6 Flutter SDK management As always, the o\ufb03cial documentation is the best place to get an updated step-by-step guide 11 to install Flutter in your operating system (Windows, macOS, Linux and Chrome OS). We strongly recommend you the usage of Android Studio or VS Code since they have an o\ufb03cial Flutter plugin. \u009f As of Flutter ., the Flutter SDK includes the full Dart SDK so you don\u2019t need to install them separately. This is very convenient because everything is centralized and managed by a single command line tool (called flutter). A fresh new Flutter install downloads \ufb01les from the stable source channel, which is the safest one in terms of stability. Your production software should rely on the stable version of the Flutter and Dart SDK. However, you can also download the SDKs from other channels (sorted from the less to the most stable): . master. The absolutely latest cutting edge build you can get. It generally works but sometimes it might break. Use it if you want to play with the latest features and \ufb01xes but absolutely don\u2019t rely on this channel for stability. . dev. The latest build with a complete test coverage. It\u2019s a bit more stable than \"master\" because everything is completely tested so there\u2019s high chance that everything will work well. You shouldn\u2019t rely your production code on this channel unless you heavily test your build (but consider if it\u2019s worth the e\ufb00ort). . beta. Once the build has arrived at this stage, it will land to \"stable\" in a couple of weeks. Even if not completely reliable, contents on this channel are quite stable. If your production app cannot wait for a feature on the \"stable\" channel, you can switch to \"beta\" and use it. . stable. This is the safest build of the engine as well as the recommended channel for production app releases. Very rarely there might be issues on this channel but the team comes to the rescue with hot\ufb01xes. 11https://\ufb02utter.dev/docs/get-started/install Flutter Complete Reference 751 Appendix B. Flutter Appendix Even if the default Flutter installation is in sync with stable, you can easily change the channel to get another build. Run the following commands in sequence to ensure being on the latest build of the selected channel: # replace <name> with 'master', 'dev', 'beta' or 'stable' $ flutter channel <name> $ flutter upgrade Using the flutter channel command you can see in which channel you\u2019re currently on. If you want to upgrade your current Flutter installation with the latest version available, just use the upgrade command. $ flutter upgrade You should also make sure that all of your dependencies listed in the pubspec.yaml are always up to date. Rather than manually checking the versions at pub.dev, which can be very tedious if you have a lot of dependecies, just run this command: $ flutter pub upgrade It automatically updates all of your dependencies to the latest version. However, before running pub upgrade you should use the pub outdated command which tells you which packages can safely be upgraded without having versioning con\ufb02icts. B..1 Web and Desktop At the time of publishing this book (September ), Flutter for web is in the beta channel but the desktop support (Windows, macOS and Linux) is still in early alpha on the dev channel. Once they will be released in the stable channel, we will cover these new platforms in a future version of the book. However, you can still move to the beta channel and unlock the Flutter web preview: $ flutter channel beta $ flutter upgrade $ flutter config --enable-web Your Android and iOS apps will look exactly the same also on web and desktop, with very high performance. The developer really needs to write the code only once because the compiler will take care of porting Flutter natively to any platform. Here\u2019s a general overview of how the web support works: . There\u2019s no need for a browser plugin because Flutter generates web contents by simple using Flutter Complete Reference 752 Appendix B. Flutter Appendix HTML, CSS and JavaScript. Rather than compiling to native ARM code, as it happens for mobile devices, Dart is compiled to JavaScript so that web browsers can understand it. . Thanks to Dart\u2019s optimized JavaScript compiler, the entire Flutter framework (including the core) along with your Dart source code are compiled into a single, mini\ufb01ed source \ufb01le that can be deployed to any web server. . Any project made for a mobile app can be ported to web. If you have worked with layout responsiveness in mind, there will be no extra work to do. A desktop is like a big horizontal tablet so your layout should adapt to various sizes. If you want to try building your Flutter app on desktop as well, there\u2019s currently a bit more of setup to do. Being desktop support in early alpha, complex apps might not work as expected. Follow the latest update guide on the o\ufb03cial Flutter website and then run the following commands before creating a new project: $ flutter channel dev $ flutter upgrade $ flutter config --enable-macos-desktop $ flutter config --enable-linux-desktop $ flutter config --enable-windows-desktop You can now create a new project with desktop support. At the time of publishing this book, macOS is the best supported OS since it has a lot of similarities with iOS. Linux is at a good stage as well but Windows still has a long way to go. Creating builds for di\ufb00erent OSes, as always, can\u2019t be easier than this: $ flutter build macos $ flutter build linux $ flutter build windows The o\ufb03cial documentation 12 recommends to not release a desktop app until support for this mode lands to the stable channel. You can add desktop support to an existing Flutter project running this command from the root project directory: $ flutter create . Most of the pub packages are available for web but only a few support desktop (you can really count them by hand). Visit https://\ufb02utter.dev/web and https://\ufb02utter.dev/desktop to get the latest news about the progress the team is making on those platform to make them land on the stable channel. 12https://\ufb02utter.dev/desktop Flutter Complete Reference 753 Appendix B. Flutter Appendix Flutter Complete Reference 754 Index Symbols \u2013obfuscate . . . . . . . . . . . . . . . . . . . . . . . . . . . \u2013split-debug-info . . . . . . . . . . . . . . . .,  ...? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ,  ._() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  <T> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . == . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .,  => . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ?? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ,  ?[] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . [] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . , ,  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .447 A abstract . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109 AccelerometerEvent . . . . . . . . . . . . . . . . . 560 accelerometerEvents . . . . . . . . . . . . . . . . .562 add() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .621 addPerson . . . . . . . . . . . . . . . . . . . . . . . . . . .435 AdMob . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .623 AdSense . . . . . . . . . . . . . . . . . . . . . . . . . . . . .623 AdSize . . . . . . . . . . . . . . . . . . . . . . . . . , 631 AlertDialog . . . . . . . . . . . . . . . . . . . . ., 547 allOf() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 441 analysis_options.yaml . . . . . . . . . . . . . . .211 AngularDart . . . . . . . . . . . . . . . . . . . . . . . . . 20 AnimatedAlign . . . . . . . . . . . . . . . . . . . . . .388 AnimatedBuilder . . . . . . . . . . . . . . . . . . . . 399 AnimatedContainer . . . . . . . . . . . . . . . . . 386 AnimatedCrossFade . . . . . . . . . . . . . . . . . 391 AnimatedDefaultTextStyle . . . . . . . . . . 389 AnimatedIcon . . . . . . . . . . . . . . . . . . . . . . . 392 AnimatedOpacity . . . . . . . . . . . . . . . . . . . 388 AnimatedPadding . . . . . . . . . . . . . . . . . . . 389 AnimatedPhysicalModel . . . . . . . . . . . . .390 AnimatedPositioned . . . . . . . . . . . . . . . . . 390 AnimatedSize . . . . . . . . . . . . . . . . . . . . . . . 391 AnimatedWidget . . . . . . . . . . , , 397 Animation library . . . . . . . . . . . . . . . . . . . 385 AnimationBuilder . . . . . . . . . . . . . . . . . . . 397 AnimationController . . . . . . ., , 405 AnimationStatus . . . . . . . . . . . . . . . . . . . . 408 annotation . . . . . . . . . . . . . . . . . . . . . . . . . . . 93 AOT . . . . . . . . . . . . . . . . . . . . . . . . . ., , 29 AppBar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257 AppLocalization . . . . . . . . . . . , , 374 ARB \ufb01le . . . . . . . . . . . . . . . . . . . . . . . , 378 ARM . . . . . . . . . . . . . . . . . . . . . . . . . , , 27 arrayContains . . . . . . . . . . . . . . . . . . . . . . . 621 arrow syntax . . . . . . . . . . . . . . . . . . . . . . . . . 62 ART . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 as . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 AsciiDecoder() . . . . . . . . . . . . . . . . . . . . . . 431 AspectRatio . . . . . . . . . . . . . . . . . . . . . . . . .521 assert . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 AssetBundle . . . . . . . . . . . . . . . . . . . . . . . . .503 AssetsAudioPlayer . . . . . . . . . . . . . . . . . . 523 async . . . . . . . . . . . . , , , , 172 Flutter Complete Reference 755 Index async* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168 AsyncSnapshot<T> . . . . . . . , , 602 AsyncValue<T> . . . . . . . . . . . . . . . . . . . . 733 attribute() . . . . . . . . . . . . . . . . . . . . . . . . . . 435 AuthResult . . . . . . . . . . . . . . . . . . . . . . . . . 655 authStateChanges() . . . . . . . . . . . . . . . . . 657 availableCameras() . . . . . . . . . . . . . . . . . . 556 await . . . . . . . . , \u2013, , , 183 await for . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172 B bang operator . . . . . . . . . . . . . . . . . . . . . . . . 48 BarcodeDetector . . . . . . . . . . . . . . . . . . . . 644 BaseOptions . . . . . . . . . . . . . . . . . . . . . . . . 482 Battery . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 568 BatteryState . . . . . . . . . . . . . . . . . . . . . . . . 568 benchmark/ . . . . . . . . . . . . . . . . . . . . . . . . . 664 bind() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .720 bindSecure() . . . . . . . . . . . . . . . . . . . . . . . . 720 BLoC . . . . . . . . . . . . . . . . . . . . . . . . . . , 313 BlocBuilder . . . . . . . . . . . . . . . . . . . . . . . . . 291 BlocBuilder<B,S> . . . . . . . . . . . . . . . . . . 333 BlocBuilder<T, K> . . . . . . . . . . . . . . . . . 318 BlocConsumer<B,S> . . . . . . . . . . . . . . . 334 BlocListener<B,S> . . . . . . . . . . . . ., 333 BlocObserver . . . . . . . . . . . . . . . . . . . . . . . .323 BlocProvider<T> . . . . . . . . . . . . . . . . . . . 316 blocTest() . . . . . . . . . . . . . . . . . . . . . . . . . . . 447 BottomNavigationBar . . . . . . . . . . , 581 BoxConstraints . . . . . . . . . . . . . . . . . . . . . .278 BoxDecoration . . . . . . . . . . . . . . . . . , 225 BoxShadow . . . . . . . . . . . . . . . . . . . . . . . . . 224 break . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .59 bridge . . . . . . . . . . . . . . . . . . . . . , , \u201328 build_runner . . . . . . . . . . . . . . . . . . . . . . . .425 BuildContext . . . . . . . . . . . . . . . . . . . . . . . .217 ButtonBar . . . . . . . . . . . . . . . . . . . . . . . . . . 261 ByteData . . . . . . . . . . . . . . . . . . . . . . . . . . . 504 C CachedNetworkImage . . . . . . . . . . ., 510 call() . . . . . . . . . . . . . . . . . . . . . . . . , , 100 called() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 737 CameraController . . . . . . . . . . . . . . . . . . . 556 CameraDescription . . . . . . . . . . . . . . . . . . 556 CameraPreview . . . . . . . . . . . . . . . . . . . . . 559 cancel() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177 CanvasKit . . . . . . . . . . . . . . . . . . . . . . . . . . .243 cascade notation . . . . . . . . . . . . . . . . . . . . . .75 case . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 cast<T>() . . . . . . . . . . . . . . . . . . . . . . . . . . 150 catch . . . . . . . . . . . . . . . . . . . . . . . . . . . \u2013132 catchError() . . . . . . . . . . . . . . . . . . . . , 160 ChangeNoti\ufb01er . . . . . . . . . . . . . . . . . . . . . . 299 ChangeNoti\ufb01erProvider . . . . . . . . ., 301 checkConnectivity() . . . . . . . . . . . . . . . . . 569 ChildIcon . . . . . . . . . . . . . . . . . . . . . . . . . . . 595 Chip . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 563 clearPersistence() . . . . . . . . . . . . . . . . . . . .619 code obfuscation . . . . . . . . . . . . . . . . . . . . 724 collection() . . . . . . . . . . . . . . . . . . . . . . . . . . 615 ColorTween . . . . . . . . . . . . . . . . . . . . . . . . . 404 Column . . . . . . . . . . . . . . . . . . . . . . . . , 221 CommonFinders . . . . . . . . . . . . . . . . . . . . .450 Comparable<T> . . . . . . . . . . . . . . . . . . . . 127 compareTo() . . . . . . . . . . . . . . . . . . . . . . . . 127 completion() . . . . . . . . . . . . . . . . . . . . . . . . 443 ComponentElement . . . . . . . . . . . . . . . . . 245 compute() . . . . . . . . . . . . . . . . . . . . . . . . . . .185 con\ufb01gure() . . . . . . . . . . . . . . . . . . . . . . . . . . 648 Connectivity . . . . . . . . . . . . . . . . . . . , 570 ConnectivityResult . . . . . . . . . . . . . . . . . . 569 const . . . . . . . . . . . . . . . . . . . . . . . . . . , \u201394 const constructor . . . . . . . . . . . . . . . . . . . .237 constant constructor . . . . . . . . . . . . . . . . . .91 ConstrainedBox . . . . . . . . . . . . . . . . . . . . . 536 constructor assignment . . . . . . . . . . . . . . 121 Consumer . . . . . . . . . . . . . . . . . . . . . . . . . . . 729 Consumer<T> . . . . . . . . . . . . . . . . . . . . . . 306 ConsumerWidget . . . . . . . . . . . . . . . . . . . .729 Container . . . . . . . . . . . . . . . . . . . . . . , 225 Flutter Complete Reference 756 Index contains() . . . . . . . . . . . . . . . . . . . . . . . . . . . 154 context.select() . . . . . . . . . . . . . . . . . . . . . . 312 context.watch<T>() . . . . . . . . . . . . . . . . 311 continue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .59 copyWith() . . . . . . . . . . . . . . . . . . . . . \u2013104 counterText . . . . . . . . . . . . . . . . . . . . . . . . . 540 covariant . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107 createElement() . . . . . . . . . . . . . . . . . . . . . 244 createRenderObject() . . . . . . . . . . . . . . . 244 CrossFadeState . . . . . . . . . . . . . . . . . . . . . .391 cubit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330 Cubit<T> . . . . . . . . . . . . . . . . . . . . . . . . . . 331 CupertinoActionSheet . . . . . . . . . . . . . . . 594 CupertinoActionSheetAction . . . . . . . . 594 CupertinoAlertDialog . . . . . . . . . . . . . . . 270 CupertinoApp . . . . . . . . . . . . . . . . . . , 341 CupertinoButton . . . . . . . . . . . . . . . . . . . . 271 CupertinoDatePicker . . . . . . . . . . . . . . . . 593 CupertinoDatePickerMode . . . . . . . . . . 594 CupertinoDialogAction . . . . . . . . . . . . . . 271 CupertinoLocalizations . . . . . . . . . . . . . . 366 CupertinoPageRoute . . . . . . . . . . . . . . . . 343 CupertinoPageRoute<T> . . . . . . . . . . . 344 CupertinoPageSca\ufb00old . . . . . . . . . . . . . . 268 CupertinoSegmentedControl . . . . . . . . .595 CupertinoTabBar . . . . . . . . . . . . . . . . . . . 268 CupertinoTabSca\ufb00old . . . . . . . . . . . . . . . 268 CupertinoThemeData . . . . . . . . . . . . . . . 287 currentStep . . . . . . . . . . . . . . . . . . . . . . . . . 586 Curve . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 401 CurvedAnimation . . . . . . . . . . . . . . . . . . . 402 CurvedAnimations . . . . . . . . . . . . . . . . . . 401 Curves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 400 Curves.linear . . . . . . . . . . . . . . . . . . . . . . . . 387 Custom animation . . . . . . . . . . . . . . . . . . 385 CustomPaint . . . . . . . . . . . . . . , , 644 D dart2js . . . . . . . . . . . . . . . . . . . . . . . . . . , 243 dart:convert . . . . . . . . . . . . . . . . . . . . . . . . . 418 dart:\ufb03. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249 DartPad . . . . . . . . . . . . . . . . . . . . . . . . . . , 29 DataCell . . . . . . . . . . . . . . . . . . . . . . . . . . . . 588 DataColumn . . . . . . . . . . . . . . . . . . . . . . . . 587 DataRow . . . . . . . . . . . . . . . . . . . . . . . . . . . .588 DataTable . . . . . . . . . . . . . . . . . . . . . . . . . . .587 DataTableSource . . . . . . . . . . . . . . . . . . . . 590 DateFormat . . . . . . . . . . . . . . . . . . . . . . . . . 365 DateTime . . . . . . . . . . . . . . . . . , , 723 DDD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .186 default . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56 DefaultAssetBundle . . . . . . . . . . . . . . . . . 503 DefaultTabController . . . . . . . . . . . . . . . .582 defaultValue . . . . . . . . . . . . . . . . . . . . . . . . .426 delete() . . . . . . . . . . . . . . . . . . . . . . . . ., 743 Dependency Injection . . . . . . . . . . . . . . . 193 DeviceInfoPlugin . . . . . . . . . . . . . . . . . . . . 568 DevTools . . . . . . . . . . . . . . . . . . . . . . . . , 459 DI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193 diamond . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139 diamonds . . . . . . . . . . . . . . . . . . . . . . . . . . . 139 dio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . , 482 DIP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193 Directory . . . . . . . . . . . . . . . . . . . . . . . . . . . .718 DismissDirection . . . . . . . . . . . . . . . . . . . . 546 Dismissible . . . . . . . . . . . . . . . . . . . . . , 547 dispose . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297 distanceBetween() . . . . . . . . . . . . . . . . . . .566 Divider . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .576 do while . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .59 DocumentSnapshot . . . . . . . . . . . . . . . . . .619 download() . . . . . . . . . . . . . . . . . . . . . , 490 Draggable<T> . . . . . . . . . . . . . . . . . , 553 DragTarget<T> . . . . . . . . . . . . . . . . . . . . 553 drain() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171 Drawer . . . . . . . . . . . . . . . . . . . . . . . . . , 573 DrawerHeader . . . . . . . . . . . . . . . . . . . . . . .575 DropdownButtonFormField<T> . . . . 542 DropdownMenuItem . . . . . . . . . . . . . . . . 542 DropdownMenuItem<T> . . . . . . . . . . . 541 Flutter Complete Reference 757 Index Duration . . . . . . . . . . . . . . . . . . . . . . . , 722 DVM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . , 21 dynamic . . . . . . . , , , \u2013, 146 E Element . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245 else . . . . . . . . . . . . . . . . . . . . . . . . . . . , , 61 embedder . . . . . . . . . . . . . . . . . . . . . . . . . . . 241 enableFlutterDriverExtension() . . . . . .455 engine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .242 ensureInitialized() . . . . . . . . . . . . . . . . . . . 556 enterText() . . . . . . . . . . . . . . . . . . . . . . . . . .457 enum . . . . . . . . . . . . . . . . . . . . . . . . . . . . . , 44 equals() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 Equatable . . . . . . . . . . . . . . . . . . . . . . , 319 Error . . . . . . . . . . . . . . . . . . . . . . . . . . . , 135 event loop . . . . . . . . . . . . . . . . . . . . . . \u2013183 every() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154 Exception . . . . . . . . . . . . ., , , 135 exception . . . . . . . . . . . . . . . . . . . . . . . . . . . .128 Expanded . . . . . . . . . . . . . . . . . . . . . . , 286 expect() . . . . . . . . . . . . . . . . . . . . . . . . , 447 explicitToJson . . . . . . . . . . . . . . . . . . . . . . .428 export . . . . . . . . . . . . . . . . . . . . . . . . . ., 663 extend . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133 extends . . . . . . . . . . . . . . . , \u2013, 139 extension . . . . . . . . . . . . . . . . . . . . . . . . . . . .122 extension methods . . . . . . . . . . . . . . . . . . 121 external . . . . . . . . . . . . . . . . . . . , , 149 F FAB . . . . . . . . . . . . . . . . . . . . . . . . . . . ., 259 Face . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 636 factory . . . . . . . . . . . . . . . . . . . . . . . . . . , 120 FFI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249 FFI.DynamicLibrary . . . . . . . . . . . . . . . . 250 FFI.NativeFunction() . . . . . . . . . . . . . . . .250 FieldValue.delete() . . . . . . . . . . . . . . . . . . 622 File . . . . . . . . . . . . . . . . . . . . . . . . . . . . , 718 File.readAsString() . . . . . . . . . . . . . . . . . . 717 FileMode.append . . . . . . . . . . . . . . . . . . . .718 FileMode.read . . . . . . . . . . . . . . . . . . . . . . .718 FileMode.write . . . . . . . . . . . . . . . . . . . . . . 718 FileMode.writeOnly . . . . . . . . . . . . . . . . .  \ufb01nal . . . . . . ., , , , , , , , \u2013,  \ufb01nally . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  \ufb01nd . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  \ufb01ndAllElements() . . . . . . . . . . . . . . .,  \ufb01ndElements() . . . . . . . . . . . . . . . . . ., 433 Finder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  \ufb01ndsNothing . . . . . . . . . . . . . . . . . . . . . . . .  \ufb01ndsNWidget . . . . . . . . . . . . . . . . . . . . . . .  \ufb01ndsOneWidget . . . . . . . . . . . . . . . . . . . . .  \ufb01ndsWidgets . . . . . . . . . . . . . . . . . . . . . . . . 450 Firebase.initializeApp(); . . . . . . . . . . . . . 609 FirebaseAdMob . . . . . . . . . . . . . . . . . . . . . 627 FirebaseAuthException . . . . . . . . . . . . . .657 FirebaseFirestore.instance . . . . . . . . . . . 615 FirebaseMessaging . . . . . . . . . . . . . . . . . . 646 Firestore . . . . . . . . . . . . . . . . . . . . . . . , 612 FlatButton . . . . . . . . . . . . . . . . . . . . . , 290 Flutter Hooks . . . . . . . . . . . . . . . . . . . . . . .  \ufb02utter_driver . . . . . . . . . . . . . . . . . . . . . . .  \ufb02utter_test . . . . . . . . . . . . . . . . . . . . . . . . . 449 FlutterFire . . . . . . . . . . . . . . . . . . . . . . . . . . 606 FlutterLogo . . . . . . . . . . . . . . . . . . . . . . . . . 393 fold() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155 followedBy() . . . . . . . . . . . . . . . . . . . . . . . . 154 fontFamily . . . . . . . . . . . . . . . . . . . . . . . . . . 287 for . . . . . . . . . . . . . . . . . . . . . . . . . ., , 146 for-in . . . . . . . . . . . . . . . . . . . . . . . . . . . . . , 66 forEach . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150 Form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .531 FormData . . . . . . . . . . . . . . . . . . . . . . . . . . . 488 forward() . . . . . . . . . . . . . . . . . . . . . . . . . . . .396 frameBuilder . . . . . . . . . . . . . . . . . . . . . . . . 508 Function . . . . . . . . . . . . . . . . . . . . . . . . . ., 64 Future.delayed() . . . . . . . . . . . . . . . . . . . . .168 Future.wait<T>() . . . . . . . . . . . . . . . . . . .160 Future<T> . . . . . . , , , , 166 Flutter Complete Reference 758 Index Future<T>.delayed() . . . . . . . . . . . . . . . 160 Future<T>.error() . . . . . . . . . . . . . . . . . . 160 Future<T>.sync() . . . . . . . . . . . . . . . . . . 161 Future<T>.value() . . . . . . . . , , 166 FutureBuilder<T> . . . . . . . . . . . . . \u2013479 FutureProvider<T> . . . . . . . . . . . . , 732 G generator . . . . . . . . . . . . . . . . . . . . . . . , 171 GestureDetector . . . . . . . . . . . , , 544 get . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . , 106 getPositionStream() . . . . . . . . . . . . . . . . . 564 getRow() . . . . . . . . . . . . . . . . . . . . . . . . . . . .592 getter . . . . . . . . . . . . . . . . . . . . . . . . . . . , 151 getText() . . . . . . . . . . . . . . . . . . . . . . . . . . . .457 GlobalKey . . . . . . . . . . . . . . . . . . . . . . . . . . 234 GlobalKey<FormState> . . . . . . . . . . . . 531 GlobalKey<NavigatorState>() . . . . . . 359 google-services.json . . . . . . . . . . . . . . . . . .608 google_fonts . . . . . . . . . . . . . . ., , 218 GoogleServices-Info.plist . . . . . . . . . . . . .609 group . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 440 group() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 441 GyroscopeEvents . . . . . . . . . . . . . . . . . . . . 560 H hasData . . . . . . . . . . . . . . . . . . . . . . . . . . . . .477 hasError . . . . . . . . . . . . . . . . . . . . . . . . . . . . 477 hashCode . . . . . . . . . . . . . . . . . . . . . . .\u2013152 HashMap<K,V> . . . . . . . . . . . . . . . . . . . . 149 Hero . . . . . . . . . . . . . . . . . . . . . . . . . . . , 413 hide . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78 Hive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 738 home . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .347 Hook<T> . . . . . . . . . . . . . . . . . . . . . . . . . . .602 hot reload . . . . . . . . . . . . . . . . . . . . . . , 211 http.Client . . . . . . . . . . . . . . . . . . . . . . . . . . 479 HTTPMock . . . . . . . . . . . . . . . . . . . . . . . . . 445 HttpRequest . . . . . . . . . . . . . . . . . . . . . . . . 720 HTTPRequest<T> . . . . . . . . . . . . . . . . . 474 HttpServer . . . . . . . . . . . . . . . . . . . . . . . . . . 719 HydratedBloc . . . . . . . . . . . . . . . . . . , 325 HydratedCubit<T> . . . . . . . . . . . . . . . . .333 I IconButton . . . . . . . . . . . . . . . . , , 543 identical() . . . . . . . . . . . . . . . . . . . . . . , 152 identity() . . . . . . . . . . . . . . . . . . . . . . . . . . . .409 if . . . . . . . . . . . . . . , , , , , 146 IgnorePointer . . . . . . . . . . . . . . . . . . . . . . . 747 Image . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 505 Image.memory() . . . . . . . . . . . . . . . . . . . . .506 Image.network() . . . . . . . . . . . . . . . . . . . . .506 ImageLabeler . . . . . . . . . . . . . . . . . . . . . . . .645 immutable class . . . . . . . . . . . . . . . . . . . . . . 92 implement . . . . . . . . . . . . . . . . . . . . . . . . . . .133 implements . . . . . . . . . . . \u2013, , 139 Implicit animation . . . . . . . . . . . . . . . . . . 385 import . . . . . . . . . . . . . . . . . . . . . . . . . . . ., 77 index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .43 InheritedWidget . . . . . . . . . . . . . . . . , 296 initializer list . . . . . . . . . . . . . . . , , 109 initializing formal . . . . . . . . . . . . . . . . . , 86 initialRoute . . . . . . . . . . . . . . . . . . . . , 347 initialState . . . . . . . . . . . . . . . . . . . . . . . . . . 315 initState . . . . . . . . . . . . . . . . . . . . . . . ., 297 inMinutes . . . . . . . . . . . . . . . . . . . . . . . . . . . 722 InputDecoration . . . . . . . . . . . . . . . . . . . . .531 inSeconds . . . . . . . . . . . . . . . . . . . . . . . . . . . 722 insert() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .742 Integration test . . . . . . . . . . . . . . . . . . . . . .437 interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111 Interface Segregation Principle . . . . . . 191 internationalization . . . . . . . . . . . . . . . . . .366 intl . . . . . . . . . . . . . . . . . . . , , , 380 Intl.message . . . . . . . . . . . . . . . . . . . . . . . . . 376 Intl.plural() . . . . . . . . . . . . . . . . . . . . . . . . . 381 invokeMethod<T>() . . . . . . . . . . . . . . . . 252 is . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .52 isA<T>() . . . . . . . . . . . . . . . . . . . . . . . . . . .442 isBoxOpen . . . . . . . . . . . . . . . . . . . . . . . . . . 739 Flutter Complete Reference 759 Index isDefaultAction . . . . . . . . . . . . . . . . . . . . . 595 isDestructiveAction . . . . . . . . . . . . . . . . . .595 isolate . . . . . . . . . . . . . . . . . . . . . . . . . . , 180 Isolate.spawn() . . . . . . . . . . . . . . . . . . . . . . 184 Iterable<T> . . . . . . . . . . . . . . . . . . . . . . . . 167 Iterator<T> . . . . . . . . . . . . . . . . . . . . . . . . 169 J JIT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 JSON . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 417 jsonDecode . . . . . . . . . . . . . . . . . . . . . \u2013420 jsonEncode . . . . . . . . . . . . . . . . . . . . . . . . . .420 JsonKey() . . . . . . . . . . . . . . . . . . . . . . . . . . .426 JSONPlaceholder . . . . . . . . . . . . . . . . . . . .473 JsonSerializable() . . . . . . . . . . . . . . . . . . . 424 K Key . . . . . . . . . . . . . . . . . . . . . . . . . . . . , 235 L late . . . . . . . . . . . . . . . . . . . . . . . , , , 89 late \ufb01nal . . . . . . . . . . . . . . . . . . . . . . . . . ., 88 Latin1Decoder() . . . . . . . . . . . . . . . . . . . . .431 LayoutBuilder . . . . . . . . . . . . . , , 530 library (keyword) . . . . . . . . . . . . . . . . . . . . .77 library aliases . . . . . . . . . . . . . . . . . . . . . . . . 77 limit() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .620 limitToLast() . . . . . . . . . . . . . . . . . . . . . . . .620 LinearGradient . . . . . . . . . . . . . . . . . . . . . . 224 LinkedHashMap<K,V> . . . . . . . . . . . . . 149 linter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .211 Liskov Substitution Principle . . . . . . . . 190 List.\ufb01lled() . . . . . . . . . . . . . . . . . . . . . . . . . . 145 List.generate() . . . . . . . . . . . . . . . . . . . . . . 145 List.unmodi\ufb01able() . . . . . . . . . . . . . . . . . . 145 List<T> . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141 listen() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178 ListTile . . . . . . . . . . . . . . . . . . . . . . . . , 617 ListView . . . . . . . . . . . . . . . . . . . . . . . , 233 ListView.builder . . . . . . . . . . . . . . . . . . . . .222 load() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 503 loadingBuilder . . . . . . . . . . . . . . . . . . . . . . 506 loadString() . . . . . . . . . . . . . . . . . . . . . . . . . 503 Locale . . . . . . . . . . . . . . . . . . . . . . . . . ., 369 localization . . . . . . . . . . . . . . . . . . . . . . . . . .366 Localization delegate . . . . . . . . . . . . . . . . 372 LSP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .191 M machine learning . . . . . . . . . . . . . . . . . . . . 633 mainAxisAlignment . . . . . . . . . . . . . . . . . 219 map() . . . . . . . . . . . . . . . . . . . . . . . . . . , 171 Map<K,V> . . . . . . . . . . . . . . . . . . . . . . . . . 147 Map<String, dynamic> toJson() . . . . 420 Matcher . . . . . . . . . . . . . . . . . . . . . . . . . . . . .450 MaterialApp . . . . . . . . . . . . . . ., , 341 MaterialPageRoute . . . . . . . . . . . . . . . . . . 343 MaterialPageRoute<T> . . . . . . . . . . . . .344 Matrix4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409 maxLength . . . . . . . . . . . . . . . . . . . . . . . . . .539 MediaQuery . . . . . . . . . . . . . . . . . . . . . . . . .280 method channels . . . . . . . . . . . . . . . . . . . . 251 MethodChannel . . . . . . . . . . . . . . . . . . . . . 251 mixin . . . . . . . . . . . . . . . . . . . . . . \u2013, 152 mock . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .444 mockito . . . . . . . . . . . . . . . . . . . . . . . . , 445 model class . . . . . . . . . . . . . . . . . . . . . . . . . .418 MultiBlocProvider . . . . . . . . . . . . . . . . . . .335 MultiProvider . . . . . . . . . . . . . . . . . . . . . . . 309 N named route . . . . . . . . . . . . . . . . . . . . . . . . 344 NavigationRail . . . . . . . . . . . . . . . . . . . . . . 579 NavigationRailDestination . . . . . . . . . . .580 Navigator . . . . . . . . . . . . . . . . . . . . . . , 351 Navigator.of() . . . . . . . . . . . . . . . . . . . . . . . 344 new . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ., 89 non-nullable . . . . . . . . . . . . . . . . . . . . . . \u201348 notifyListeners() . . . . . . . . . . . . . . . . . . . . 300 null . . . . . . . . . . . . ., \u2013, , , , 86 nullable . . . . . . . . . . . . . . . . . . . . . . . . . . ., 48 num . . . . . . . . . . . . . . . . . . . . . . . . . . . . . , 140 Flutter Complete Reference 760 Index O Object . . . . . . . . . . . . . . . . . . . . . . . , , 124 ObjectKey . . . . . . . . . . . . . . . . . . . . . . . . . . 234 obscureText . . . . . . . . . . . . . . . . . . . . . . . . . 540 OEM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .25 on . . . . . . . . . . . . . . . . . . . . . . . . . \u2013, 134 onAccept . . . . . . . . . . . . . . . . . . . . . . . . . . . .554 onBatteryStateChanged . . . . . . . . . . . . . 568 onDateTimeChanged . . . . . . . . . . . . . . . . 594 onDestinationSelected . . . . . . . . . . . . . . . 580 onDispose() . . . . . . . . . . . . . . . . . . . . . . . . . 733 onGenerateRoute . . . . . . . . . . . . . . . . . . . .345 onSort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 588 onStepCancel . . . . . . . . . . . . . . . . . . . . . . . 586 onStepContinue . . . . . . . . . . . . . . . . . . . . . 586 onWillAccept . . . . . . . . . . . . . . . . . . . . . . . .554 OOP . . . . . . . . . . . . . . . . . . . . . . . . . . . . , 105 open closed principle . . . . . . . . . . . . . . . . 188 openDatabase() . . . . . . . . . . . . . . . . . . . . . 741 operator== . . . . . . . . . . . . . . . . . . . . , 152 orderBy() . . . . . . . . . . . . . . . . . . . . . . . . . . . 620 OrientationBuilder . . . . . . . . . . . . . . . . . . 282 override . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56 P package (keyword) . . . . . . . . . . . . . . . . . . . .77 PageRouteBuilder . . . . . . . . . . . . . . , 415 PageStorageKey<T> . . . . . . . . . . . . . . . .236 PaginatedDataTable . . . . . . . . . . . . . . . . .590 Paint . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .643 paint() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 641 parse() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 part . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 424 path_provider . . . . . . . . . . . . . . . . . ., 718 Placemark . . . . . . . . . . . . . . . . . . . . . . . . . . 567 placemarkFromCoordinates() . . . . . . . . 567 playlistPlayAtIndex() . . . . . . . . . . . . . . . 524 pop() . . . . . . . . . . . . . . . . . . . . . . . . . . ., 351 Positioned . . . . . . . . . . . . . . . . . . . . . . . . . . .225 pretty . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 430 primaryAccent . . . . . . . . . . . . . . . . . . . . . . 288 primaryColor . . . . . . . . . . . . . . . . . . . . . . . .288 processImage() . . . . . . . . . . . . . . . . . . . . . . 636 Provider . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291 Provider<T> . . . . . . . . . . . . . . . . . . . . . . . 731 ProviderScope . . . . . . . . . . . . . . . . . . . . . . .728 pubspec . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211 pubspec.yaml . . . . . . . . . . . . . . . . . . ., 206 pump . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 451 pump() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 451 pumpWidget . . . . . . . . . . . . . . . . . . . . . . . . 450 pumpWidget() . . . . . . . . . . . . . . . . . , 452 pushNamed() . . . . . . . . . . . . . . , , 351 putIfAbsent() . . . . . . . . . . . . . . . . . . . . . . . 147 Q QueryDocumentSnapshot . . . . . . . . . . . .617 queryParameters . . . . . . . . . . . . . . . . . . . . 482 QuerySnapshot . . . . . . . . . . . . . . . . . . . . . .619 quiz . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 R RadialGradient . . . . . . . . . . . . . . . . . . . . . .224 RaisedButton . . . . . . . . . . . . . . . . . . . . . . . 261 Raster thread . . . . . . . . . . . . . . . . . . . . . . . 462 ReceivePort . . . . . . . . . . . . . . . . . . . . . . . . . 184 recursive . . . . . . . . . . . . . . . . . . . . . . . . . . . . 719 reduce() . . . . . . . . . . . . . . . . . . . . . . . . . . . . .154 reload() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 659 remainder() . . . . . . . . . . . . . . . . . . . . . . . . . 722 RenderObject . . . . . . . . . . . . . . . . . . . . . . . 245 repeat() . . . . . . . . . . . . . . . . . . . . . . . . , 402 ReplayBloc . . . . . . . . . . . . . . . . . . . . . . . . . .328 ReplayBlocMixin . . . . . . . . . . . . . . . . . . . . 330 ReplayCubit<T> . . . . . . . . . . . . . . . . . . . 333 requestNoti\ufb01cationPermissions() . . . . .646 required . . . . . . . . . . . . . . . . . . . . . . . . . , 228 reset() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 723 resizeToAvoidBottomInset . . . . . . . . . . . 537 ResolutionPreset . . . . . . . . . . . . . . . . . . . . 557 Response . . . . . . . . . . . . . . . . . . , , 482 Flutter Complete Reference 761 Index ResponseType.bytes . . . . . . . . . . . . . . . . . 514 rethrow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135 reverse engineering . . . . . . . . . . . . . . . . . . 724 reverse() . . . . . . . . . . . . . . . . . . . . . . . ., 402 ReverseAnimation . . . . . . . . . . . . . . . . . . . 402 RewardedVideoAd . . . . . . . . . . . . . ., 633 Riverpod . . . . . . . . . . . . . . . . . . . . . . . . . . . . 727 rootBundle . . . . . . . . . . . . . . . . . . . . . . . . . . 503 rotateX() . . . . . . . . . . . . . . . . . . . . . . . . . . . .407 rotateY() . . . . . . . . . . . . . . . . . . . . . . . . . . . .407 rotateZ() . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407 RoundedRectangleBorder . . . . . . . . . . . .263 route . . . . . . . . . . . . . . . . . . . . . . . . . . . , 341 RouteGenerator . . . . . . . . . . . . . . . . . . . . . 342 Router . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 348 Row . . . . . . . . . . . . . . . . . . . . . . . . . . . . \u2013221 rowsPerPage . . . . . . . . . . . . . . . . . . . . . . . . 590 runApp() . . . . . . . . . . . . . . . . . . . . . . . . . . . .215 runTransaction() . . . . . . . . . . . . . . . . . . . . 618 S Sca\ufb00old . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257 scale() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 408 screenshot() . . . . . . . . . . . . . . . . . . . . . . . . . 457 scroll() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 457 scrollDirection . . . . . . . . . . . . . . . . . . . . . . .222 secondChild . . . . . . . . . . . . . . . . . . . . . . . . . 391 selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539 Selector<T> . . . . . . . . . . . . . . . . . . . . . . . . 310 Semantic . . . . . . . . . . . . . . . . . . . . . . . . . . . . 745 semantic tree . . . . . . . . . . . . . . . . . . . . . . . .747 sendEmailVeri\ufb01cation() . . . . . . . . . . . . . .658 SendPort . . . . . . . . . . . . . . . . . . . . . . . . . . . .184 set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . , 106 Set<T> . . . . . . . . . . . . . . . . . . . . . . . . , 146 setMockInitialValues() . . . . . . . . . . . . . . .572 setPersistence() . . . . . . . . . . . . . . . . . . . . . 658 setState . . . . . . . . . . . . . . . . . . . . . . . . \u2013231 setState() . . . . . . . . . . . . . . . . . . . . . . . . . . . 291 setter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .96 setUpAll() . . . . . . . . . . . . . . . . . . . . . . . . . . 457 SharedPreferences . . . . . . . . . . . . . . . . . . . 572 short if . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56 shouldRepaint() . . . . . . . . . . . . . . . . . . . . . 641 show . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78 showBottomSheet . . . . . . . . . . . . . . . . . . . 265 showDialog() . . . . . . . . . . . . . . . . . . . . . . . . 262 showDialog<T>() . . . . . . . . . . . . . . . . . . .548 showFirst . . . . . . . . . . . . . . . . . . . . . . . . . . . 391 showModalBottomSheet<T> . . . . . . . .593 shrinkWrap . . . . . . . . . . . . . . . . . . . . . . . . . .285 SimpleDialog . . . . . . . . . . . . . . . . . . . . . . . . 264 SingleChildScrollView . . . . . . . . . . . . . . . 534 skewY() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407 Skia . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 skip . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 448 skip() . . . . . . . . . . . . . . . . . . . . . . . . . . , 171 sleep() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169 Slider . . . . . . . . . . . . . . . . . . . . . . . . . . , 522 SlideTransition . . . . . . . . . . . . . . . . . , 415 SlidingPageRoute . . . . . . . . . . . . . . . . . . . 415 smart cast . . . . . . . . . . . . . . . . . . . . . . . . . . . .52 SOLID . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187 sortAscending . . . . . . . . . . . . . . . . . . . . . . . 587 SplayTreeMap<K,V> . . . . . . . . . . . . . . . 149 spread operator . . . . . . . . . . . . . . . . . . . . . 142 SRP . . . . . . . . . . . . . . . . . . . . . . . . . . . ., 189 Stack . . . . . . . . . . . . . . . . . . . . . . . . . . ., 405 start() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 723 State<T> . . . . . . . . . . . . . . . . . . . . . . , 230 Stateful widget . . . . . . . . . . . . . . . . . . . . . . 228 StatefulWidget . . . . . . . ., , , 233 StatelessWidget . . . . . . ., , , 233 StateNoti\ufb01er<T> . . . . . . . . . . . . . . . . . . . 604 StateNoti\ufb01erProvider . . . . . . . . . . . . . . . .604 StateProvider<T> . . . . . . . . . . . . . , 732 static . . . . . . . . . . . . . . . . . . . . . . . . . . . . . , 91 Step . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .585 Stepper . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 584 stop() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 723 Flutter Complete Reference 762 Index Stopwatch . . . . . . . . . . . . . . . . . . . . . . . . . . .723 stream . . . . . . . . . . . . . . . . . . . . . . . . . , 167 Stream<T> . . . . . . . . . . . . . . . . . . . . , 169 Stream<T>.empty() . . . . . . . . . . . . . . . . 171 Stream<T>.error() . . . . . . . . . . . . . . . . . 170 Stream<T>.fromFuture() . . . . . . . . . . . 170 Stream<T>.fromIterable() . . . . . . . . . . 170 Stream<T>.periodic() . . . . . . . . . . . . . . 170 Stream<T>.value() . . . . . . . . . . . . . . . . . 170 StreamBuilder<T> . . . . . . . . , , 565 StreamProvider<T> . . . . . . . . . . . . . . . . 733 StringBu\ufb00er . . . . . . . . . . . . . . . . . . . . . . , 43 subscribeToTopic() . . . . . . . . . . . . . . . . . . 653 super . . . . . . . . . . . . . . . . . . . . . . , , 109 SvgPicture . . . . . . . . . . . . . . . . . . . . . . . . . . 512 SvgPicture.memory() . . . . . . . . . . . . . . . .516 SweepGradient . . . . . . . . . . . . . . . . . . . . . . 225 swipe to dismiss . . . . . . . . . . . . . . . . . . . . . 544 switch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56 sync* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169 SynchronousFuture<T> . . . . . . . . . . . . .372 T TabBar . . . . . . . . . . . . . . . . . . . . . . . . ., 582 TabBarView . . . . . . . . . . . . . . . . . . . . . . . . 582 TabController . . . . . . . . . . . . . . . . . . . . . . . 583 TargetPlatform . . . . . . . . . . . . . . . . . . . . . .274 TDD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186 tearDownAll() . . . . . . . . . . . . . . . . . . . . . . .457 test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 439 test() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 439 testWidgets() . . . . . . . . . . . . . . . . . . . . . . . 449 Text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218 TextEditingController . . . . . . . . . . . . . . . 537 TextFormField . . . . . . . . . . . . . . . . . . . . . . 531 TextRecognizer . . . . . . . . . . . . . . . . . . . . . .645 TextStyle . . . . . . . . . . . . . . . . . . . . . . . . . . . 218 Theme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288 Theme.of() . . . . . . . . . . . . . . . . . . . . . . . . . . 288 ThemeData . . . . . . . . . . . . . . . ., , 325 then . . . . . . . . . . . . . . . . . . . . . . . . . . . ., 163 then() . . . . . . . . . . . . . . . . , , , 163 this . . . . . . . . . . . . . . . . . . . . . . , , , 122 throw . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133 throwsA() . . . . . . . . . . . . . . . . . . . . . . . . . . . 442 TickerProviderStateMixin . . . . . . . . . . . 396 Timer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177 toJson() . . . . . . . . . . . . . . . . . . . . . . . . . . . . .420 toString() . . . . . . . . . . . . . . . . . . . ., , 124 toXmlString . . . . . . . . . . . . . . . . . . . . . . . . .436 Transform . . . . . . . . . . . . . . . . . . . . . . , 405 Transform.rotate() . . . . . . . . . . . . . . . . . . 394 translate() . . . . . . . . . . . . . . . . . . . . . ., 409 tree shaking . . . . . . . . . . . . . . . . . . . . . . . . . 213 try . . . . . . . . . . . . . . . . . . . . . . . . , , 134 ttf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209 Tween<T> . . . . . . . . . . . . . . . . . . . . . . . . . 402 typedef . . . . . . . . . . . . . . . . . . . . . . . . . . . , 73 U UI thread . . . . . . . . . . . . . . . . . . . . . . . . . . . 462 Uint8List . . . . . . . . . . . . . . . . . . . . . . . . . . . .717 UniqueKey . . . . . . . . . . . . . . . . . . . . . . . . . . 234 Unit test . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437 unmodi\ufb01able() . . . . . . . . . . . . . . . . . . . . . . 150 Unmodi\ufb01ableListView<T> . . . . . . . . . .145 update() . . . . . . . . . . . . . . . . . . . . . . . . . . . . 742 useAnimationController() . . . . . . . . . . . 599 useFuture<T>() . . . . . . . . . . . . . . . . . . . . 602 useMemoized<T> . . . . . . . . . . . . . . . . . . .602 UserAccelerometerEvent . . . . . . . . . . . . .560 userChanges() . . . . . . . . . . . . . . . . . . . . . . . 657 useStream<T>() . . . . . . . . . . . . . . . . . . . .601 useTabController() . . . . . . . . . . . . . . . . . . 601 useTextEditingController() . . . . . . . . . . 601 utc() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 722 Utf8Decoder() . . . . . . . . . . . . . . . . . . . . . . .431 V ValueKey . . . . . . . . . . . . . . . . . . . . . . . . . . . 233 ValueKey<T> . . . . . . . . . . . . . . . . . . . . . . 233 Flutter Complete Reference 763 Index var . . . . . . . . . . . . . . . . . . . . . . . . \u2013, , 64 verify() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .737 verifyNoMoreInteractions() . . . . . . . . . . 737 video_player . . . . . . . . . . . . . . . . . . . . . . . . 518 VideoControllerPlayer . . . . . . . . . . . . . . . 519 VideoControllerPlayer.asset() . . . . . . . .519 VideoControllerPlayer.\ufb01le() . . . . . . . . . .519 VideoControllerPlayer.network() . . . . .519 VideoPlayerController . . . . . . . . . . . . . . . 518 virtual . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 VirtualDirectory . . . . . . . . . . . . . . . . . . . . 721 vsync . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 396 W wait() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160 watch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 425 WebAssembly . . . . . . . . . . . . . . . . . . . . . . . 243 when() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 446 whenListen() . . . . . . . . . . . . . . . . . . . . . . . . 453 where . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153 where() . . . . . . . . . . . . . . . . . . . ., , 621 while . . . . . . . . . . . . . . . . . . . . . . . . . . . . . , 59 Widget . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .215 Widget test . . . . . . . . . . . . . . . . . . . . . . . . . 437 widget tree . . . . . . . . . . . . . . . . . . . . . . . . . . 215 with . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .116 Wrap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .561 X xml . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429 XmlBuilder . . . . . . . . . . . . . . . . . . . . ., 435 XmlDocument . . . . . . . . . . . . . . . . . ., 431 Y YAML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206 yield . . . . . . . . . . . . . , , , , 175 yield* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175 Flutter Complete Reference 764 Special thanks to Felix Angelov, Matej Re\u0161et\u00e1r, R\u00e9mi Rousselet, Matthew Palomba and Alfred Schilken"
]